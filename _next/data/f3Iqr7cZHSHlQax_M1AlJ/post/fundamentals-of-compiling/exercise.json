{"pageProps":{"title":"编译原理-语法制导翻译实现计算器","description":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","createdAt":"Jun 23, 2016","updatedAt":"Jun 04, 2023","timeToRead":"03min 31s","tags":["编译原理","语法制导翻译","计算机"],"categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"前言"}],"identifier":"heading-前言"},{"type":"paragraph","children":[{"type":"text","value":"设计一个文法，匹配合法的计算式，并返回正确计算式的结果。"}]},{"type":"paragraph","children":[{"type":"text","value":"一些定义："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"语法制导定义（Syntax-directed definitions, "},{"type":"strong","children":[{"type":"text","value":"SDD"}]},{"type":"text","value":"）"}]},{"type":"listItem","children":[{"type":"text","value":"语法制导翻译方案（Syntax-directed Translation Schema, "},{"type":"strong","children":[{"type":"text","value":"SDT"}]},{"type":"text","value":"）"}]}]},{"type":"paragraph","children":[{"type":"text","value":"其它一些编译原理相关的前置知识可以参考： "},{"type":"linkReference","identifier":"compiling-grammar","label":"compiling-grammar","referenceType":"full","children":[{"type":"text","value":"编译原理-语法分析 | 光和尘"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"文法"}],"identifier":"heading-文法"},{"type":"paragraph","children":[{"type":"text","value":"对于一个只支持加减乘除、括号、正负数的计算表达式，不难得到其产生式："}]},{"type":"math","value":"  \\begin{aligned}\n    &A \\rightarrow BD \\mid +BD \\mid -BD \\\\\n    &B \\rightarrow CE \\\\\n    &C \\rightarrow digit \\mid (A) \\\\\n    &D \\rightarrow +BD \\mid -BD \\mid \\varepsilon \\\\\n    &E \\rightarrow \\times CE \\mid \\div CE \\mid \\varepsilon \\\\\n  \\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"可求得它的 "},{"type":"inlineMath","value":"\\mathsf{FIRST}"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"\\mathsf{FOLLOW}"},{"type":"text","value":" 集为："}]},{"type":"math","value":"  \\begin{aligned}\n    \\mathsf{FIRST}(A)   &= \\Big\\lbrace digit,(,+,- \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(A)  &= \\Big\\lbrace \\$,) \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(B)   &= \\Big\\lbrace digit,( \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(B)  &= \\Big\\lbrace \\$,),+,- \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(C)   &= \\Big\\lbrace digit,( \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(C)  &= \\Big\\lbrace \\$,),*,\\div,+,- \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(D)   &= \\Big\\lbrace +,-,\\varepsilon \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(D)  &= \\Big\\lbrace \\$,) \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(E)   &= \\Big\\lbrace \\times,\\div,\\varepsilon \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(E)  &= \\Big\\lbrace \\$,),+,- \\Big\\rbrace\\\\\n  \\end{aligned}\n"},{"type":"heading","depth":3,"children":[{"type":"text","value":"LL(1) 预测分析表："}],"identifier":"heading-ll-1-预测分析表"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Token"}]},{"type":"tableCell","children":[{"type":"text","value":"digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"("}]},{"type":"tableCell","children":[{"type":"inlineMath","value":")"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"+"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"-"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"*"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\div"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\$"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"A"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow -BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"B"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"C"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow (A)"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"D"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow -BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"E"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\times CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\div CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"SDD"}],"identifier":"heading-sdd"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"#"}]},{"type":"tableCell","children":[{"type":"text","value":"产生式"}]},{"type":"tableCell","children":[{"type":"text","value":"语义规则"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow -BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= -B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E.inh    &= C.syn\\\\ B.syn &= E.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} C.syn    &= digit.lexval \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow (A)"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} C.syn    &= A.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow +BD_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D_1.inh  &= D.inh + B.syn\\\\ D.syn  &= D_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"7"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow -BD_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D_1.inh  &= D.inh - B.syn\\\\ D.syn  &= D_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"8"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.syn    &= D.inh \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"9"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\times CE_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E_1.inh  &= E.inh \\times C.syn\\\\ E.syn &= E_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"10"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\div CE_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E_1.inh  &= E.inh \\div C.syn\\\\ E.syn &= E_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"11"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E.syn    &= E.inh \\end{align}"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"C++"}]},{"type":"code","lang":"cpp","meta":"title=\"calculator.cpp\" sourcefile=\"./calculator.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <exception>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct node {\n  int id, syn, inh;\n  node(int id = 0, int syn = 0, int inh = 0) : id(id), syn(syn), inh(inh) {\n  }\n};\nchar ll1Idx[128];\nint ll1Table[10][10];\nvector<int> ssdTable[10];\n\ninline int idx(char c) {\n  return ll1Idx[c];\n}\n\ninline void initLL1Table() {\n  memset(ll1Idx, 0, sizeof ll1Idx);\n  memset(ll1Table, -1, sizeof ll1Table);\n\n  for (int k = '0'; k <= '9'; ++k) ll1Idx[k] = 1;\n  ll1Idx['('] = 2;\n  ll1Idx[')'] = 3;\n  ll1Idx['+'] = 4;\n  ll1Idx['-'] = 5;\n  ll1Idx['*'] = 6;\n  ll1Idx['/'] = 7;\n  ll1Idx['$'] = 8;\n\n  ll1Idx['A'] = -1;\n  ll1Idx['B'] = -2;\n  ll1Idx['C'] = -3;\n  ll1Idx['D'] = -4;\n  ll1Idx['E'] = -5;\n\n  // 0: A -> BD\n  ll1Table[1][1] = 0;\n  ll1Table[1][2] = 0;\n\n  // 1: A -> +BD\n  ll1Table[1][4] = 1;\n\n  // 2: A -> -BD\n  ll1Table[1][5] = 2;\n\n  // 3: B --> CE\n  ll1Table[2][1] = 3;\n  ll1Table[2][2] = 3;\n\n  // 4: C --> digit\n  ll1Table[3][1] = 4;\n\n  // 5: C --> (A)\n  ll1Table[3][2] = 5;\n\n  // 6: D --> +BD\n  ll1Table[4][4] = 6;\n\n  // 7: D --> -BD\n  ll1Table[4][5] = 7;\n\n  // 8: D --> \\varepsilon\n  ll1Table[4][3] = 8;\n  ll1Table[4][8] = 8;\n\n  // 9: E --> *CE\n  ll1Table[5][6] = 9;\n\n  // 10: E --> /CE\n  ll1Table[5][7] = 10;\n\n  // 11: E --> \\varepsilon\n  ll1Table[5][3] = 11;\n  ll1Table[5][4] = 11;\n  ll1Table[5][5] = 11;\n  ll1Table[5][8] = 11;\n}\n\n\ninline void initSSDTable() {\n#define pb push_back\n  for (int i = 0; i < 10; ++i) ssdTable[i].clear();\n\n  // 0: A --> BD\n  ssdTable[0].pb(idx('B'));\n  ssdTable[0].pb(idx('D'));\n\n  // 1: A --> +BD\n  ssdTable[1].pb(idx('+'));\n  ssdTable[1].pb(idx('B'));\n  ssdTable[1].pb(idx('D'));\n\n  // 2: A --> -BD\n  ssdTable[2].pb(idx('-'));\n  ssdTable[2].pb(idx('B'));\n  ssdTable[2].pb(idx('D'));\n\n  // 3: B --> CE\n  ssdTable[3].pb(idx('C'));\n  ssdTable[3].pb(idx('E'));\n\n  // 4: C --> digit\n  ssdTable[4].pb(idx('0'));\n\n  // 5: C -> (A)\n  ssdTable[5].pb(idx('('));\n  ssdTable[5].pb(idx('A'));\n  ssdTable[5].pb(idx(')'));\n\n  // 6: D --> +BD\n  ssdTable[6].pb(idx('+'));\n  ssdTable[6].pb(idx('B'));\n  ssdTable[6].pb(idx('D'));\n\n  // 7: D --> -BD\n  ssdTable[7].pb(idx('-'));\n  ssdTable[7].pb(idx('B'));\n  ssdTable[7].pb(idx('D'));\n\n  // 8: D --> \\varepsilon\n\n  // 9: E --> *CE\n  ssdTable[9].pb(idx('*'));\n  ssdTable[9].pb(idx('C'));\n  ssdTable[9].pb(idx('E'));\n\n  // 10: E --> /CE\n  ssdTable[10].pb(idx('/'));\n  ssdTable[10].pb(idx('C'));\n  ssdTable[10].pb(idx('E'));\n\n  // 11: E --> \\varepsilon\n#undef pb\n}\n\nint getnum(const char*& s) {\n  int num = 0;\n  for (; isdigit(*s); ++s) num = num * 10 + *s - '0';\n  return num;\n}\n\nconst int endsym = idx('$');\nvoid calculate(const char*& s, node& sy, int cur) {\n  int id = idx(*s);\n  if (!id) throw \"Syntax Error\";\n\n  if (sy.id != endsym) {\n    if (sy.id == id) {\n      if (id == 1) {\n        sy.syn = getnum(s);\n      } else {\n        ++s;\n      }\n      return;\n    }\n    if (sy.id > 0) throw \"Syntax Error!\";\n\n    int Mid = ll1Table[-sy.id][id];\n    if (Mid < 0) throw \"Syntax Error!\";\n\n    node sym[4];\n\n    for (int i = 0; i < ssdTable[Mid].size(); ++i) sym[i].id = ssdTable[Mid][i];\n    if (ssdTable[Mid].size()) calculate(s, sym[0], cur + 1);\n\n    switch (Mid) {\n      // 0: A --> BD\n      case 0:\n        sym[1].inh = sym[0].syn;\n        calculate(s, sym[1], cur + 1);\n        sy.syn = sym[1].syn;\n        break;\n\n      // 1: A --> +BD\n      case 1:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 2: A --> -BD\n      case 2:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = -sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 3: B --> CE\n      case 3:\n        sym[1].inh = sym[0].syn;\n        calculate(s, sym[1], cur + 1);\n        sy.syn = sym[1].syn;\n        break;\n\n      // 4: C --> digit\n      case 4:\n        sy.syn = sym[0].syn;\n        break;\n\n      // 5: C --> (A)\n      case 5:\n        calculate(s, sym[1], cur + 1);\n        sy.syn = sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        break;\n\n      // 6: D --> +BD\n      case 6:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh + sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 7: D --> -BD\n      case 7:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh - sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 8: D --> \\varepsilon\n      case 8:\n        sy.syn = sy.inh;\n        break;\n\n      // 9: E --> *CE\n      case 9:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh * sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 10: E --> /CE\n      case 10:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh / sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 11: E --> \\varepsilon\n      case 11:\n        sy.syn = sy.inh;\n        break;\n    }\n  }\n}\n\nint main() {\n  string in;\n  string coin;\n  initLL1Table();\n  initSSDTable();\n  while (getline(cin, in)) {\n    in.push_back('$');\n    int len = in.length();\n    const char* s = in.c_str();\n\n    // 去除空格\n    coin.clear();\n    for (int i = 0; i < len; ++i)\n      if (s[i] != ' ' && s[i] != '\\t' && s[i] != '\\n') coin.push_back(s[i]);\n    coin.push_back('\\0');\n\n    try {\n      node sy = node(idx('A'));\n      s = coin.c_str();\n      calculate(s, sy, 0);\n      int ans = sy.syn;\n      for (int i = 0; i < len - 1; ++i) putchar(in[i]);\n      printf(\" = %d\\n\", ans);\n      printf(\"succuss!\\n\");\n    } catch (const char* str) {\n      puts(str);\n    }\n  }\n  return 0;\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"Typescript (可以直接使用 "},{"type":"linkReference","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/calculate"}]},{"type":"text","value":")"}]},{"type":"code","lang":"typescript","meta":"title=\"calculator.ts\" sourcefile=\"./calculator.ts\" maxlines=\"20\" collapsed linenos","value":"export function calculate(rawExpression: string): number {\n  let cur = 0\n  const expression = rawExpression.replace(/[\\s]+/g, '')\n  const result: number = dfs(idx('A'), 0, 0)\n  return cur === expression.length ? result : Number.NaN\n\n  function dfs(id: number, syn: number, inh: number): number {\n    if (cur === expression.length) {\n      // Only D and E could be parsed as \\varepsilon\n      if (id === TokenSymbol.D || id === TokenSymbol.E) return inh\n      return Number.NaN\n    }\n\n    const id0 = idx(expression[cur])\n\n    // Unrecognized symbol.\n    if (id0 === undefined) return Number.NaN\n\n    // Matched an operator.\n    if (id === id0) {\n      // Matched digits.\n      if (id0 === TokenSymbol.DIGIT) {\n        const [nextCur, value] = getNum(expression, cur)\n\n        // No valid digit found.\n        if (cur === nextCur) return Number.NaN\n\n        cur = nextCur\n        return value\n      }\n\n      cur += 1\n      return syn\n    }\n\n    // Syntax error.\n    if (id > 0) return Number.NaN\n\n    const ssdId = ll1Table[-id][id0]\n    if (ssdId < 0) return Number.NaN\n\n    const tokens: ReadonlyArray<number> = sddTable[ssdId]\n    const syn0: number = tokens.length > 0 ? dfs(tokens[0], 0, 0) : 0\n\n    switch (ssdId) {\n      // 0: A --> BD\n      case 0:\n        return dfs(tokens[1], 0, syn0)\n\n      // 1: A --> +BD\n      case 1: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, val1)\n      }\n\n      // 2: A --> -BD\n      case 2: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, -val1)\n      }\n\n      // 3: B --> CE\n      case 3:\n        return dfs(tokens[1], 0, syn0)\n\n      // 4: C --> digit\n      case 4:\n        return syn0\n\n      // 5: C --> (A)\n      case 5: {\n        const result: number = dfs(tokens[1], 0, 0)\n        dfs(tokens[2], 0, 0)\n        return result\n      }\n\n      // 6: D --> +BD\n      case 6: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh + val1)\n      }\n\n      // 7: D --> -BD\n      case 7: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh - val1)\n      }\n\n      // 8: D --> \\varepsilon\n      case 8:\n        return inh\n\n      // 9: E --> *CE\n      case 9: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh * val1)\n      }\n\n      // 10: E --> /CE\n      case 10: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh / val1)\n      }\n\n      // 11: E --> \\varepsilon\n      case 11:\n        return inh\n    }\n\n    return 0\n  }\n}\n\nexport enum TokenSymbol {\n  DIGIT = 1,\n  OPEN_PAREN = 2,\n  CLOSE_PAREN = 3,\n  PLUS = 4,\n  MINUS = 5,\n  MULTI = 6,\n  DIVIDE = 7,\n  END = 8,\n  A = -1,\n  B = -2,\n  C = -3,\n  D = -4,\n  E = -5,\n}\n\n/**\n * Priority map.\n */\nconst ll1IdxMap: Record<string, TokenSymbol> = Object.freeze({\n  '0': TokenSymbol.DIGIT,\n  '1': TokenSymbol.DIGIT,\n  '2': TokenSymbol.DIGIT,\n  '3': TokenSymbol.DIGIT,\n  '4': TokenSymbol.DIGIT,\n  '5': TokenSymbol.DIGIT,\n  '6': TokenSymbol.DIGIT,\n  '7': TokenSymbol.DIGIT,\n  '8': TokenSymbol.DIGIT,\n  '9': TokenSymbol.DIGIT,\n  '(': TokenSymbol.OPEN_PAREN,\n  ')': TokenSymbol.CLOSE_PAREN,\n  '+': TokenSymbol.PLUS,\n  '-': TokenSymbol.MINUS,\n  '*': TokenSymbol.MULTI,\n  '/': TokenSymbol.DIVIDE,\n  $: TokenSymbol.END,\n  A: TokenSymbol.A,\n  B: TokenSymbol.B,\n  C: TokenSymbol.C,\n  D: TokenSymbol.D,\n  E: TokenSymbol.E,\n})\n\nexport const idx = (c: string): number => ll1IdxMap[c]\n\nexport const sddTable: number[][] = [\n  'BD', //    0: A --> BD\n  '+BD', //   1: A --> +BD\n  '-BD', //   2: A --> -BD\n  'CE', //    3: B --> CE\n  '0', //     4: C --> digit\n  '(A)', //   5: C --> (A)\n  '+BD', //   6: D --> +BD\n  '-BD', //   7: D --> -BD\n  '', //      8: D --> \\varepsilon\n  '*CE', //   9: E --> *CE\n  '/CE', //  10: E --> /CE\n  '', //     11: E --> \\varepsilon\n].map(x => x.split('').map(idx))\n\n// tokens: A,B,C,D,E\nexport const MAX_TOKENS = 5\n\n// symbols: digit, (, ), +, -, *, /, $\nexport const MAX_SYMBOLS = 8\n\n// LL1 table.\nexport const ll1Table: Int8Array[] = new Array(MAX_TOKENS + 1)\n\n// Initialize LL1Table\n{\n  for (let i = 0; i <= MAX_TOKENS; ++i) {\n    ll1Table[i] = new Int8Array(MAX_SYMBOLS + 1).fill(-1)\n  }\n\n  // 0: A -> BD\n  ll1Table[1][1] = 0\n  ll1Table[1][2] = 0\n\n  // 1: A -> +BD\n  ll1Table[1][4] = 1\n\n  // 2: A -> -BD\n  ll1Table[1][5] = 2\n\n  // 3: B --> CE\n  ll1Table[2][1] = 3\n  ll1Table[2][2] = 3\n\n  // 4: C --> digit\n  ll1Table[3][1] = 4\n\n  // 5: C --> (A)\n  ll1Table[3][2] = 5\n\n  // 6: D --> +BD\n  ll1Table[4][4] = 6\n\n  // 7: D --> -BD\n  ll1Table[4][5] = 7\n\n  // 8: D --> \\varepsilon\n  ll1Table[4][3] = 8\n  ll1Table[4][8] = 8\n\n  // 9: E --> *CE\n  ll1Table[5][6] = 9\n\n  // 10: E --> /CE\n  ll1Table[5][7] = 10\n\n  // 11: E --> \\varepsilon\n  ll1Table[5][3] = 11\n  ll1Table[5][4] = 11\n  ll1Table[5][5] = 11\n  ll1Table[5][8] = 11\n}\n\nexport function getNum(s: string, start: number): [number, number] {\n  let result = 0\n  let i: number = start\n  for (; i < s.length; ++i) {\n    const c = s[i]\n    if (!/\\d/.test(c)) break\n    result = result * 10 + Number(c)\n  }\n  return [i, result]\n}\n"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"linkReference","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/calculate"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"compiling-grammar","label":"compiling-grammar","referenceType":"full","children":[{"type":"text","value":"编译原理-语法分析 | 光和尘"}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-前言","contents":[{"type":"text","value":"前言"}],"children":[]},{"depth":2,"identifier":"heading-文法","contents":[{"type":"text","value":"文法"}],"children":[{"depth":3,"identifier":"heading-ll-1-预测分析表","contents":[{"type":"text","value":"LL(1) 预测分析表："}],"children":[]},{"depth":3,"identifier":"heading-sdd","contents":[{"type":"text","value":"SDD"}],"children":[]}]},{"depth":2,"identifier":"heading-程序实现","contents":[{"type":"text","value":"程序实现"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"@algorithm.ts/calculate":{"type":"definition","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","url":"https://github.com/guanghechen/algorithm.ts/tree/main/packages/calculate#readme"},"compiling-grammar":{"type":"definition","identifier":"compiling-grammar","label":"compiling-grammar","url":"/post/fundamentals-of-compiling/grammar/"}},"footnoteDefinitionMap":{},"paginationUrl":"/posts/5","prev":{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar"},"next":{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E"},"aplayerOptions":null,"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"__N_SSG":true}