<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta name="application-name" content="guanghechen"/><meta name="apple-mobile-web-app-title" content="光和尘"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="description" content="Guanghechen&#x27;s personal site"/><meta name="format-detection" content="telephone=no"/><meta name="mobile-web-app-capable" content="yes"/><meta name="msapplication-config" content="/icons/browserconfig.xml"/><meta name="msapplication-TileColor" content="#2B5797"/><meta name="msapplication-tap-highlight" content="no"/><meta name="theme-color" content="#a2466c"/><link rel="manifest" href="/manifest.json"/><link rel="shortcut icon" href="/favicon.png"/><meta property="og:type" content="website"/><meta property="og:title" content="光和尘"/><meta property="og:description" content="光和尘的个人站点"/><meta property="og:site_name" content="guanghechen"/><meta property="og:url" content="https://me.guanghechen.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Roboto+Mono&amp;display=swap"/><link rel="preload" href="/_next/static/css/f6e2a3135d0744b2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f6e2a3135d0744b2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2159a4b672631e08.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2159a4b672631e08.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b364002f74c8bef4.js" defer=""></script><script src="/_next/static/chunks/framework-18c7e6fcf99e5daa.js" defer=""></script><script src="/_next/static/chunks/main-881697fc9a01f7ab.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d30f69c091586e2f.js" defer=""></script><script src="/_next/static/chunks/554-0ae36613042b30fd.js" defer=""></script><script src="/_next/static/chunks/724-59b1a7f2cbe70306.js" defer=""></script><script src="/_next/static/chunks/997-b0975c06e066394a.js" defer=""></script><script src="/_next/static/chunks/515-cfa1deacb9c88e57.js" defer=""></script><script src="/_next/static/chunks/198-040287fcec2acc1b.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5B...slug%5D-852cb19b1bf36bb3.js" defer=""></script><script src="/_next/static/a2GHX3dzrrGOQuNQX5n_t/_buildManifest.js" defer=""></script><script src="/_next/static/a2GHX3dzrrGOQuNQX5n_t/_ssgManifest.js" defer=""></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap"/></head><body><div id="__next"><div class="css-pwdx5x"><style data-emotion="css z01bqi animation-61bdi0">.css-z01bqi{display:inline-block;color:#1976d2;-webkit-animation:animation-61bdi0 1.4s linear infinite;animation:animation-61bdi0 1.4s linear infinite;}@-webkit-keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style><span class="MuiCircularProgress-root MuiCircularProgress-indeterminate MuiCircularProgress-colorPrimary css-z01bqi" style="width:40px;height:40px" role="progressbar"><style data-emotion="css 13o7eu2">.css-13o7eu2{display:block;}</style><svg class="MuiCircularProgress-svg css-13o7eu2" viewBox="22 22 44 44"><style data-emotion="css 14891ef animation-1p2h4ri">.css-14891ef{stroke:currentColor;stroke-dasharray:80px,200px;stroke-dashoffset:0;-webkit-animation:animation-1p2h4ri 1.4s ease-in-out infinite;animation:animation-1p2h4ri 1.4s ease-in-out infinite;}@-webkit-keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}@keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}</style><circle class="MuiCircularProgress-circle MuiCircularProgress-circleIndeterminate css-14891ef" cx="44" cy="44" r="20.2" fill="none" stroke-width="3.6"></circle></svg></span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"伸展树专题","description":"伸展树专题","slug":"/post/data-structure/bbst/splay","createdAt":"Jul 03, 2016","updatedAt":"Oct 06, 2022","timeToRead":"06min 20s","tags":["acm","Splay","解题报告","专题训练"],"categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"题目"}],"identifier":"heading-题目"},{"type":"heading","depth":3,"children":[{"type":"text","value":"hihoCoder/1329"}],"identifier":"heading-hihocoder-1329"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hiho-coder-1329","label":"problem-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1329 平衡树 Splay"}]}]},{"type":"paragraph","children":[{"type":"text","value":"基础题。"}]},{"type":"code","lang":"cpp","meta":"title=\"hihocoder-1329.cpp\" sourcefile=\"./hihocoder-1329.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\n\ntypedef long long LL;\n\nstruct node {\n  int key;\n  int siz;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson-\u003esiz + 1;\n    if (x == cnt) return -1;\n    return x \u003c cnt ? 0 : 1;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n  }\n};\n\ntypedef node* root;\ntypedef std::pair\u003cnode*, node*\u003e droot;\nconst int MAX_NODES = 200000 + 10;\n\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003elson = null;\n  nodetop-\u003erson = null;\n  return nodetop++;\n}\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = null;\n  o-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\ninline int rank(root o, int key) {\n  if (o == null) return 0;\n  if (key == o-\u003ekey) return o-\u003elson-\u003esiz;\n  if (key \u003c o-\u003ekey) return rank(o-\u003elson, key);\n  return o-\u003elson-\u003esiz + 1 + rank(o-\u003erson, key);\n}\n\ninline void insert(root\u0026 o, int id) {\n  int k = rank(o, id);\n  root left, right;\n  root middle = newnode(id);\n  split(o, k, left, right);\n  o = merge(merge(left, middle), right);\n}\n\ninline void remove(root\u0026 o, int id1, int id2) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 \u003e= k2) return;\n\n  root left, middle, right;\n  split(o, k1, left, right);\n  split(right, k2 - k1, middle, right);\n  o = merge(left, right);\n}\n\ninline int query(root\u0026 o, int key) {\n  if (o == null) return 0;\n  if (key \u003c o-\u003ekey) return query(o-\u003elson, key);\n  return std::max(o-\u003ekey, query(o-\u003erson, key));\n}\n\nroot rt;\nvoid Init() {\n  null = new node();\n  null-\u003ekey = 0;\n  null-\u003esiz = 0;\n  null-\u003elson = NULL;\n  null-\u003erson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(0);\n  rt-\u003erson = newnode(1000000001);\n}\n\nint N, arg1, arg2, arg3;\nchar cmd[20];\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nint main() {\n  Init();\n  N = read();\n  for (int i = 1; i \u003c= N; ++i) {\n    scanf(\"%s\", cmd);\n    arg1 = std::min(std::max(read(), 1), 1000000000);\n    if (cmd[0] == 'D') arg2 = std::min(std::max(read(), 1), 1000000000);\n\n    switch (cmd[0]) {\n    case 'I':\n      insert(rt, arg1);\n      break;\n    case 'Q':\n      printf(\"%lld\\n\", query(rt, arg1));\n      break;\n    case 'D':\n      remove(rt, arg1, arg2);\n      break;\n    }\n  }\n  return 0;\n}\n"},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"hihoCoder/1333"}],"identifier":"heading-hihocoder-1333"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hiho-coder-1333","label":"problem-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1333 平衡树 Splay2"}]}]},{"type":"paragraph","children":[{"type":"text","value":"节点中维护 "},{"type":"inlineCode","value":"add"},{"type":"text","value":"，"},{"type":"inlineCode","value":"sum"},{"type":"text","value":"，"},{"type":"inlineCode","value":"key"},{"type":"text","value":"，"},{"type":"inlineCode","value":"siz"},{"type":"text","value":"，"},{"type":"inlineCode","value":"val"},{"type":"text","value":"；其中"}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineCode","value":"key"},{"type":"text","value":" 为每个人的 "},{"type":"inlineCode","value":"id"}]},{"type":"listItem","children":[{"type":"inlineCode","value":"val"},{"type":"text","value":" 为每个人的兴趣值"}]}]},{"type":"paragraph","children":[{"type":"text","value":"在进行区间操作时，利用 "},{"type":"inlineCode","value":"key"},{"type":"text","value":"，计算出左右区间在 Splay 中的名次，然后使用该名次加上基础 Splay 操作就可以了。"}]},{"type":"code","lang":"cpp","meta":"title=\"hihocoder-1333.cpp\" sourcefile=\"./hihocoder-1333.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003calgorithm\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\n#include \u003ciostream\u003e\n\ntypedef long long LL;\n\nstruct node {\n  int key;\n  int siz;\n  int val;\n  int add;\n  LL sum;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson-\u003esiz + 1;\n    if (x == cnt) return -1;\n    return x \u003c cnt ? 0 : 1;\n  }\n  void pushdown() {\n    if (!add) return;\n    lson-\u003eupdate(add);\n    rson-\u003eupdate(add);\n    add = 0;\n  }\n  void update(int add) {\n    if (this-\u003elson == NULL) return;\n    this-\u003eadd += add;\n    this-\u003eval += add;\n    this-\u003esum += (LL)add * this-\u003esiz;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n    sum = lson-\u003esum + val + rson-\u003esum;\n  }\n};\n\ntypedef node* root;\ntypedef std::pair\u003cnode*, node*\u003e droot;\nconst int MAX_NODES = 200000 + 10;\n\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0, int val = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003eval = val;\n  nodetop-\u003eadd = 0;\n  nodetop-\u003esum = val;\n  nodetop-\u003elson = null;\n  nodetop-\u003erson = null;\n  return nodetop++;\n}\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    p-\u003epushdown();\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = null;\n  o-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\ninline int rank(root o, int key) {\n  if (o == null) return 0;\n  if (key == o-\u003ekey) return o-\u003elson-\u003esiz;\n  if (key \u003c o-\u003ekey) return rank(o-\u003elson, key);\n  return o-\u003elson-\u003esiz + 1 + rank(o-\u003erson, key);\n}\n\ninline void insert(root\u0026 o, int id, int val) {\n  int k = rank(o, id);\n  root left, right;\n  root middle = newnode(id, val);\n  split(o, k, left, right);\n  o = merge(merge(left, middle), right);\n}\n\ninline void remove(root\u0026 o, int id1, int id2) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 \u003e= k2) return;\n\n  root left, middle, right;\n  split(o, k1, left, right);\n  split(right, k2 - k1, middle, right);\n  o = merge(left, right);\n}\n\ninline void update(root\u0026 o, int id1, int id2, int add) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 \u003e= k2) return;\n\n  splay(o, k1);\n  splay(o-\u003erson, k2 - k1 + 1);\n  o-\u003erson-\u003elson-\u003eupdate(add);\n  o-\u003erson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline LL query(root\u0026 o, int id1, int id2) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 \u003e= k2) return 0;\n\n  splay(o, k1);\n  splay(o-\u003erson, k2 - k1 + 1);\n  return o-\u003erson-\u003elson-\u003esum;\n}\n\nroot rt;\nvoid Init() {\n  null = new node();\n  null-\u003ekey = 0;\n  null-\u003esiz = 0;\n  null-\u003eval = 0;\n  null-\u003eadd = 0;\n  null-\u003esum = 0;\n  null-\u003elson = NULL;\n  null-\u003erson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(0, 0);\n  rt-\u003erson = newnode(1000000001, 0);\n}\n\nint N, arg1, arg2, arg3;\nchar cmd[20];\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nint main() {\n  Init();\n  N = read();\n  for (int i = 1; i \u003c= N; ++i) {\n    scanf(\"%s\", cmd);\n    arg1 = std::min(std::max(read(), 1), 100000000);\n    arg2 = std::min(std::max(read(), 1), 100000000);\n    if (cmd[0] == 'M') arg3 = read();\n\n    switch (cmd[0]) {\n    case 'I':\n      insert(rt, arg1, arg2);\n      break;\n    case 'Q':\n      printf(\"%lld\\n\", query(rt, arg1, arg2));\n      break;\n    case 'M':\n      update(rt, arg1, arg2, arg3);\n      break;\n    case 'D':\n      remove(rt, arg1, arg2);\n      break;\n    }\n  }\n  return 0;\n}\n"},{"type":"thematicBreak"},{"type":"paragraph","children":[{"type":"text","value":"法二：将原序列离散化到 "},{"type":"inlineMath","value":"1 \\sim N"},{"type":"text","value":"，并建成 Splay，多维护一个区间最小值，利用维护的 "},{"type":"inlineCode","value":"siz"},{"type":"text","value":"，就可以实现名次树的一些功能，就可以快速查找了。"}]},{"type":"code","lang":"cpp","meta":"title=\"LA-3961_2.cpp\" sourcefile=\"./LA-3961_2.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\n\nstruct node {\n  int key;\n  int siz;\n  int minv;\n  bool flip;\n  node* lson;\n  node* rson;\n\n  int cmp(int key) {\n    int cnt = lson-\u003esiz + 1;\n    if (key == cnt) return -1;\n    return key \u003c cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson-\u003ereverse();\n    rson-\u003ereverse();\n    flip = false;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n    minv = std::min(key, std::min(lson-\u003eminv, rson-\u003eminv));\n  }\n};\n\ntypedef node* root;\nnode* null;\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    p-\u003epushdown();\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d2 ^ 1);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = null;\n  o-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\ninline int kth(root rt) {\n  rt-\u003epushdown();\n  if (rt-\u003ekey == rt-\u003eminv) return rt-\u003elson-\u003esiz + 1;\n  if (rt-\u003elson-\u003eminv \u003c rt-\u003erson-\u003eminv) return kth(rt-\u003elson);\n  return kth(rt-\u003erson) + rt-\u003elson-\u003esiz + 1;\n}\n\nconst int MAX_NODES = 100000 + 10;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003eminv = key;\n  nodetop-\u003eflip = false;\n  nodetop-\u003elson = null;\n  nodetop-\u003erson = null;\n  return nodetop++;\n}\n\ninline void build(root\u0026 o, int lft, int rht, int* rank) {\n  int mid = (lft + rht) \u003e\u003e 1;\n  o = newnode(rank[mid]);\n  if (lft \u003c mid) build(o-\u003elson, lft, mid - 1, rank);\n  if (mid \u003c rht) build(o-\u003erson, mid + 1, rht, rank);\n  o-\u003emaintain();\n}\n\nconst int MAXN = 100000 + 10;\nconst int INF = 0x3f3f3f3f;\nint N, A[MAXN], id[MAXN], rank[MAXN];\nroot rt;\n\ninline bool cmp(int u, int v) {\n  return A[u] \u003c A[v];\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void init() {\n  nodetop = nodepool;\n}\n\ninline int solve() {\n  int k = kth(rt);\n  splay(rt, k);\n  int ans = rt-\u003elson-\u003esiz;\n  if (ans) {\n    rt-\u003elson-\u003ereverse();\n    splay(rt-\u003elson, rt-\u003elson-\u003esiz);\n    rt = merge(rt-\u003elson, rt-\u003erson);\n  } else\n    rt = rt-\u003erson, rt-\u003epushdown();\n  return ans;\n}\n\nint main() {\n  null = new node();\n  null-\u003ekey = 0;\n  null-\u003esiz = 0;\n  null-\u003eminv = INF;\n  null-\u003eflip = false;\n  null-\u003elson = NULL;\n  null-\u003erson = NULL;\n\n  while (scanf(\"%d\", \u0026N) == 1 \u0026\u0026 N) {\n    init();\n    for (int i = 1; i \u003c= N; ++i) A[i] = read();\n    for (int i = 1; i \u003c= N; ++i) id[i] = i;\n    std::stable_sort(id + 1, id + N + 1, cmp);\n    for (int i = 1; i \u003c= N; ++i) rank[id[i]] = i;\n    build(rt, 1, N, rank);\n    for (int i = 1; i \u003c N; ++i) printf(\"%d \", solve() + i);\n    printf(\"%d\\n\", N);\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/06"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"HYSBZ/1269"}],"identifier":"heading-hysbz-1269"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hysbz-1269","label":"problem-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1269 文本编辑器 editor"}]}]},{"type":"paragraph","children":[{"type":"text","value":"都是一些 Splay 的经典操作，为了方便操作，在最最左边和最右边分别加了一个虚拟节点。"}]},{"type":"code","lang":"cpp","meta":"title=\"hysbz-1269.cpp\" sourcefile=\"./hysbz-1269.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\n\nstruct node {\n  char key;\n  int siz;\n  bool flip;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson-\u003esiz + 1;\n    if (x == cnt) return -1;\n    return x \u003c cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson-\u003ereverse();\n    rson-\u003ereverse();\n    flip ^= 1;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n  }\n};\n\ntypedef node* root;\nconst int MAX_NODES = (1 \u003c\u003c 22) + 10;\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(char key) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003eflip = false;\n  nodetop-\u003elson = null;\n  nodetop-\u003erson = null;\n  return nodetop++;\n}\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    p-\u003epushdown();\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = null;\n  o-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\ninline void build(root\u0026 o, int lft, int rht, char* s) {\n  int mid = (lft + rht) \u003e\u003e 1;\n  o = newnode(s[mid]);\n  if (lft \u003c mid) build(o-\u003elson, lft, mid - 1, s);\n  if (mid \u003c rht) build(o-\u003erson, mid + 1, rht, s);\n  o-\u003emaintain();\n}\n\nconst int MAXN = (1 \u003c\u003c 22) + 10;\nchar s[MAXN];\n\ninline void Move(root\u0026 rt, int k) {\n  splay(rt, k);\n}\ninline void Insert(root\u0026 rt, int n) {\n  for (s[1] = getchar(); s[1] \u003c 32 || s[1] \u003e 126;) s[1] = getchar();\n  for (int i = 2; i \u003c= n; ++i) s[i] = getchar();\n  root left = rt;\n  root middle;\n  build(middle, 1, n, s);\n  root right = rt-\u003erson;\n  rt-\u003erson = null;\n  rt-\u003emaintain();\n  rt = merge(left, merge(middle, right));\n}\ninline void Delete(root\u0026 rt, int n) {\n  splay(rt-\u003erson, n);\n  rt-\u003erson = rt-\u003erson-\u003erson;\n  rt-\u003emaintain();\n}\ninline void Rotate(root\u0026 rt, int n) {\n  splay(rt-\u003erson, n + 1);\n  rt-\u003erson-\u003elson-\u003ereverse();\n}\ninline void Get(root\u0026 rt) {\n  root o = rt-\u003erson;\n  for (; o-\u003elson != null; o = o-\u003elson) o-\u003epushdown();\n  printf(\"%c\\n\", o-\u003ekey);\n}\ninline void Prev(root\u0026 rt) {\n  splay(rt, rt-\u003elson-\u003esiz);\n}\ninline void Next(root\u0026 rt) {\n  splay(rt, rt-\u003elson-\u003esiz + 2);\n}\n\nroot rt;\ninline void Init() {\n  null = new node();\n  null-\u003ekey = '\\0';\n  null-\u003esiz = 0;\n  null-\u003eflip = false;\n  null-\u003elson = NULL;\n  null-\u003erson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(31);\n  rt-\u003erson = newnode(127);\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return s;\n}\n\nchar cmd[20];\n\nint main() {\n  Init();\n\n  int N = read();\n  for (int i = 1; i \u003c= N; ++i) {\n    scanf(\"%s\", cmd);\n    switch (cmd[0]) {\n    case 'M':\n      Move(rt, read() + 1);\n      break;\n    case 'I':\n      Insert(rt, read());\n      break;\n    case 'D':\n      Delete(rt, read());\n      break;\n    case 'R':\n      Rotate(rt, read());\n      break;\n    case 'G':\n      Get(rt);\n      break;\n    case 'P':\n      Prev(rt);\n      break;\n    case 'N':\n      Next(rt);\n      break;\n    }\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/05"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"HYSBZ/1500"}],"identifier":"heading-hysbz-1500"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hysbz-1500","label":"problem-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1500 维修数列"}]}]},{"type":"paragraph","children":[{"type":"text","value":"前五个操作比较简单，第六个操作，需要维护："}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"子树左侧起最大连续和 "},{"type":"inlineMath","value":"mxlv"},{"type":"text","value":"（可以为空）"}]},{"type":"listItem","children":[{"type":"text","value":"子树右侧起最大连续和 "},{"type":"inlineMath","value":"mxrv"},{"type":"text","value":"（可以为空）"}]},{"type":"listItem","children":[{"type":"text","value":"子树中最大连续和 "},{"type":"inlineMath","value":"mxmv"},{"type":"text","value":"（非空）。"}]}]},{"type":"paragraph","children":[{"type":"text","value":"在序列的最左侧和最右侧增加两个虚拟节点就可以很方便了，注意为了不影响结果的正确性，虚拟节点的 sum 值需为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":"，但是节点的 "},{"type":"inlineMath","value":"key,mxlv,mxmv,mxrv"},{"type":"text","value":" 均需设成负无穷。"}]},{"type":"code","lang":"cpp","meta":"title=\"hysbz-1500.cpp\" sourcefile=\"./hysbz-1500.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\n\nconst int INF = 0x3f3f3f3f;\n\nstruct node {\n  int key;\n  int siz;\n  int setv;   // 懒惰标记，表示是否标记为同一个值\n  int sumv;   // 该节点为根的子树的 $\\sum key$\n  int mxlv;   // 该节点为根的子树表示的序列左侧（可以为空）最大连续和\n  int mxmv;   // 该节点为根的子树最大连续和\n  int mxrv;   // 该节点为根的子树表示的序列右侧（可以为空）最大连续和\n  bool flip;   // 懒惰标记，表示是否翻转\n  node* lson;\n  node* rson;\n\n  static node* null;\n\n  int cmp(int x) {\n    int cnt = lson-\u003esiz + 1;\n    if (x == cnt) return -1;\n    return x \u003c cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n    std::swap(mxlv, mxrv);\n  }\n  void update(int tag) {\n    setv = tag;\n    key = tag;\n    sumv = tag * siz;\n    mxlv = mxrv = tag \u003e 0 ? sumv : 0;\n    mxmv = tag \u003e 0 ? sumv : tag;\n  }\n  void pushdown() {\n    if (flip) {\n      lson-\u003ereverse();\n      rson-\u003ereverse();\n      flip = false;\n    }\n    if (setv != -INF) {\n      if (lson != null) lson-\u003eupdate(setv);\n      if (rson != null) rson-\u003eupdate(setv);\n      setv = -INF;\n    }\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n    sumv = lson-\u003esumv + key + rson-\u003esumv;\n    mxlv = std::max(lson-\u003emxlv, lson-\u003esumv + key + rson-\u003emxlv);\n    mxrv = std::max(rson-\u003emxrv, lson-\u003emxrv + key + rson-\u003esumv);\n    mxmv = std::max(lson-\u003emxmv, rson-\u003emxmv);\n    mxmv = std::max(mxmv, lson-\u003emxrv + key + rson-\u003emxlv);\n  }\n};\n\ntypedef node* root;\nnode* node::null = new node();\n\ninline void printtree(root o, int cur = 0) {\n  if (o == node::null) return;\n  o-\u003epushdown();\n  o-\u003emaintain();\n  printtree(o-\u003elson, cur + 1);\n  printf(\"cur %d: key=%d, siz=%d, sum=%d\\n\", cur, o-\u003ekey, o-\u003esiz, o-\u003esumv);\n  printtree(o-\u003erson, cur + 1);\n  if (!cur) printf(\"-------------------------------------\\n\");\n}\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\n\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\n\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    p-\u003epushdown();\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = node::null;\n  o-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\n/********************** 以上为 splay 基本操作 *******************/\n\nconst int MAX_NODES = 1000000 + 10;\nstd::queue\u003croot\u003e Qnodepool;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  root nodetop = Qnodepool.front();\n  Qnodepool.pop();\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003esetv = -INF;\n  nodetop-\u003esumv = key;\n  nodetop-\u003emxlv = key \u003e 0 ? key : 0;\n  nodetop-\u003emxmv = key;\n  nodetop-\u003emxrv = key \u003e 0 ? key : 0;\n  nodetop-\u003eflip = false;\n  nodetop-\u003elson = node::null;\n  nodetop-\u003erson = node::null;\n  return nodetop;\n}\n\ninline void deletenode(root o) {\n  if (o == node::null) return;\n  deletenode(o-\u003elson);\n  deletenode(o-\u003erson);\n  Qnodepool.push(o);\n}\n\ninline void build(root\u0026 o, int lft, int rht, int* A) {\n  int mid = (lft + rht) \u003e\u003e 1;\n  o = newnode(A[mid]);\n  if (lft \u003c mid) build(o-\u003elson, lft, mid - 1, A);\n  if (mid \u003c rht) build(o-\u003erson, mid + 1, rht, A);\n  if (A[mid] == -INF) o-\u003esumv = 0;\n  o-\u003emaintain();\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nconst int MAXN = 500000 + 10;\nint A[MAXN];\nroot rt;\n\ninline void INSERT(int pos, int tot) {\n  for (int i = 1; i \u003c= tot; ++i) A[i] = read();\n  root left, middle, right;\n  build(middle, 1, tot, A);\n  split(rt, pos + 1, left, right);\n  rt = merge(merge(left, middle), right);\n}\n\ninline void DELETE(int pos, int tot) {\n  splay(rt, pos);\n  splay(rt-\u003erson, tot + 1);\n\n  deletenode(rt-\u003erson-\u003elson);\n\n  rt-\u003erson-\u003elson = node::null;\n  rt-\u003erson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\ninline void MODIFY(int pos, int tot, int tag) {\n  splay(rt, pos);\n  splay(rt-\u003erson, tot + 1);\n  rt-\u003erson-\u003elson-\u003eupdate(tag);\n  rt-\u003erson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\ninline void REVERSE(int pos, int tot) {\n  splay(rt, pos);\n  splay(rt-\u003erson, tot + 1);\n  rt-\u003erson-\u003elson-\u003ereverse();\n  rt-\u003erson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\ninline int GETSUM(int pos, int tot) {\n  splay(rt, pos);\n  splay(rt-\u003erson, tot + 1);\n  return rt-\u003erson-\u003elson-\u003esumv;\n}\n\ninline int MAXSUM() {\n  return rt-\u003emxmv;\n}\n\ninline void init() {\n  while (!Qnodepool.empty()) Qnodepool.pop();\n  for (int i = 0; i \u003c MAX_NODES; ++i) Qnodepool.push(nodepool + i);\n  node::null-\u003ekey = -INF;\n  node::null-\u003esiz = 0;\n  node::null-\u003esetv = -INF;\n  node::null-\u003esumv = 0;\n  node::null-\u003emxlv = 0;\n  node::null-\u003emxmv = -INF;\n  node::null-\u003emxrv = 0;\n  node::null-\u003eflip = false;\n  node::null-\u003elson = NULL;\n  node::null-\u003erson = NULL;\n}\n\nint main() {\n  init();\n\n  int N = read();\n  int Q = read();\n\n  for (int i = 1; i \u003c= N; ++i) A[i] = read();\n  A[0] = A[N + 1] = -INF;\n  build(rt, 0, N + 1, A);\n  while (Q--) {\n    char cmd[20];\n    scanf(\"%s\", cmd);\n    if (cmd[0] == 'M' \u0026\u0026 cmd[2] == 'X') {\n      printf(\"%d\\n\", MAXSUM());\n      continue;\n    }\n\n    int arg1 = read();\n    int arg2 = read();\n\n    switch (cmd[0]) {\n    case 'I':\n      INSERT(arg1, arg2);\n      break;\n    case 'D':\n      DELETE(arg1, arg2);\n      break;\n    case 'M':\n      MODIFY(arg1, arg2, read());\n      break;\n    case 'R':\n      REVERSE(arg1, arg2);\n      break;\n    case 'G':\n      printf(\"%d\\n\", GETSUM(arg1, arg2));\n      break;\n    }\n  }\n\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"update time: 2016/07/07"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"HYSBZ/1503"}],"identifier":"heading-hysbz-1503"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hysbz-1503","label":"problem-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1503 郁闷的出纳员"}]}]},{"type":"paragraph","children":[{"type":"text","value":"只需要用 Splay 实现名次树即可。注意由于存在懒惰标记，在查询第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 大，及确定有多少个值比 "},{"type":"inlineMath","value":"key"},{"type":"text","value":" 小，这两个操作的过程中都要一路 "},{"type":"inlineMath","value":"pushdown"},{"type":"text","value":"。"}]},{"type":"admonition","keyword":"tip","title":[{"type":"text","value":"HINT"}],"children":[{"type":"paragraph","children":[{"type":"text","value":"坑点：立即离开公司的人不算入答案。。。"}]}]},{"type":"code","lang":"cpp","meta":"title=\"hysbz-1503.cpp\" sourcefile=\"./hysbz-1503.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\n\nstruct node {\n  int key;\n  int siz;\n  int addv;\n  node* lson;\n  node* rson;\n\n  static node* null;\n\n  int cmp(int s) {\n    int cnt = lson-\u003esiz + 1;\n    if (s == cnt) return -1;\n    return s \u003c cnt ? 0 : 1;\n  }\n  void update(int v) {\n    key += v;\n    addv += v;\n  }\n  void pushdown() {\n    if (!addv) return;\n    if (lson != null) lson-\u003eupdate(addv);\n    if (rson != null) rson-\u003eupdate(addv);\n    addv = 0;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n  }\n};\n\ntypedef node* root;\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\n\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\n\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void printtree(root o, int cur = 0) {\n  if (o == node::null) return;\n  printtree(o-\u003elson, cur + 1);\n  printf(\"cur %d: key=%d, siz=%d\\n\", cur, o-\u003ekey, o-\u003esiz);\n  printtree(o-\u003erson, cur + 1);\n  if (!cur) printf(\"---------------------------------\\n\");\n}\n\ninline void splay(root\u0026 o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    p-\u003epushdown();\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline int kth(root o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == -1) return o-\u003ekey;\n  return d ? kth(o-\u003erson, k - o-\u003elson-\u003esiz - 1) : kth(o-\u003elson, k);\n}\n\ninline int rank(root o, int k) {\n  if (o == node::null) return 0;\n  o-\u003epushdown();\n  if (k \u003c= o-\u003ekey) return rank(o-\u003elson, k);\n  return rank(o-\u003erson, k) + o-\u003elson-\u003esiz + 1;\n}\n\nconst int MAX_NODES = 100000 + 10;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003eaddv = 0;\n  nodetop-\u003elson = node::null;\n  nodetop-\u003erson = node::null;\n  return nodetop++;\n}\n\ninline void insert(root\u0026 rt, int key) {\n  int k = rank(rt, key);\n  splay(rt, k);\n  root left = rt;\n  root middle = newnode(key);\n  root right = rt-\u003erson;\n  left-\u003erson = middle;\n  middle-\u003erson = right;\n  middle-\u003emaintain();\n  left-\u003emaintain();\n  rt = left;\n}\n\ninline void remove(root\u0026 rt, int M) {\n  int k = rank(rt, M);\n  if (k == 1) return;\n  splay(rt, 1);\n  splay(rt-\u003erson, k);\n  rt-\u003erson-\u003elson = node::null;\n  rt-\u003erson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\ninline void update(root\u0026 rt, int addv) {\n  if (rt-\u003esiz == 2) return;\n  splay(rt, 1);\n  splay(rt-\u003erson, rt-\u003erson-\u003esiz);\n  rt-\u003erson-\u003elson-\u003eupdate(addv);\n  rt-\u003erson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\nconst int INF = 0x3f3f3f3f;\nroot rt;\n\nnode* node::null = new node();\ninline void init() {\n  node::null-\u003ekey = 0;\n  node::null-\u003esiz = 0;\n  node::null-\u003eaddv = 0;\n  node::null-\u003elson = NULL;\n  node::null-\u003erson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(-INF);\n  rt-\u003erson = newnode(INF);\n  rt-\u003emaintain();\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nint main() {\n  init();\n\n  int N = read();\n  int M = read();\n  int tot = 2;\n  for (int i = 1; i \u003c= N; ++i) {\n    char cmd[20];\n    scanf(\"%s\", cmd);\n    int arg = read();\n\n    switch (cmd[0]) {\n    case 'I':\n      if (arg \u003e= M) insert(rt, arg), ++tot;\n      break;\n    case 'A':\n      update(rt, arg);\n      break;\n    case 'S':\n      update(rt, -arg);\n      remove(rt, M);\n      break;\n    case 'F':\n      printf(\"%d\\n\", arg \u003c= rt-\u003esiz - 2 ? kth(rt, rt-\u003esiz - arg) : -1);\n      break;\n    }\n  }\n  printf(\"%d\\n\", tot - rt-\u003esiz);\n\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/07"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"LA/3961"}],"identifier":"heading-la-3961"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-la-3961","label":"problem-la-3961","referenceType":"full","children":[{"type":"text","value":"LA/3961 Robotic Sort"}]}]},{"type":"paragraph","children":[{"type":"text","value":"初始时，建一棵 "},{"type":"inlineMath","value":"1 \\sim N"},{"type":"text","value":" 的 Splay，并对原序列进行排序（排序规则为：值小的优先，值相等时，在原序列靠左的优先）。对于第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 次询问，将值为 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的节点伸展至根，然后就是些基础的操作了。问题的难点在于快速找到值为 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的节点。"}]},{"type":"paragraph","children":[{"type":"text","value":"法一：用一个父指针，直接从值为 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的节点往上伸展就好了。之所以扯这么多，是因为此前一直都是用 刘汝佳 的递归写法（被惯坏了），不需要父指针。"}]},{"type":"code","lang":"cpp","meta":"title=\"LA-3961.cpp\" sourcefile=\"./LA-3961.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\n\nstruct node {\n  int key;\n  int siz;\n  bool flip;\n  node* prev;\n  node* lson;\n  node* rson;\n\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson-\u003ereverse();\n    rson-\u003ereverse();\n    flip = false;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n  }\n};\n\ntypedef node* root;\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson-\u003eprev = o;\n  k-\u003elson = o;\n  o-\u003eprev = k;\n  o = k;\n}\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson-\u003eprev = o;\n  k-\u003erson = o;\n  o-\u003eprev = k;\n  o = k;\n}\n// 带父指针的 旋转 和 伸展操作 是此问题最大的难点（蒽，被刘汝佳的代码惯坏了。。\ninline void rotate(root o, int d) {\n  int d2 = -1;\n  root p = o-\u003eprev;\n  if (p != NULL) d2 = p-\u003elson == o ? 0 : 1;\n  d ? zig(o) : zag(o);\n  if (d2 != -1) d2 ? p-\u003erson = o : p-\u003elson = o;\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003eprev = p;\n  o-\u003emaintain();\n}\n\n// 注意，d 必须在 pushdown 之后计算，因为有交换子树的操作。\ninline void splay(root o, root f) {\n  // o 必须先 pushdown() 一次，因为可能 o 已经是 f 的子节点，\n  // 但为了保持 “splay 操作后的根节点标记全部下传” 的传统，需要这么做。\n  for (o-\u003epushdown(); o-\u003eprev != f;) {\n    root p = o-\u003eprev;\n    if (p-\u003eprev == f) {\n      p-\u003epushdown();\n      o-\u003epushdown();\n      int d = p-\u003elson == o ? 0 : 1;\n      rotate(p, d ^ 1);\n      break;\n    }\n\n    root g = p-\u003eprev;\n    g-\u003epushdown();\n    p-\u003epushdown();\n    o-\u003epushdown();\n    int d = p-\u003elson == o ? 0 : 1;\n    int d2 = g-\u003elson == p ? 0 : 1;\n    if (d == d2)\n      rotate(g, d2 ^ 1), rotate(p, d ^ 1);\n    else\n      rotate(p, d ^ 1), rotate(g, d2 ^ 1);\n  }\n}\n\nconst int MAX_NODES = 100000 + 10;\nnode* null;\nnode nodepool[MAX_NODES];\n\ninline void build(root\u0026 o, int lft, int rht) {\n  int mid = (lft + rht) \u003e\u003e 1;\n  o = nodepool + mid;\n  o-\u003ekey = mid;\n  o-\u003esiz = 1;\n  o-\u003eflip = false;\n  if (lft \u003c mid)\n    build(o-\u003elson, lft, mid - 1);\n  else\n    o-\u003elson = null;\n  if (mid \u003c rht)\n    build(o-\u003erson, mid + 1, rht);\n  else\n    o-\u003erson = null;\n  o-\u003elson-\u003eprev = o;\n  o-\u003erson-\u003eprev = o;\n  o-\u003emaintain();\n}\n\ninline int solve(root\u0026 rt, int key) {\n  root o = nodepool + key;\n  splay(o, rt-\u003eprev);\n  int ans = o-\u003elson-\u003esiz;\n  if (ans) {\n    root k = o-\u003elson;\n    k-\u003ereverse();\n    for (; k-\u003erson != null; k = k-\u003erson) k-\u003epushdown();\n    splay(k, o);\n    k-\u003erson = o-\u003erson;\n    o-\u003erson-\u003eprev = k;\n    o = k;\n  } else\n    o = o-\u003erson;\n  rt = o;\n  rt-\u003eprev = NULL;\n  rt-\u003emaintain();\n  return ans;\n}\n\ntypedef std::pair\u003cint, int\u003e pii;\nconst int MAXN = 100000 + 10;\n\nroot rt;\npii A[MAXN];\nint N;\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = true;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void Init() {\n  for (int i = 1; i \u003c= N; ++i) A[i] = pii(read(), i);\n  sort(A + 1, A + N + 1);\n  build(rt, 1, N);\n  rt-\u003eprev = NULL;\n}\n\nint main() {\n  null = new node();\n  null-\u003ekey = 0;\n  null-\u003esiz = 0;\n  null-\u003eflip = false;\n  null-\u003elson = NULL;\n  null-\u003erson = NULL;\n\n  while (scanf(\"%d\", \u0026N) == 1 \u0026\u0026 N) {\n    Init();\n    for (int i = 1; i \u003c N; ++i) printf(\"%d \", solve(rt, A[i].second) + i);\n    printf(\"%d\\n\", N);\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/05"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"POJ/2828"}],"identifier":"heading-poj-2828"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-poj-2828","label":"problem-poj-2828","referenceType":"full","children":[{"type":"text","value":"POJ/2828 Buy Tickets"}]}]},{"type":"paragraph","children":[{"type":"text","value":"法一：在线做。直接 Splay 模拟，容易超时，可以检验自己 Splay 写法常数大不大（不加读入读出优化的前提下）。"}]},{"type":"admonition","keyword":"tip","title":[{"type":"text","value":"HINT"}],"children":[{"type":"paragraph","children":[{"type":"text","value":"POJ 加读入读出优化能快很多 = ="}]}]},{"type":"code","lang":"cpp","meta":"title=\"poj-2828.cpp\" sourcefile=\"./poj-2828.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003calgorithm\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\n#include \u003ciostream\u003e\n\nstruct node {\n  int key;\n  int siz;\n  node* lson;\n  node* rson;\n\n  static node* null;\n\n  int cmp(int x) {\n    int cnt = lson-\u003esiz + 1;\n    if (x == cnt) return -1;\n    return x \u003c cnt ? 0 : 1;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n  }\n};\n\ntypedef node* root;\n\ninline void zag(root\u0026 o) {\n  root k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\n\ninline void zig(root\u0026 o) {\n  root k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\n\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = node::null;\n  o-\u003emaintain();\n}\n\nconst int MAX_NODES = 200000 + 10;\n\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 0;\n  nodetop-\u003elson = node::null;\n  nodetop-\u003erson = node::null;\n  return nodetop++;\n}\n\ninline void insert(root\u0026 rt, int pos, int key) {\n  root left, right;\n  split(rt, pos + 1, left, right);\n  left-\u003erson = newnode(key);\n  left-\u003erson-\u003erson = right;\n  left-\u003erson-\u003emaintain();\n  left-\u003emaintain();\n  rt = left;\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void print(int s) {\n  if (s \u003e 9) print(s / 10);\n  putchar(s % 10 + '0');\n}\n\nnode* node::null = new node();\nroot rt;\nint N;\n\ninline void init() {\n  node::null-\u003ekey = 0;\n  node::null-\u003esiz = 0;\n  node::null-\u003elson = NULL;\n  node::null-\u003erson = NULL;\n}\n\ninline void printtree(root\u0026 o) {\n  if (o == node::null) return;\n  printtree(o-\u003elson);\n  print(o-\u003ekey);\n  putchar(' ');\n  printtree(o-\u003erson);\n}\n\nint main() {\n  init();\n  while (scanf(\"%d\", \u0026N) == 1) {\n    nodetop = nodepool;\n    rt = newnode(0);\n    for (int i = 1; i \u003c= N; ++i) {\n      int arg1 = read();\n      int arg2 = read();\n      insert(rt, arg1, arg2);\n    }\n    splay(rt, 1);\n    printtree(rt-\u003erson);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"text","value":"法二：离线做。类似约瑟夫问题的线段树写法。初始时，维护一个前缀和\n"},{"type":"inlineMath","value":"\\displaystyle sum(N)=\\sum_{i=1}^N i"},{"type":"text","value":"；最后一个人的最终位置显然是 "},{"type":"inlineMath","value":"pos+1"},{"type":"text","value":"，然后去掉这个人，那么倒数第二个人就成了最后一个人了。"}]},{"type":"code","lang":"cpp","meta":"title=\"poj-2828_2.cpp\" sourcefile=\"./poj-2828_2.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003calgorithm\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\n#include \u003ciostream\u003e\n#define lc (o \u003c\u003c 1)\n#define rc (o \u003c\u003c 1 | 1)\n#define lson lc, lft, mid\n#define rson rc, mid + 1, rht\n#define MID(lft, rht) (lft + rht \u003e\u003e 1)\n\nconst int MAXN = 200000 + 10;\n\nint sumv[MAXN \u003c\u003c 2], ans[MAXN], pos[MAXN], val[MAXN], N;\nvoid build(int o, int lft, int rht) {\n  sumv[o] = rht - lft + 1;\n  if (lft == rht) return;\n  int mid = MID(lft, rht);\n  build(lson);\n  build(rson);\n}\n\nvoid query(int o, int lft, int rht, int pos, int val) {\n  --sumv[o];\n  if (lft == rht)\n    ans[lft] = val;\n  else {\n    int mid = MID(lft, rht);\n    if (pos \u003c= sumv[lc])\n      query(lson, pos, val);\n    else\n      query(rson, pos - sumv[lc], val);\n  }\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void print(int s) {\n  if (s \u003e 9) print(s / 10);\n  putchar(s % 10 + '0');\n}\n\nint main() {\n  while (scanf(\"%d\", \u0026N) == 1) {\n    build(1, 1, N);\n    for (int i = 1; i \u003c= N; ++i) pos[i] = read() + 1, val[i] = read();\n    for (int i = N; i; --i) query(1, 1, N, pos[i], val[i]);\n    for (int i = 1; i \u003c= N; ++i) print(ans[i]), putchar(' ');\n    putchar('\\n');\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/07"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"UVA/11922"}],"identifier":"heading-uva-11922"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-uva-11922","label":"problem-uva-11922","referenceType":"full","children":[{"type":"text","value":"UVA/11922 Permutation Transformer"}]}]},{"type":"paragraph","children":[{"type":"text","value":"基础题。"}]},{"type":"code","lang":"cpp","meta":"title=\"uva-11922.cpp\" sourcefile=\"./uva-11922.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n\nstruct node {\n  int key;\n  int siz;\n  bool flip;\n  node* lson;\n  node* rson;\n  node(int key = 0) : key(key), siz(0), flip(0), lson(NULL), rson(NULL) {\n  }\n  int cmp(int key) {\n    int cnt = lson-\u003esiz + 1;\n    if (key == cnt) return -1;\n    return key \u003c cnt ? 0 : 1;\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson-\u003eflip ^= 1;\n    rson-\u003eflip ^= 1;\n    swap(lson, rson);\n    flip = false;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n  }\n};\n\ntypedef node* root;\ntypedef pair\u003cnode*, node*\u003e droot;\nconst int MAX_NODES = 100000 + 10;\nnode* null = new node();\n\nnode nodepool[MAX_NODES];\nnode* nodetop;\n\ninline node* newnode(int key = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003eflip = false;\n  nodetop-\u003elson = null;\n  nodetop-\u003erson = null;\n  return nodetop++;\n}\n\ninline void zag(root\u0026 o) {\n  node* k = o-\u003erson;\n  o-\u003erson = k-\u003elson;\n  k-\u003elson = o;\n  o = k;\n}\ninline void zig(root\u0026 o) {\n  node* k = o-\u003elson;\n  o-\u003elson = k-\u003erson;\n  k-\u003erson = o;\n  o = k;\n}\ninline void rotate(root\u0026 o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o-\u003erson-\u003emaintain() : o-\u003elson-\u003emaintain();\n  o-\u003emaintain();\n}\n\ninline void splay(root\u0026 o, int k) {\n  o-\u003epushdown();\n  int d = o-\u003ecmp(k);\n  if (d == 1) k -= o-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 p = d ? o-\u003erson : o-\u003elson;\n    p-\u003epushdown();\n    int d2 = p-\u003ecmp(k);\n    if (d2 == 1) k -= p-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p-\u003erson : p-\u003elson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root\u0026 left, root\u0026 right) {\n  splay(o, k);\n  left = o;\n  right = o-\u003erson;\n  o-\u003erson = null;\n  o-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003epushdown();\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\ninline void build(root\u0026 o, int lft, int rht) {\n  int mid = (lft + rht) \u003e\u003e 1;\n  o = newnode(mid);\n  if (lft \u003c mid) build(o-\u003elson, lft, mid - 1);\n  if (mid \u003c rht) build(o-\u003erson, mid + 1, rht);\n  o-\u003emaintain();\n}\n\ninline void print(root\u0026 o) {\n  if (o == null) return;\n  o-\u003epushdown();\n  if (o-\u003elson != null) print(o-\u003elson);\n  if (o-\u003ekey) printf(\"%d\\n\", o-\u003ekey);\n  if (o-\u003erson != null) print(o-\u003erson);\n}\n\nroot rt;\ninline void init(int N) {\n  nodetop = nodepool;\n  build(rt, 0, N);\n}\n\nint main() {\n  int N, Q;\n  while (scanf(\"%d%d\", \u0026N, \u0026Q) == 2) {\n    init(N);\n    while (Q--) {\n      int lft, rht;\n      root o, left, middle, right;\n      scanf(\"%d%d\", \u0026lft, \u0026rht);\n      split(rt, lft, left, o);\n      split(o, rht - lft + 1, middle, right);\n      middle-\u003eflip ^= 1;\n      rt = merge(merge(left, right), middle);\n    }\n    print(rt);\n  }\n  return 0;\n}\n"},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"UVA/11996"}],"identifier":"heading-uva-11996"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-uva-11996","label":"problem-uva-11996","referenceType":"full","children":[{"type":"text","value":"UVA/11996 Jewel Magic"}]}]},{"type":"paragraph","children":[{"type":"text","value":"用 hash 求 LCP，则仅需用 Splay 维护 hash 值即可。考虑到用反转操作，每个节点需要维护正反两个 hash 值。"}]},{"type":"code","lang":"cpp","meta":"title=\"uva-11996.cpp\" sourcefile=\"./uva-11996.cpp\" maxlines=\"20\" collapsed linenos","value":"#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int MAXN = 400000 + 10;\nconst int hashkey = 137;\n\nULL xp[MAXN];\n\nstruct node {\n  int key;\n  int siz;\n  ULL val;\n  ULL reval;\n  bool flip;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson-\u003esiz + 1;\n    if (x == cnt) return -1;\n    return x \u003c cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    swap(lson, rson);\n    swap(val, reval);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson-\u003ereverse();\n    rson-\u003ereverse();\n    flip = false;\n  }\n  void maintain() {\n    siz = lson-\u003esiz + 1 + rson-\u003esiz;\n    val = lson-\u003eval + key * xp[lson-\u003esiz] + rson-\u003eval * xp[lson-\u003esiz + 1];\n    reval = rson-\u003ereval + key * xp[rson-\u003esiz] + lson-\u003ereval * xp[rson-\u003esiz + 1];\n  }\n};\n\ntypedef node* root;\ntypedef pair\u003cnode*, node*\u003e droot;\nconst int MAX_NODES = 400000 + 10;\n\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop-\u003ekey = key;\n  nodetop-\u003esiz = 1;\n  nodetop-\u003eval = 0;\n  nodetop-\u003ereval = 0;\n  nodetop-\u003eflip = false;\n  nodetop-\u003elson = null;\n  nodetop-\u003erson = null;\n  return nodetop++;\n}\n\ninline void zag(root\u0026 rt) {\n  root k = rt-\u003erson;\n  rt-\u003erson = k-\u003elson;\n  k-\u003elson = rt;\n  rt = k;\n}\ninline void zig(root\u0026 rt) {\n  root k = rt-\u003elson;\n  rt-\u003elson = k-\u003erson;\n  k-\u003erson = rt;\n  rt = k;\n}\ninline void rotate(root\u0026 rt, int d) {\n  d ? zig(rt) : zag(rt);\n  d ? rt-\u003erson-\u003emaintain() : rt-\u003elson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\ninline void splay(root\u0026 rt, int k) {\n  rt-\u003epushdown();\n  int d = rt-\u003ecmp(k);\n  if (d == 1) k -= rt-\u003elson-\u003esiz + 1;\n  if (d != -1) {\n    root\u0026 pt = d ? rt-\u003erson : rt-\u003elson;\n    pt-\u003epushdown();\n    int d2 = pt-\u003ecmp(k);\n    if (d2 == 1) k -= pt-\u003elson-\u003esiz + 1;\n    if (d2 != -1) {\n      splay((d2 ? pt-\u003erson : pt-\u003elson), k);\n      if (d == d2)\n        rotate(rt, d ^ 1);\n      else\n        rotate(pt, d);\n    }\n    rotate(rt, d ^ 1);\n  }\n}\n\ninline void split(root rt, int k, root\u0026 left, root\u0026 right) {\n  splay(rt, k);\n  left = rt;\n  right = rt-\u003erson;\n  rt-\u003erson = null;\n  rt-\u003emaintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left-\u003esiz);\n  left-\u003erson = right;\n  left-\u003emaintain();\n  return left;\n}\n\n/* insert at (k+1)th position. */\ninline void insert(root\u0026 rt, int k, int key) {\n  root left, right;\n  root middle = newnode(key);\n  split(rt, k, left, right);\n  rt = merge(merge(left, middle), right);\n}\n\n/* remove at (k+1)th position. */\ninline void remove(root\u0026 rt, int k) {\n  root left, middle, right;\n  split(rt, k, left, right);\n  split(right, 1, middle, right);\n  rt = merge(left, right);\n}\n\n/* modify [lft+1, rht+1]. */\ninline void update(root\u0026 rt, int lft, int rht) {\n  splay(rt, lft);\n  splay(rt-\u003erson, rht - lft + 2);\n  rt-\u003erson-\u003elson-\u003ereverse(); /* update rt-\u003erson-\u003elson, rt-\u003erson, rt */\n  rt-\u003erson-\u003emaintain();\n  rt-\u003emaintain();\n}\n\ninline int query(root\u0026 rt, int p1, int p2) {\n  int lft = 0, rht = rt-\u003esiz - p2;\n  while (lft \u003c rht) {\n    int mid = (lft + rht) \u003e\u003e 1;\n    splay(rt, p1);\n    splay(rt-\u003erson, mid + 1);\n    ULL val1 = rt-\u003erson-\u003elson-\u003eval;\n    splay(rt, p2);\n    splay(rt-\u003erson, mid + 1);\n    ULL val2 = rt-\u003erson-\u003elson-\u003eval;\n    if (val1 == val2)\n      lft = mid + 1;\n    else\n      rht = mid;\n  }\n  return lft - 1;\n}\n\nroot rt;\nchar s[MAXN];\nint N, Q, op, arg1, arg2;\n\ninline void build(root\u0026 rt, int lft, int rht) {\n  int mid = (lft + rht) \u003e\u003e 1;\n  rt = newnode(s[mid] - '0');\n  if (lft \u003c mid) build(rt-\u003elson, lft, mid - 1);\n  if (mid \u003c rht) build(rt-\u003erson, mid + 1, rht);\n  rt-\u003emaintain();\n}\n\ninline void Init() {\n  nodetop = nodepool;\n  scanf(\"%s\", s + 1);\n  s[0] = s[N + 1] = '0';\n  build(rt, 0, N + 1);\n}\n\ninline int read() {\n  char c = getchar();\n  int s = 0;\n  for (; c \u003c '0' || c \u003e '9'; c = getchar())\n    ;\n  for (; c \u003e= '0' \u0026\u0026 c \u003c= '9'; c = getchar()) s = s * 10 + c - '0';\n  return s;\n}\n\nint main() {\n  null = new node();\n  memset(null, 0, sizeof(node));\n  xp[0] = 1;\n  for (int i = 1; i \u003c MAXN; ++i) xp[i] = xp[i - 1] * hashkey;\n\n  while (scanf(\"%d%d\", \u0026N, \u0026Q) == 2) {\n    Init();\n    while (Q--) {\n      op = read();\n      arg1 = read();\n      if (op != 2) arg2 = read();\n      switch (op) {\n      case 1:\n        insert(rt, arg1 + 1, arg2);\n        break;\n      case 2:\n        remove(rt, arg1);\n        break;\n      case 3:\n        update(rt, arg1, arg2);\n        break;\n      case 4:\n        printf(\"%d\\n\", query(rt, arg1, arg2));\n        break;\n      }\n    }\n  }\n  return 0;\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"Summary"}],"identifier":"heading-summary"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Problems"}]},{"type":"tableCell","children":[{"type":"text","value":"Category"}]},{"type":"tableCell","children":[{"type":"text","value":"solution"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hiho-coder-1329","label":"problem-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1329"}]}]},{"type":"tableCell","children":[{"type":"text","value":"基础题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hiho-coder-1329","label":"solution-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hiho-coder-1329","label":"code-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hiho-coder-1333","label":"problem-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1333"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hiho-coder-1333","label":"solution-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hiho-coder-1333","label":"code-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hysbz-1269","label":"problem-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1269"}]}]},{"type":"tableCell","children":[{"type":"text","value":"经典题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hysbz-1269","label":"solution-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hysbz-1269","label":"code-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hysbz-1500","label":"problem-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1500"}]}]},{"type":"tableCell","children":[{"type":"text","value":"经典题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hysbz-1500","label":"solution-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hysbz-1500","label":"code-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hysbz-1503","label":"problem-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1503"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hysbz-1503","label":"solution-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hysbz-1503","label":"code-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-la-3961","label":"problem-la-3961","referenceType":"full","children":[{"type":"text","value":"LA/3961"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-la-3961","label":"solution-la-3961","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-la-3961","label":"code-la-3961","referenceType":"full","children":[{"type":"text","value":"Code"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-la-3961_2","label":"code-la-3961_2","referenceType":"full","children":[{"type":"text","value":"Code2"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-poj-2828","label":"problem-poj-2828","referenceType":"full","children":[{"type":"text","value":"POJ/2828"}]}]},{"type":"tableCell","children":[{"type":"text","value":"基础题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-poj-2828","label":"solution-poj-2828","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-poj-2828","label":"code-poj-2828","referenceType":"full","children":[{"type":"text","value":"Code"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-poj-2828_2","label":"code-poj-2828_2","referenceType":"full","children":[{"type":"text","value":"Code2"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-uva-11922","label":"problem-uva-11922","referenceType":"full","children":[{"type":"text","value":"UVa/11922"}]}]},{"type":"tableCell","children":[{"type":"text","value":"基础题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-uva-11922","label":"solution-uva-11922","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-uva-11922","label":"code-uva-11922","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-uva-11996","label":"problem-uva-11996","referenceType":"full","children":[{"type":"text","value":"UVa/11996"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-uva-11996","label":"solution-uva-11996","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-uva-11996","label":"code-uva-11996","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-题目","contents":[{"type":"text","value":"题目"}],"children":[{"depth":3,"identifier":"heading-hihocoder-1329","contents":[{"type":"text","value":"hihoCoder/1329"}],"children":[]},{"depth":3,"identifier":"heading-hihocoder-1333","contents":[{"type":"text","value":"hihoCoder/1333"}],"children":[]},{"depth":3,"identifier":"heading-hysbz-1269","contents":[{"type":"text","value":"HYSBZ/1269"}],"children":[]},{"depth":3,"identifier":"heading-hysbz-1500","contents":[{"type":"text","value":"HYSBZ/1500"}],"children":[]},{"depth":3,"identifier":"heading-hysbz-1503","contents":[{"type":"text","value":"HYSBZ/1503"}],"children":[]},{"depth":3,"identifier":"heading-la-3961","contents":[{"type":"text","value":"LA/3961"}],"children":[]},{"depth":3,"identifier":"heading-poj-2828","contents":[{"type":"text","value":"POJ/2828"}],"children":[]},{"depth":3,"identifier":"heading-uva-11922","contents":[{"type":"text","value":"UVA/11922"}],"children":[]},{"depth":3,"identifier":"heading-uva-11996","contents":[{"type":"text","value":"UVA/11996"}],"children":[]}]},{"depth":2,"identifier":"heading-summary","contents":[{"type":"text","value":"Summary"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"problem-hiho-coder-1329":{"type":"definition","identifier":"problem-hiho-coder-1329","label":"problem-hiho-coder-1329","url":"http://hihocoder.com/problemset/problem/1329"},"problem-hiho-coder-1333":{"type":"definition","identifier":"problem-hiho-coder-1333","label":"problem-hiho-coder-1333","url":"http://hihocoder.com/problemset/problem/1333"},"problem-hysbz-1269":{"type":"definition","identifier":"problem-hysbz-1269","label":"problem-hysbz-1269","url":"http://www.lydsy.com/JudgeOnline/problem.php?id=1269"},"problem-hysbz-1500":{"type":"definition","identifier":"problem-hysbz-1500","label":"problem-hysbz-1500","url":"http://www.lydsy.com/JudgeOnline/problem.php?id=1500"},"problem-hysbz-1503":{"type":"definition","identifier":"problem-hysbz-1503","label":"problem-hysbz-1503","url":"http://www.lydsy.com/JudgeOnline/problem.php?id=1503"},"problem-la-3961":{"type":"definition","identifier":"problem-la-3961","label":"problem-la-3961","url":"https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=1962"},"problem-poj-2828":{"type":"definition","identifier":"problem-poj-2828","label":"problem-poj-2828","url":"http://poj.org/problem?id=2828"},"problem-uva-11922":{"type":"definition","identifier":"problem-uva-11922","label":"problem-uva-11922","url":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=3073"},"problem-uva-11996":{"type":"definition","identifier":"problem-uva-11996","label":"problem-uva-11996","url":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=3147"},"solution-hiho-coder-1329":{"type":"definition","identifier":"solution-hiho-coder-1329","label":"solution-hiho-coder-1329","url":"#heading-hihocoder-1329"},"solution-hiho-coder-1333":{"type":"definition","identifier":"solution-hiho-coder-1333","label":"solution-hiho-coder-1333","url":"#heading-hihocoder-1333"},"solution-hysbz-1269":{"type":"definition","identifier":"solution-hysbz-1269","label":"solution-hysbz-1269","url":"#heading-hysbz-1269"},"solution-hysbz-1500":{"type":"definition","identifier":"solution-hysbz-1500","label":"solution-hysbz-1500","url":"#heading-hysbz-1500"},"solution-hysbz-1503":{"type":"definition","identifier":"solution-hysbz-1503","label":"solution-hysbz-1503","url":"#heading-hysbz-1503"},"solution-la-3961":{"type":"definition","identifier":"solution-la-3961","label":"solution-la-3961","url":"#heading-la-3961"},"solution-poj-2828":{"type":"definition","identifier":"solution-poj-2828","label":"solution-poj-2828","url":"#heading-poj-2828"},"solution-uva-11922":{"type":"definition","identifier":"solution-uva-11922","label":"solution-uva-11922","url":"#heading-uva-11922"},"solution-uva-11996":{"type":"definition","identifier":"solution-uva-11996","label":"solution-uva-11996","url":"#heading-uva-11996"},"code-hiho-coder-1329":{"type":"definition","identifier":"code-hiho-coder-1329","label":"code-hiho-coder-1329","url":"/asset/file/post/d9cc3148-a380-580d-8f3f-8d5e4e99636c.cpp"},"code-hiho-coder-1333":{"type":"definition","identifier":"code-hiho-coder-1333","label":"code-hiho-coder-1333","url":"/asset/file/post/e1795dee-74b1-5d41-978f-ee20a0b4d1b7.cpp"},"code-hysbz-1269":{"type":"definition","identifier":"code-hysbz-1269","label":"code-hysbz-1269","url":"/asset/file/post/2b0cecd1-68d8-5f71-8b48-e1a265f180f4.cpp"},"code-hysbz-1500":{"type":"definition","identifier":"code-hysbz-1500","label":"code-hysbz-1500","url":"/asset/file/post/168bc0e3-c414-570e-9572-4c84889b16ec.cpp"},"code-hysbz-1503":{"type":"definition","identifier":"code-hysbz-1503","label":"code-hysbz-1503","url":"/asset/file/post/9f55baf5-ea15-5915-9c07-fbf943958cbb.cpp"},"code-la-3961":{"type":"definition","identifier":"code-la-3961","label":"code-la-3961","url":"/asset/file/post/bcf2e488-357a-5722-a948-4412f0db948d.cpp"},"code-la-3961_2":{"type":"definition","identifier":"code-la-3961_2","label":"code-la-3961_2","url":"/asset/file/post/ab8f9599-df63-55c4-9d79-ea2f8527d43c.cpp"},"code-poj-2828":{"type":"definition","identifier":"code-poj-2828","label":"code-poj-2828","url":"/asset/file/post/650a1987-85ba-5379-aca7-ec17e791ac42.cpp"},"code-poj-2828_2":{"type":"definition","identifier":"code-poj-2828_2","label":"code-poj-2828_2","url":"/asset/file/post/2ed06c74-c97d-524c-8af8-0017dd05981e.cpp"},"code-uva-11922":{"type":"definition","identifier":"code-uva-11922","label":"code-uva-11922","url":"/asset/file/post/6afa095a-c82e-5362-8227-b98df1c38956.cpp"},"code-uva-11996":{"type":"definition","identifier":"code-uva-11996","label":"code-uva-11996","url":"/asset/file/post/36af9be2-1cbc-558e-8a56-1b3ef68e8968.cpp"}},"footnoteDefinitionMap":{},"paginationUrl":"/posts/5","prev":{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E"},"next":{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph"},"aplayerOptions":null,"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"__N_SSG":true},"page":"/post/[...slug]","query":{"slug":["data-structure","bbst","splay"]},"buildId":"a2GHX3dzrrGOQuNQX5n_t","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>