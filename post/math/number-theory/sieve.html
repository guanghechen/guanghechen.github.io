<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta name="application-name" content="guanghechen"/><meta name="apple-mobile-web-app-title" content="光和尘"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="description" content="Guanghechen&#x27;s personal site"/><meta name="format-detection" content="telephone=no"/><meta name="mobile-web-app-capable" content="yes"/><meta name="msapplication-config" content="/icons/browserconfig.xml"/><meta name="msapplication-TileColor" content="#2B5797"/><meta name="msapplication-tap-highlight" content="no"/><meta name="theme-color" content="#a2466c"/><link rel="manifest" href="/manifest.json"/><link rel="shortcut icon" href="/favicon.png"/><meta property="og:type" content="website"/><meta property="og:title" content="光和尘"/><meta property="og:description" content="光和尘的个人站点"/><meta property="og:site_name" content="guanghechen"/><meta property="og:url" content="https://preview.me.guanghechen.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Roboto+Mono&amp;display=swap"/><link rel="preload" href="/_next/static/css/f6e2a3135d0744b2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f6e2a3135d0744b2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2159a4b672631e08.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2159a4b672631e08.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-265847f8f26a647f.js" defer=""></script><script src="/_next/static/chunks/framework-18c7e6fcf99e5daa.js" defer=""></script><script src="/_next/static/chunks/main-881697fc9a01f7ab.js" defer=""></script><script src="/_next/static/chunks/pages/_app-336856b3bec30f8c.js" defer=""></script><script src="/_next/static/chunks/554-0ae36613042b30fd.js" defer=""></script><script src="/_next/static/chunks/724-59b1a7f2cbe70306.js" defer=""></script><script src="/_next/static/chunks/997-b0975c06e066394a.js" defer=""></script><script src="/_next/static/chunks/865-6ac09b2c0ad0941c.js" defer=""></script><script src="/_next/static/chunks/796-208972a23765040d.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5B...slug%5D-65f62f877fc223b3.js" defer=""></script><script src="/_next/static/kLJS-F-0bGeWqnfLXv89E/_buildManifest.js" defer=""></script><script src="/_next/static/kLJS-F-0bGeWqnfLXv89E/_ssgManifest.js" defer=""></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap"/></head><body><div id="__next"><div class="css-pwdx5x"><style data-emotion="css z01bqi animation-61bdi0">.css-z01bqi{display:inline-block;color:#1976d2;-webkit-animation:animation-61bdi0 1.4s linear infinite;animation:animation-61bdi0 1.4s linear infinite;}@-webkit-keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style><span class="MuiCircularProgress-root MuiCircularProgress-indeterminate MuiCircularProgress-colorPrimary css-z01bqi" style="width:40px;height:40px" role="progressbar"><style data-emotion="css 13o7eu2">.css-13o7eu2{display:block;}</style><svg class="MuiCircularProgress-svg css-13o7eu2" viewBox="22 22 44 44"><style data-emotion="css 14891ef animation-1p2h4ri">.css-14891ef{stroke:currentColor;stroke-dasharray:80px,200px;stroke-dashoffset:0;-webkit-animation:animation-1p2h4ri 1.4s ease-in-out infinite;animation:animation-1p2h4ri 1.4s ease-in-out infinite;}@-webkit-keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}@keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}</style><circle class="MuiCircularProgress-circle MuiCircularProgress-circleIndeterminate css-14891ef" cx="44" cy="44" r="20.2" fill="none" stroke-width="3.6"></circle></svg></span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"数论基础之筛法","description":"数论基础之筛法","slug":"/post/math/number-theory/sieve","createdAt":"May 06, 2016","updatedAt":"Nov 03, 2021","timeToRead":"07min 48s","tags":["math","数论","素数","欧拉函数","线性筛"],"categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"筛素数的算法"}],"identifier":"heading-筛素数的算法"},{"type":"heading","depth":3,"children":[{"type":"text","value":"朴素筛法"}],"identifier":"heading-朴素筛法"},{"type":"paragraph","children":[{"type":"text","value":"朴素的筛素数算法的流程是这样的："}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"inlineMath","value":"i"},{"type":"text","value":" 没有被标记，"},{"type":"inlineMath","value":"i"},{"type":"text","value":" 是素数；用 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 去标记所有的\n"},{"type":"inlineMath","value":"i,2i,\\cdots,\\left\\lfloor \\frac{N}{i} \\right\\rfloor \\times i"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"inlineMath","value":"i"},{"type":"text","value":" 被标记，"},{"type":"inlineMath","value":"i"},{"type":"text","value":" 不是素数"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"因为每个数至少被所有它的素因子各自标记一次，而每个数的素因子个数是不超过\n"},{"type":"inlineMath","value":"O(\\log N)"},{"type":"text","value":" 个的，所以这个算法的复杂度是 "},{"type":"inlineMath","value":"O(N\\log N)"},{"type":"text","value":" 的，其中 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 为要筛的数的个数。"}]},{"type":"paragraph","children":[{"type":"text","value":"一个简单的优化技巧是：如果 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 是素数，则用 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 去标记所有的\n"},{"type":"inlineMath","value":"\\displaystyle i^2,(i+1)\\times i,\\cdots,\\left\\lfloor \\frac{N}{i} \\right\\rfloor \\times i"},{"type":"text","value":".\n这个优化是正确的，因为 "},{"type":"inlineMath","value":"(i, i^2)"},{"type":"text","value":" 之间的合数其最小素因子必然小于 "},{"type":"inlineMath","value":"i"},{"type":"text","value":"，由数学归纳法可证明其必然会被一个小于 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 的素数标记。优化之后的复杂度好像是\n"},{"type":"footnoteReference","label":"1","identifier":"footnote-1"},{"type":"text","value":"\n"},{"type":"inlineMath","value":"O\\big(N\\log (\\log N)\\big)"},{"type":"text","value":" 的。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"线性筛"}],"identifier":"heading-线性筛"},{"type":"paragraph","children":[{"type":"text","value":"对于任意一个大于 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的整数 "},{"type":"inlineMath","value":"X"},{"type":"text","value":"，可以将其写为 "},{"type":"inlineMath","value":"X = e \\cdot X'"},{"type":"text","value":"。其中，"},{"type":"inlineMath","value":"e"},{"type":"text","value":" 是 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 的最小正素因子。特别地，如果 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 是一个素数，有 "},{"type":"inlineMath","value":"X=e"},{"type":"text","value":"。那么，如果能让每一个正整数 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 仅被其最小正素因子标记，就可以保证筛法的复杂度是线性的了。"}]},{"type":"paragraph","children":[{"type":"text","value":"先看怎么实现，再解释为什么是正确的且其复杂度是线性的。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"C++"}]},{"type":"code","lang":"cpp","meta":"{16,19} title=\"sieve.prime.linear.cpp\" linenos collapsed","value":"// 一般来说，素数个数在 MAXN/10 ～ MAXN/15 左右 \n\ntypedef long long LL;\nbool isprime[MAXN];\nint prime[MAXN], tot;\n\nvoid sievePrimes() {\n  memset(isprime, 1, sizeof isprime);\n  tot = 0;\n  for (int x = 2; x \u003c MAXN; ++x) {\n      if (isprime[x]) prime[tot++] = x;\n      for (int i = 0; i \u003c tot; ++i) {\n          // 防止乘法溢出\n          if ((LL) prime[i]*x \u003e= MAXN) break;\n\n          isprime[prime[i]*x] = false;\n\n          // 保证每个数仅被其最小正素因子标记\n          if (x % prime[i] == 0) break;\n      }\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"Typescript （也可以直接使用 "},{"type":"linkReference","identifier":"@algorithm.ts/sieve-prime","label":"@algorithm.ts/sieve-prime","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sieve-prime"}]},{"type":"text","value":"）"}]},{"type":"code","lang":"typescript","meta":"title=\"sieve-prime.linear.ts\" linenos collapsed","value":"export function sievePrime(N: number): number[] {\n  if (N \u003c= 1) return []\n\n  let tot = 0\n  const primes: number[] = []\n  const isNotPrime: Uint8Array = new Uint8Array(N)\n\n  for (let x = 2; x \u003c N; ++x) {\n    // eslint-disable-next-line no-plusplus\n    if (!isNotPrime[x]) primes[tot++] = x\n    for (let i = 0; i \u003c tot; ++i) {\n      if (primes[i] * x \u003e= N) break\n\n      isNotPrime[primes[i] * x] = 1\n\n      // Ensure that each number is only marked by its smallest positive factor.\n      if (x % primes[i] === 0) break\n    }\n  }\n\n  primes.length = tot\n  return primes\n}\n"}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"正确性证明"}],"identifier":"heading-正确性证明"},{"type":"paragraph","children":[{"type":"text","value":"如果 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 是一个合数，令 "},{"type":"inlineMath","value":"X=e\\cdot X'"},{"type":"text","value":"，其中 "},{"type":"inlineMath","value":"e"},{"type":"text","value":" 为 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 的最小正素因子。首先，"},{"type":"inlineMath","value":"e \u003c= X'"},{"type":"text","value":"，所以当 "},{"type":"inlineMath","value":"x=X'"},{"type":"text","value":" 时，"},{"type":"inlineMath","value":"e"},{"type":"text","value":" 已经在 "},{"type":"inlineCode","value":"prime"},{"type":"text","value":" 栈中了。其次，不存在一个正素数 "},{"type":"inlineMath","value":"e' \u003c e"},{"type":"text","value":" 满足 "},{"type":"inlineMath","value":"e' \\mid X'"},{"type":"text","value":"；因为如果存在这样的 "},{"type":"inlineMath","value":"e'"},{"type":"text","value":"，则 "},{"type":"inlineMath","value":"X=e'\\cdot\\frac{X'}{e'}\\cdot e"},{"type":"text","value":"，与 "},{"type":"inlineMath","value":"e"},{"type":"text","value":" 是 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 的最小素因子矛盾。"}]},{"type":"paragraph","children":[{"type":"text","value":"也就说，如果 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 是一个合数，那么上面第 16 行程序必会得到执行（我们已经排除了所有跳过标记 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 的可能），所以这个筛法可以无遗漏地标记所有的合数。又因为\n"},{"type":"inlineCode","value":"prime[i]*x"},{"type":"text","value":" 是一个合数，所以这个筛法不会标记素数。据此，证明了该筛法的正确性。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"线性复杂度证明"}],"identifier":"heading-线性复杂度证明"},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"如果 "},{"type":"inlineMath","value":"X=e^k"},{"type":"text","value":"，那么显然不用担心它被多个不同的素数标记过"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"如果 "},{"type":"inlineMath","value":"X=e_1 \\cdot e_2 \\cdot X'"}]},{"type":"list","ordered":false,"marker":45,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"若 "},{"type":"inlineMath","value":"e_1 \u003c e_2"},{"type":"text","value":"；令 "},{"type":"inlineMath","value":"\\displaystyle x_2=\\frac{X}{e_2}"},{"type":"text","value":"，显然有 "},{"type":"inlineMath","value":"e_1 \\mid x_2"},{"type":"text","value":"，即上述程序第 19 行程序会得到执行。"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"否则 "},{"type":"inlineMath","value":"e_2 \u003e e_1"},{"type":"text","value":"，也就是说， "},{"type":"inlineMath","value":"x_2"},{"type":"text","value":" 在遇见 "},{"type":"inlineMath","value":"e_1"},{"type":"text","value":" 时就会结束内层循环，不会遇见 "},{"type":"inlineMath","value":"e_2"},{"type":"text","value":"，所以保证了 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 至多仅被 "},{"type":"inlineMath","value":"e_1"},{"type":"text","value":" 筛一次。"}]}]}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"综上，此筛法是 "},{"type":"inlineMath","value":"O(N)"},{"type":"text","value":" 的。"}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"欧拉函数的筛法"}],"identifier":"heading-欧拉函数的筛法"},{"type":"heading","depth":3,"children":[{"type":"text","value":"欧拉函数"}],"identifier":"heading-欧拉函数"},{"type":"paragraph","children":[{"type":"text","value":"欧拉函数 "},{"type":"inlineMath","value":"\\varphi(X)"},{"type":"text","value":" 表示 "},{"type":"inlineMath","value":"1,2,\\cdots,X-1"},{"type":"text","value":" 中与 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 互质的数的个数。"}]},{"type":"paragraph","children":[{"type":"text","value":"定义函数： "},{"type":"inlineMath","value":"f(x,y) = \\left\\lbrace\\begin{aligned}\u00261, \u0026\\gcd(x,y)=1 \\\\ \u00260, \u0026\\gcd(x,y) \\neq 1 \\end{aligned}\\right."},{"type":"break"},{"type":"text","value":"\n那么，对于正整数 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 有："}]},{"type":"math","value":"\\varphi(X)=\\sum_{i=1}^{X-1} f(X,i) \\tag{1}\n"},{"type":"paragraph","children":[{"type":"text","value":"更一般地，将 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 唯一分解，得到 "},{"type":"inlineMath","value":"X=p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_s^{k_s}"},{"type":"text","value":"。那么，"}]},{"type":"math","value":"\\varphi(X)=X\\cdot \\left(1-\\frac{1}{p_1}\\right) \\cdot \\left(1-\\frac{1}{p_2}\\right) \\cdots \\left(1-\\frac{1}{p_s}\\right). \\tag{2}\n"},{"type":"paragraph","children":[{"type":"text","value":"下面利用容斥原理简单证明一下方程(2)："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"将 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 唯一分解，得："},{"type":"inlineMath","value":"X=p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_s^{k_s}"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n令 "},{"type":"inlineMath","value":"A_i"},{"type":"text","value":" 为比 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 小且被 "},{"type":"inlineMath","value":"p_i"},{"type":"text","value":" 整除的正整数集合，则有："}]},{"type":"math","value":"\\begin{align}\n  \\varphi(X) \n  \u0026= X-\\sum_{i=1}^s \\big| A_i \\big|+\\sum_{i=1}^s \\sum_{j \u003e i} \\big|A_i\n     \\bigcap A_j\\big|-\\sum_{i=1}^s\\sum_{j \u003e i}\\sum_{k \u003e j} \\big| A_i\n     \\bigcap A_j \\bigcap A_k \\big|+\\cdots \n     +(-1)^{s}\\big|A_1\\bigcap A_2\\bigcap \\cdots \\bigcap A_s \\big|\\\\\n  \u0026= X-\\sum_{i=1}^s \\frac{X}{p_1}+\\sum_{i=1}^s\\sum_{j \u003e i} \\frac{X}{p_ip_j}\n     -\\sum_{i=1}^s\\sum_{j \u003e i}\\sum_{k \u003e j} \\frac{X}{p_ip_jp_k}\n     +\\cdots+(-1)^s\\frac{X}{p_1p_2\\cdots p_s} \\\\\n  \u0026= X\\cdot \\left(1-\\frac{1}{p_1}\\right) \\cdot \\left(1-\\frac{1}{p_2}\\right) \\cdots \\left(1-\\frac{1}{p_s}\\right)\n\\end{align}\n"}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"朴素筛法"}],"identifier":"heading-朴素筛法-2"},{"type":"paragraph","children":[{"type":"text","value":"方程(2) 虽然给出了欧拉函数的一个简单计算方法，但是，注意到质因数分解的复杂度是\n"},{"type":"inlineMath","value":"O(\\sqrt{N})"},{"type":"text","value":" 的，如果多次这样计算代价太大。可以反过来考虑：筛出所有的素数，并用每个素数更新 "},{"type":"inlineMath","value":"\\varphi(X)"},{"type":"text","value":" 的值。"}]},{"type":"code","lang":"cpp","meta":"title=\"sieve.phi.cpp\" linenos","value":"typedef long long LL;\nint phi[N];\n\nvoid sievePhi() {\n  memset(phi, 0, sizeof phi);\n  phi[1] = 1;\n  for (int i = 2; i \u003c N; ++i) {\n    if (!phi[i]) {\n      for (int j = i; j \u003c N; j += i) {\n        if (!phi[j]) phi[j] = j;    \n        phi[j] = phi[i] / i * (i - 1); // 先除后乘防止溢出\n      }\n    }\n  }\n}\n"},{"type":"paragraph","children":[{"type":"text","value":"这个程序可以生成 "},{"type":"inlineMath","value":"X \\in [1,N)"},{"type":"text","value":" 的欧拉函数表，且时间复杂度与朴素筛素数方法同阶，据说是 "},{"type":"inlineMath","value":"O(N\\log(N))"},{"type":"text","value":" 的。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"线性筛"}],"identifier":"heading-线性筛-2"},{"type":"paragraph","children":[{"type":"text","value":"基于素数线性筛的思想，不妨设 "},{"type":"inlineMath","value":"X=e\\cdot X'"},{"type":"text","value":"，其中，"},{"type":"inlineMath","value":"e"},{"type":"text","value":" 为 "},{"type":"inlineMath","value":"X"},{"type":"text","value":" 的最小素因子。"}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"当 "},{"type":"inlineMath","value":"e \\mid X'"},{"type":"text","value":" 时，由上述计算公式可知，"},{"type":"inlineMath","value":"\\varphi(X) = \\varphi(X') \\cdot (\\frac{X}{X'})=\\varphi(X')\\cdot e"},{"type":"text","value":"；"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"当 "},{"type":"inlineMath","value":"e \\nmid X'"},{"type":"text","value":" 时，由上述计算公式可知，"},{"type":"inlineMath","value":"\\varphi(X) = \\varphi(X') \\cdot (\\frac{X}{X'}) \\cdot (1-\\frac{1}{e}) = \\varphi(X')\\cdot (e-1)"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"所以："}]},{"type":"math","value":"  \\varphi(X) = \\left\\lbrace \\begin{aligned}\n    \u0026\\varphi(X') \\cdot e, \u0026e \\mid X' \\\\\n    \u0026\\varphi(X') \\cdot (e-1), \u0026e \\nmid X'\n  \\end{aligned} \\right.\n"},{"type":"paragraph","children":[{"type":"text","value":"不难发现，该筛法与素数线性筛同阶，因此也是线性的。"}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"C++"}]},{"type":"code","lang":"cpp","meta":"title=\"sieve.phi.linear.cpp\" linenos collapsed","value":"typedef long long LL;\nint phi[N], prime[N], tot;\n\nvoid sievePhi() {\n  memset(phi, 0, sizeof phi);\n  phi[1] = 1;\n  tot = 0;\n\n  for (int i = 2; i \u003c N; ++i) {\n    if (!phi[i]) {\n      phi[i] = i - 1;\n      prime[tot++] = i;\n    }\n    for (int j = 0; j \u003c tot; ++j) {\n      LL ret = (LL) prime[j] * i;\n      if (ret \u003e= N) break;\n      if (i % prime[j] == 0) {\n        phi[ret] = phi[i] * prime[j]; // 对应 e 整除 X' 的情况\n        break;\n      }\n      phi[ret] = phi[i] * (prime[j] - 1); // 对应 e 不整除 X' 的情况\n    }\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"Typescript  （也可以直接使用 "},{"type":"linkReference","identifier":"@algorithm.ts/sieve-totient","label":"@algorithm.ts/sieve-totient","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sieve-totient"}]},{"type":"text","value":"）"}]},{"type":"code","lang":"typescript","meta":"title=\"sieve.phi.linear.ts\" linenos collapsed","value":"export function sieveTotient(\n  N: number,\n): [totient: Uint32Array, primes: number[]] {\n  if (N \u003c 1) return [new Uint32Array(0), []]\n  if (N === 1) return [new Uint32Array(1), []]\n\n  let tot = 0\n  const totients: Uint32Array = new Uint32Array(N)\n  const primes: number[] = []\n\n  totients[1] = 1\n  for (let x = 2; x \u003c N; ++x) {\n    if (totients[x] === 0) {\n      // eslint-disable-next-line no-plusplus\n      primes[tot++] = x\n      totients[x] = x - 1\n    }\n\n    for (let i = 0; i \u003c tot; ++i) {\n      const target = primes[i] * x\n      if (target \u003e= N) break\n\n      // Ensure that each number is only marked by its smallest positive factor.\n      if (x % primes[i] === 0) {\n        totients[target] = totients[x] * primes[i]\n        break\n      }\n\n      totients[target] = totients[x] * (primes[i] - 1)\n    }\n  }\n\n  primes.length = tot\n  return [totients, primes]\n}\n"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"练习"}],"identifier":"heading-练习"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Problem"}]},{"type":"tableCell","children":[{"type":"text","value":"Category"}]},{"type":"tableCell","children":[{"type":"text","value":"Solution / Code"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"vua-2421-problem","label":"vua-2421-problem","referenceType":"full","children":[{"type":"text","value":"UVa/GCD Extreme(II)"}]}]},{"type":"tableCell","children":[{"type":"text","value":"欧拉函数"}]},{"type":"tableCell","children":[{"type":"text","value":"-"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"linkReference","identifier":"数论基础之欧拉函数","label":"数论基础之欧拉函数","referenceType":"collapsed","children":[{"type":"text","value":"数论基础之欧拉函数"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"@algorithm.ts/sieve-prime","label":"@algorithm.ts/sieve-prime","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sieve-prime"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"@algorithm.ts/sieve-totient","label":"@algorithm.ts/sieve-totient","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sieve-totient"}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-筛素数的算法","contents":[{"type":"text","value":"筛素数的算法"}],"children":[{"depth":3,"identifier":"heading-朴素筛法","contents":[{"type":"text","value":"朴素筛法"}],"children":[]},{"depth":3,"identifier":"heading-线性筛","contents":[{"type":"text","value":"线性筛"}],"children":[]},{"depth":3,"identifier":"heading-程序实现","contents":[{"type":"text","value":"程序实现"}],"children":[]},{"depth":3,"identifier":"heading-正确性证明","contents":[{"type":"text","value":"正确性证明"}],"children":[]},{"depth":3,"identifier":"heading-线性复杂度证明","contents":[{"type":"text","value":"线性复杂度证明"}],"children":[]}]},{"depth":2,"identifier":"heading-欧拉函数的筛法","contents":[{"type":"text","value":"欧拉函数的筛法"}],"children":[{"depth":3,"identifier":"heading-欧拉函数","contents":[{"type":"text","value":"欧拉函数"}],"children":[]},{"depth":3,"identifier":"heading-朴素筛法-2","contents":[{"type":"text","value":"朴素筛法"}],"children":[]},{"depth":3,"identifier":"heading-线性筛-2","contents":[{"type":"text","value":"线性筛"}],"children":[]}]},{"depth":2,"identifier":"heading-练习","contents":[{"type":"text","value":"练习"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"数论基础之欧拉函数":{"type":"definition","identifier":"数论基础之欧拉函数","label":"数论基础之欧拉函数","url":"/post/math/number-theory/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},"vua-2421-problem":{"type":"definition","identifier":"vua-2421-problem","label":"vua-2421-problem","url":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=2421"},"@algorithm.ts/sieve-prime":{"type":"definition","identifier":"@algorithm.ts/sieve-prime","label":"@algorithm.ts/sieve-prime","url":"https://github.com/guanghechen/algorithm.ts/tree/main/packages/sieve-prime"},"@algorithm.ts/sieve-totient":{"type":"definition","identifier":"@algorithm.ts/sieve-totient","label":"@algorithm.ts/sieve-totient","url":"https://github.com/guanghechen/algorithm.ts/tree/main/packages/sieve-totient"}},"footnoteDefinitionMap":{"footnote-1":{"type":"footnoteDefinition","identifier":"footnote-1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"这个复杂度是道听途说的，未见到严谨证明，但是，显然它仍都不会是线性的，因为对于\n"},{"type":"inlineMath","value":"[i^2, N]"},{"type":"text","value":" 之间的合数仍然会被所有其小于 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 的素因子各自标记一次"}]}]}},"paginationUrl":"/posts/6","prev":{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic"},"next":{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数"},"aplayerOptions":null,"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"__N_SSG":true},"page":"/post/[...slug]","query":{"slug":["math","number-theory","sieve"]},"buildId":"kLJS-F-0bGeWqnfLXv89E","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>