<!DOCTYPE html><html lang="en" class="__className_324942"><head><meta charSet="utf-8"/><meta charSet="utf8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><link rel="preload" href="/_next/static/media/627622453ef56b0d-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/934c4b7cb736f2a3-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/f2ccec9f31141b1c.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-62f3425439692c3f.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-720c60cb92b754a9.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-48533d44d2bf446a.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-73a1fec814ad4325.js" async="" crossorigin=""></script><script src="/_next/static/chunks/74-31f764c22632bceb.js" async=""></script><script src="/_next/static/chunks/32-c49bb5d7213019d7.js" async=""></script><script src="/_next/static/chunks/800-4848173b49d8d689.js" async=""></script><script src="/_next/static/chunks/app/layout-fa17488f223d6ca7.js" async=""></script><script src="/_next/static/chunks/app/not-found-7a4f60c8a23c275c.js" async=""></script><script src="/_next/static/chunks/4-1f47c029a7fba46f.js" async=""></script><script src="/_next/static/chunks/810-8ebda3a4770496e8.js" async=""></script><script src="/_next/static/chunks/659-7f246e0fb997ad2e.js" async=""></script><script src="/_next/static/chunks/714-13c64a7806ea4ae0.js" async=""></script><script src="/_next/static/chunks/448-62c186fb5283557d.js" async=""></script><script src="/_next/static/chunks/app/(essay)/layout-5f49ece7d1bf5812.js" async=""></script><script src="/_next/static/chunks/595-60215c9a9c19277d.js" async=""></script><script src="/_next/static/chunks/551-68df0022cc950ef8.js" async=""></script><script src="/_next/static/chunks/app/(post)/post/%5B...slug%5D/page-80cd6d5787edd594.js" async=""></script><link rel="preload" href="/_next/static/css/2159a4b672631e08.css" as="style" crossorigin=""/><title>不修改数组找出重复的数字 | guanghechen</title><meta name="description" content="不修改数组找出重复的数字"/><meta name="application-name" content="guanghechen"/><link rel="author" href="https://github.com/guanghechen"/><meta name="author" content="光和尘"/><link rel="icon" href="/favicon.png"/><meta name="next-size-adjust"/><meta name="application-name" content="guanghechen"/><meta name="apple-mobile-web-app-title" content="光和尘"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="description" content="Guanghechen&#x27;s personal site"/><meta name="format-detection" content="telephone=no"/><meta name="mobile-web-app-capable" content="yes"/><meta name="msapplication-config" content="/icons/browserconfig.xml"/><meta name="msapplication-TileColor" content="#2B5797"/><meta name="msapplication-tap-highlight" content="no"/><meta name="theme-color" content="#a2466c"/><meta property="og:type" content="website"/><meta property="og:title" content="光和尘"/><meta property="og:description" content="光和尘的个人站点"/><meta property="og:site_name" content="guanghechen"/><meta property="og:url" content="https://me.guanghechen.com"/><link rel="manifest" href="/manifest.json"/><link rel="shortcut icon" href="/favicon.png"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><div class="css-pwdx5x"><style data-emotion="css z01bqi animation-61bdi0">.css-z01bqi{display:inline-block;color:#1976d2;-webkit-animation:animation-61bdi0 1.4s linear infinite;animation:animation-61bdi0 1.4s linear infinite;}@-webkit-keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style><span class="MuiCircularProgress-root MuiCircularProgress-indeterminate MuiCircularProgress-colorPrimary css-z01bqi" style="width:40px;height:40px" role="progressbar"><style data-emotion="css 13o7eu2">.css-13o7eu2{display:block;}</style><svg class="MuiCircularProgress-svg css-13o7eu2" viewBox="22 22 44 44"><style data-emotion="css 14891ef animation-1p2h4ri">.css-14891ef{stroke:currentColor;stroke-dasharray:80px,200px;stroke-dashoffset:0;-webkit-animation:animation-1p2h4ri 1.4s ease-in-out infinite;animation:animation-1p2h4ri 1.4s ease-in-out infinite;}@-webkit-keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}@keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}</style><circle class="MuiCircularProgress-circle MuiCircularProgress-circleIndeterminate css-14891ef" cx="44" cy="44" r="20.2" fill="none" stroke-width="3.6"></circle></svg></span></div><script src="/_next/static/chunks/webpack-62f3425439692c3f.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/627622453ef56b0d-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/934c4b7cb736f2a3-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/css/f2ccec9f31141b1c.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L4\"\n"])</script><script>self.__next_f.push([1,"5:HL[\"/_next/static/css/2159a4b672631e08.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"6:I[47690,[],\"\"]\n9:I[5613,[],\"\"]\nb:I[31778,[],\"\"]\nd:I[79286,[\"74\",\"static/chunks/74-31f764c22632bceb.js\",\"32\",\"static/chunks/32-c49bb5d7213019d7.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"185\",\"static/chunks/app/layout-fa17488f223d6ca7.js\"],\"SiteProvider\"]\ne:I[54110,[\"74\",\"static/chunks/74-31f764c22632bceb.js\",\"32\",\"static/chunks/32-c49bb5d7213019d7.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"185\",\"static/chunks/app/layout-fa17488f223d6ca7.js\"],\"\"]\nf:I[74117,[\"74\",\"static/chunks/74-31f764c226"])</script><script>self.__next_f.push([1,"32bceb.js\",\"32\",\"static/chunks/32-c49bb5d7213019d7.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"185\",\"static/chunks/app/layout-fa17488f223d6ca7.js\"],\"MaterialThemeProvider\"]\n10:I[55153,[\"74\",\"static/chunks/74-31f764c22632bceb.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"160\",\"static/chunks/app/not-found-7a4f60c8a23c275c.js\"],\"NotFoundView\"]\n12:I[48955,[],\"\"]\na:[\"slug\",\"quiz/partition/find-duplicate-number\",\"c\"]\n13:[]\n"])</script><script>self.__next_f.push([1,"4:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/f2ccec9f31141b1c.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L6\",null,{\"buildId\":\"QrHnf4rdYBDkyXQkdleFO\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/post/quiz/partition/find-duplicate-number\",\"initialTree\":[\"\",{\"children\":[\"(post)\",{\"children\":[\"post\",{\"children\":[[\"slug\",\"quiz/partition/find-duplicate-number\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"quiz\\\",\\\"partition\\\",\\\"find-duplicate-number\\\"]}\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(post)\",{\"children\":[\"post\",{\"children\":[[\"slug\",\"quiz/partition/find-duplicate-number\",\"c\"],{\"children\":[\"__PAGE__\",{},[\"$L7\",\"$L8\",null]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(post)\",\"children\",\"post\",\"children\",\"$a\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(post)\",\"children\",\"post\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,\"$Lc\",null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"__className_324942\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"charSet\":\"utf8\"}],[\"$\",\"meta\",\"viewport\",{\"name\":\"viewport\",\"content\":\"initial-scale=1.0, width=device-width\"}],[\"$\",\"meta\",null,{\"name\":\"application-name\",\"content\":\"guanghechen\"}],[\"$\",\"meta\",null,{\"name\":\"apple-mobile-web-app-title\",\"content\":\"光和尘\"}],[\"$\",\"meta\",null,{\"name\":\"apple-mobile-web-app-capable\",\"content\":\"yes\"}],[\"$\",\"meta\",null,{\"name\":\"apple-mobile-web-app-status-bar-style\",\"content\":\"default\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"Guanghechen's personal site\"}],[\"$\",\"meta\",null,{\"name\":\"format-detection\",\"content\":\"telephone=no\"}],[\"$\",\"meta\",null,{\"name\":\"mobile-web-app-capable\",\"content\":\"yes\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-config\",\"content\":\"/icons/browserconfig.xml\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#2B5797\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-tap-highlight\",\"content\":\"no\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#a2466c\"}],[\"$\",\"meta\",null,{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",null,{\"property\":\"og:title\",\"content\":\"光和尘\"}],[\"$\",\"meta\",null,{\"property\":\"og:description\",\"content\":\"光和尘的个人站点\"}],[\"$\",\"meta\",null,{\"property\":\"og:site_name\",\"content\":\"guanghechen\"}],[\"$\",\"meta\",null,{\"property\":\"og:url\",\"content\":\"https://me.guanghechen.com\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/manifest.json\"}],[\"$\",\"link\",null,{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$Le\",null,{\"children\":[\"$\",\"$Lf\",null,{\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"$L10\",null,{}],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/2159a4b672631e08.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]}]}]}]]}],null]],\"initialHead\":[false,\"$L11\"],\"globalErrorComponent\":\"$12\",\"missingSlots\":\"$W13\"}]]\n"])</script><script>self.__next_f.push([1,"14:I[56057,[\"74\",\"static/chunks/74-31f764c22632bceb.js\",\"32\",\"static/chunks/32-c49bb5d7213019d7.js\",\"4\",\"static/chunks/4-1f47c029a7fba46f.js\",\"810\",\"static/chunks/810-8ebda3a4770496e8.js\",\"659\",\"static/chunks/659-7f246e0fb997ad2e.js\",\"714\",\"static/chunks/714-13c64a7806ea4ae0.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"448\",\"static/chunks/448-62c186fb5283557d.js\",\"63\",\"static/chunks/app/(essay)/layout-5f49ece7d1bf5812.js\"],\"YozoraThemeProvider\"]\n15:I[20593,[\"74\",\"static/chunks/74-31f764c22632bceb.js\","])</script><script>self.__next_f.push([1,"\"32\",\"static/chunks/32-c49bb5d7213019d7.js\",\"4\",\"static/chunks/4-1f47c029a7fba46f.js\",\"810\",\"static/chunks/810-8ebda3a4770496e8.js\",\"659\",\"static/chunks/659-7f246e0fb997ad2e.js\",\"714\",\"static/chunks/714-13c64a7806ea4ae0.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"448\",\"static/chunks/448-62c186fb5283557d.js\",\"63\",\"static/chunks/app/(essay)/layout-5f49ece7d1bf5812.js\"],\"PostLayoutView\"]\n"])</script><script>self.__next_f.push([1,"16:I[59627,[\"74\",\"static/chunks/74-31f764c22632bceb.js\",\"32\",\"static/chunks/32-c49bb5d7213019d7.js\",\"4\",\"static/chunks/4-1f47c029a7fba46f.js\",\"810\",\"static/chunks/810-8ebda3a4770496e8.js\",\"659\",\"static/chunks/659-7f246e0fb997ad2e.js\",\"714\",\"static/chunks/714-13c64a7806ea4ae0.js\",\"595\",\"static/chunks/595-60215c9a9c19277d.js\",\"551\",\"static/chunks/551-68df0022cc950ef8.js\",\"800\",\"static/chunks/800-4848173b49d8d689.js\",\"448\",\"static/chunks/448-62c186fb5283557d.js\",\"918\",\"static/chunks/app/(post)/post/%5B...slug%5D/page-80cd6d5787edd594.js\"],\"PostDetailPageView\"]\n"])</script><script>self.__next_f.push([1,"c:[\"$\",\"$L14\",null,{\"children\":[\"$\",\"$L15\",null,{\"data\":{\"postItems\":[{\"title\":\"Javascript 踩坑记——继承和原型链\",\"slug\":\"/post/web/javascript/inherit\",\"tags\":[\"studynote\",\"javascript\",\"ecmascript\"],\"createdAt\":\"Sep 05, 2021\"},{\"title\":\"防抖和节流\",\"slug\":\"/post/algorithm/debounce-and-throttle\",\"tags\":[\"coding\",\"debounce\",\"throttle\"],\"createdAt\":\"Sep 03, 2021\"},{\"title\":\"XSS 与 CSRF 的攻防\",\"slug\":\"/post/web/security/xss-csrf\",\"tags\":[\"web\",\"web security\",\"csrf\"],\"createdAt\":\"Aug 19, 2021\"},{\"title\":\"自然对数底数 e\",\"slug\":\"/post/math/calculus/自然对数底数e\",\"tags\":[\"math\",\"函数\",\"极限\",\"自然对数\"],\"createdAt\":\"Aug 07, 2021\"},{\"title\":\"当你想来一把数独\",\"slug\":\"/post/game/sudoku\",\"tags\":[\"game\",\"sudoku\"],\"createdAt\":\"Aug 01, 2021\"},{\"title\":\"精确覆盖问题和 DLX 算法\",\"slug\":\"/post/algorithm/dlx\",\"tags\":[\"算法\",\"精确覆盖\",\"DLX 算法\"],\"createdAt\":\"Jul 24, 2021\"},{\"title\":\"洗牌问题和 knuth-shuffle 算法\",\"slug\":\"/post/algorithm/shuffle\",\"tags\":[\"shuffle\",\"knuth-shuffle\",\"约瑟夫环\"],\"createdAt\":\"Jul 22, 2021\"},{\"title\":\"统计区间内的线段\",\"slug\":\"/post/quiz/scanning-line/segments\",\"tags\":[\"quiz\",\"扫描线\",\"前缀和\",\"树状数组\",\"线段树\"],\"createdAt\":\"Jul 21, 2021\"},{\"title\":\"约瑟夫环问题\",\"slug\":\"/post/quiz/classical/Josephus-ring\",\"tags\":[\"quiz\",\"经典问题\",\"约瑟夫环\"],\"createdAt\":\"Jul 16, 2021\"},{\"title\":\"剑指offer 解题报告\",\"slug\":\"/post/acm/oj/nowcoder/jz-offer\",\"tags\":[\"专题训练\",\"解题报告\"],\"createdAt\":\"Jul 15, 2021\"},{\"title\":\"不修改数组找出重复的数字\",\"slug\":\"/post/quiz/partition/find-duplicate-number\",\"tags\":[\"quiz\",\"分治\",\"追击\"],\"createdAt\":\"Jun 29, 2021\"},{\"title\":\"背包九讲\",\"slug\":\"/post/algorithm/knapsack\",\"tags\":[\"acm\",\"算法\",\"动态规划\",\"背包问题\"],\"createdAt\":\"Jun 27, 2021\"},{\"title\":\"React Reconciliation\",\"slug\":\"/post/web/react/reconciliation\",\"tags\":[\"react\",\"react reconciliation\"],\"createdAt\":\"Jun 26, 2021\"},{\"title\":\"扔鸡蛋问题\",\"slug\":\"/post/quiz/dp/egg-drop\",\"tags\":[\"quiz\",\"动态规划\"],\"createdAt\":\"Jun 20, 2021\"},{\"title\":\"端口管理\",\"slug\":\"/post/network/端口管理\",\"tags\":[\"network\",\"port\",\"ssh\",\"netstat\"],\"createdAt\":\"Jun 20, 2021\"},{\"title\":\"最长公共子序列（LCS）\",\"slug\":\"/post/algorithm/lcs\",\"tags\":[\"最长公共子序列\",\"LCS\"],\"createdAt\":\"Jun 02, 2021\"},{\"title\":\"最长上升子序列（LIS）\",\"slug\":\"/post/algorithm/lis\",\"tags\":[\"最长上升子序列\",\"LIS\"],\"createdAt\":\"Jun 02, 2021\"},{\"title\":\"Dijkstra 算法\",\"slug\":\"/post/algorithm/graph/shortest-path/dijkstra\",\"tags\":[\"算法\",\"最短路\",\"单源最短路\",\"dijkstra\"],\"createdAt\":\"May 29, 2021\"},{\"title\":\"函数的极限\",\"slug\":\"/post/math/calculus/函数的极限\",\"tags\":[\"math\",\"函数\",\"极限\"],\"createdAt\":\"May 09, 2021\"},{\"title\":\"ECMA 2020 新特性\",\"slug\":\"/post/web/javascript/2020\",\"tags\":[\"javascript\",\"ecmascript\"],\"createdAt\":\"Apr 05, 2021\"},{\"title\":\"ECMA 2021 新特性\",\"slug\":\"/post/web/javascript/2021\",\"tags\":[\"javascript\",\"ecmascript\"],\"createdAt\":\"Apr 05, 2021\"},{\"title\":\"在 excel 中启用正则表达式\",\"slug\":\"/post/tool/excel/regex\",\"tags\":[\"excel\",\"tools\"],\"createdAt\":\"Mar 29, 2021\"},{\"title\":\"CSS 选择器\",\"slug\":\"/post/web/css/selector\",\"tags\":[\"web\",\"frontend\",\"css\"],\"createdAt\":\"Nov 02, 2020\"},{\"title\":\"Custom React Hooks\",\"slug\":\"/post/web/react/hooks/custom\",\"tags\":[\"react\",\"react hooks\"],\"createdAt\":\"Oct 29, 2020\"},{\"title\":\"组合游戏基础之 SG 函数和 SG 定理\",\"slug\":\"/post/math/combinatorial/SG\",\"tags\":[\"组合数学\",\"组合游戏\",\"SG 定理\"],\"createdAt\":\"Sep 04, 2016\"},{\"title\":\"网络流 24 题\",\"slug\":\"/post/algorithm/graph/network-flow/24-problems\",\"tags\":[\"acm\",\"算法\",\"图论\",\"网络流\",\"二分图\",\"解题报告\",\"专题训练\"],\"createdAt\":\"Jul 30, 2016\"},{\"title\":\"网络流基础之最大权闭合图\",\"slug\":\"/post/algorithm/graph/network-flow/最大权闭合图\",\"tags\":[\"算法\",\"图论\",\"网络流\",\"最大权闭合图\"],\"createdAt\":\"Jul 24, 2016\"},{\"title\":\"2016 多校第 2 场\",\"slug\":\"/post/acm/contest/multi-university-training/2016/2\",\"tags\":[\"acm\",\"训练赛\",\"数据结构\",\"解题报告\"],\"createdAt\":\"Jul 22, 2016\"},{\"title\":\"二分图\",\"slug\":\"/post/algorithm/graph/bipartite-graph\",\"tags\":[\"算法\",\"图论\",\"二分图\",\"学习笔记\"],\"createdAt\":\"Jul 17, 2016\"},{\"title\":\"伸展树专题\",\"slug\":\"/post/data-structure/bbst/splay\",\"tags\":[\"acm\",\"Splay\",\"解题报告\",\"专题训练\"],\"createdAt\":\"Jul 03, 2016\"},{\"title\":\"CCF 2015-09 最佳文章 解题报告\",\"slug\":\"/post/acm/oj/ccf/2015/09/E\",\"tags\":[\"acm\",\"Aho-Corasick 自动机\",\"矩阵快速幂\",\"动态规划\",\"解题报告\"],\"createdAt\":\"Jun 26, 2016\"},{\"title\":\"编译原理-语法制导翻译实现计算器\",\"slug\":\"/post/fundamentals-of-compiling/exercise\",\"tags\":[\"编译原理\",\"语法制导翻译\",\"计算机\"],\"createdAt\":\"Jun 23, 2016\"},{\"title\":\"编译原理-语法分析\",\"slug\":\"/post/fundamentals-of-compiling/grammar\",\"tags\":[\"编译原理\",\"语法分析\",\"计算机\"],\"createdAt\":\"Jun 18, 2016\"},{\"title\":\"百度之星 2016 解题报告\",\"slug\":\"/post/acm/contest/baiduzhixing/2016\",\"tags\":[\"acm\",\"递推\",\"状态压缩\",\"动态规划\",\"字典树\",\"解题报告\"],\"createdAt\":\"Jun 03, 2016\"},{\"title\":\"数论基础之原根\",\"slug\":\"/post/math/number-theory/原根\",\"tags\":[\"math\",\"数论\",\"原根\"],\"createdAt\":\"May 16, 2016\"},{\"title\":\"数论基础之欧拉函数\",\"slug\":\"/post/math/number-theory/欧拉函数\",\"tags\":[\"math\",\"数论\",\"既约剩余系\",\"欧拉函数\"],\"createdAt\":\"May 10, 2016\"},{\"title\":\"数论基础之筛法\",\"slug\":\"/post/math/number-theory/sieve\",\"tags\":[\"math\",\"数论\",\"素数\",\"欧拉函数\",\"线性筛\"],\"createdAt\":\"May 06, 2016\"},{\"title\":\"数论基础之模方程初步\",\"slug\":\"/post/math/number-theory/模方程/basic\",\"tags\":[\"math\",\"数论\",\"扩展欧几里得算法\",\"中国剩余定理\",\"Baby Step Gaint Step\"],\"createdAt\":\"May 04, 2016\"},{\"title\":\"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)\",\"slug\":\"/post/acm/oj/hdu/5576\",\"tags\":[\"acm\",\"动态规划\",\"解题报告\"],\"createdAt\":\"Apr 24, 2016\"},{\"title\":\"树链剖分\",\"slug\":\"/post/algorithm/tree/tcs\",\"tags\":[\"acm\",\"算法\",\"树链剖分\"],\"createdAt\":\"Apr 23, 2016\"},{\"title\":\"51nod-1462 数据结构 -- 解题报告\",\"slug\":\"/post/acm/oj/51nod/1462\",\"tags\":[\"acm\",\"数据结构\",\"树链剖分\",\"线段树\",\"解题报告\"],\"createdAt\":\"Apr 23, 2016\"},{\"title\":\"小球放盒模型\",\"slug\":\"/post/math/combinatorial/小球放盒模型\",\"tags\":[\"math\",\"组合数学\"],\"createdAt\":\"Apr 22, 2016\"},{\"title\":\"最长回文子串 Manacher 算法\",\"slug\":\"/post/algorithm/string/manacher\",\"tags\":[\"算法\",\"字符串\",\"回文串\",\"manacher\"],\"createdAt\":\"Apr 18, 2016\"},{\"title\":\"POJ-1324 Holedox Moving 解题报告\",\"slug\":\"/post/acm/oj/poj/1324\",\"tags\":[\"acm\",\"bfs\",\"图论\",\"状态压缩\",\"解题报告\"],\"createdAt\":\"Apr 13, 2016\"},{\"title\":\"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）\",\"slug\":\"/post/acm/oj/hdu/5574\",\"tags\":[\"acm\",\"数据结构\",\"树链剖分\",\"线段树\",\"解题报告\"],\"createdAt\":\"Apr 12, 2016\"},{\"title\":\"快速傅里叶变换和雷德算法\",\"slug\":\"/post/math/number-theory/fft\",\"tags\":[\"acm\",\"大数乘法\",\"fft\",\"快速傅里叶变换\"],\"createdAt\":\"Apr 10, 2016\"},{\"title\":\"HDU-5306 Gorgeous Sequence 解题报告\",\"slug\":\"/post/acm/oj/hdu/5306\",\"tags\":[\"acm\",\"数据结构\",\"线段树\",\"解题报告\"],\"createdAt\":\"Apr 09, 2016\"}]},\"storageKey\":\"@kyokuya/react-layout-post/#page\",\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(post)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]}]}]\n"])</script><script>self.__next_f.push([1,"17:[\"quiz\",\"分治\",\"追击\"]\n"])</script><script>self.__next_f.push([1,"8:[\"$\",\"$L16\",null,{\"data\":{\"title\":\"不修改数组找出重复的数字\",\"titleAst\":{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"不修改数组找出重复的数字\"}]},\"slug\":\"/post/quiz/partition/find-duplicate-number\",\"createdAt\":\"Jun 29, 2021\",\"updatedAt\":\"Nov 03, 2021\",\"timeToRead\":\"07min 52s\",\"tags\":\"$17\",\"categories\":[],\"ast\":{\"type\":\"root\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"children\":[{\"type\":\"text\",\"value\":\"问题描述\"}],\"identifier\":\"heading-问题描述\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"给定一个长度为 \"},{\"type\":\"inlineMath\",\"value\":\"N + 1\"},{\"type\":\"text\",\"value\":\" 的数列 \"},{\"type\":\"inlineMath\",\"value\":\"A=\\\\lbrace a_0, a_1, a_2 \\\\cdots, a_N \\\\rbrace\"},{\"type\":\"text\",\"value\":\".\"},{\"type\":\"break\"},{\"type\":\"text\",\"value\":\"\\n其中 \"},{\"type\":\"inlineMath\",\"value\":\"1 \\\\leqslant a_i \\\\leqslant N,\\\\; 0 \\\\leqslant i \\\\leqslant N,\\\\; N \\\\geqslant 1\"},{\"type\":\"text\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"在满足以下限制的前提下找出数组中任意一个重复的数字：\"}]},{\"type\":\"list\",\"ordered\":false,\"marker\":42,\"spread\":false,\"children\":[{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"不能修改输入的数组；\"}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"只能使用 \"},{\"type\":\"inlineMath\",\"value\":\"O(1)\"},{\"type\":\"text\",\"value\":\" 的额外空间；\"}]}]},{\"type\":\"heading\",\"depth\":2,\"children\":[{\"type\":\"text\",\"value\":\"分治法\"}],\"identifier\":\"heading-分治法\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"分治算法的思想是不断收紧区间范围以确定重复的数字\"},{\"type\":\"strong\",\"children\":[{\"type\":\"text\",\"value\":\"其值\"}]},{\"type\":\"text\",\"value\":\"所在的区间范围，当区间长度为 \"},{\"type\":\"inlineMath\",\"value\":\"1\"},{\"type\":\"text\",\"value\":\" 时，则找到了那个重复的数字（相当于二分答案）。\"}]},{\"type\":\"heading\",\"depth\":3,\"children\":[{\"type\":\"text\",\"value\":\"算法描述\"}],\"identifier\":\"heading-算法描述\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"根据鸽巢原理易知，原数组中必然至少有一个重复的数字，即答案所在区间为 \"},{\"type\":\"inlineMath\",\"value\":\"[1,N]\"},{\"type\":\"text\",\"value\":\"。不妨取 \"},{\"type\":\"inlineMath\",\"value\":\"\\\\displaystyle x = \\\\left\\\\lfloor \\\\frac{1+N}{2} \\\\right\\\\rfloor\"},{\"type\":\"text\",\"value\":\"，则要么有\\n\"},{\"type\":\"inlineMath\",\"value\":\"x+1\"},{\"type\":\"text\",\"value\":\" 个数的值落在区间 \"},{\"type\":\"inlineMath\",\"value\":\"[1,x]\"},{\"type\":\"text\",\"value\":\" 中，要么有 \"},{\"type\":\"inlineMath\",\"value\":\"N-x\"},{\"type\":\"text\",\"value\":\" 个值落在区间 \"},{\"type\":\"inlineMath\",\"value\":\"[x+1,N)\"},{\"type\":\"text\",\"value\":\" 中\\n\"},{\"type\":\"footnoteReference\",\"label\":\"1\",\"identifier\":\"footnote-1\"},{\"type\":\"text\",\"value\":\"。这样，我们就把重复数字所在区间的长度缩减了一半了。重复操作，直到区间长度为 \"},{\"type\":\"inlineMath\",\"value\":\"1\"},{\"type\":\"text\",\"value\":\".\"}]},{\"type\":\"heading\",\"depth\":3,\"children\":[{\"type\":\"text\",\"value\":\"程序实现\"}],\"identifier\":\"heading-程序实现\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"时间复杂度： \"},{\"type\":\"inlineMath\",\"value\":\"O(N \\\\log N)\"},{\"type\":\"break\"},{\"type\":\"text\",\"value\":\"\\n空间复杂度（额外）： \"},{\"type\":\"inlineMath\",\"value\":\"O(1)\"}]},{\"type\":\"code\",\"lang\":\"cpp\",\"meta\":\"title=\\\"分治法.cpp\\\" sourcefile=\\\"./分治法.cpp\\\" sourceline=\\\"8-22\\\" collapsed linenos\",\"value\":\"int duplicateInArray(std::vector\u003cint\u003e\u0026 nums) {\\n  int L = 1, R = nums.size() - 1;\\n  for (int M, cnt; L \u003c R;) {\\n    M = (L + R) \u003e\u003e 1;\\n    cnt = 0;\\n    for (int x : nums) {\\n      if (x \u003e= L \u0026\u0026 x \u003c= M) cnt += 1;\\n    }\\n    if (cnt \u003e (M - L + 1))\\n      R = M;\\n    else\\n      L = M + 1;\\n  }\\n  return L;\\n}\"},{\"type\":\"heading\",\"depth\":2,\"children\":[{\"type\":\"text\",\"value\":\"追击法\"}],\"identifier\":\"heading-追击法\"},{\"type\":\"heading\",\"depth\":3,\"children\":[{\"type\":\"text\",\"value\":\"前置知识\"}],\"identifier\":\"heading-前置知识\"},{\"type\":\"list\",\"ordered\":false,\"marker\":42,\"spread\":true,\"children\":[{\"type\":\"listItem\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"如何判断一个链表有环呢？\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"采用双指针遍历链表，快指针每次走两步，慢指针每次走一步，若链表中存在环，则快指针一定能追上慢指针\\n\"},{\"type\":\"footnoteReference\",\"label\":\"2\",\"identifier\":\"footnote-2\"},{\"type\":\"text\",\"value\":\"。\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"因为至多在环内多跑一圈就可以追上慢指针，所以算法复杂度为：\"}]},{\"type\":\"list\",\"ordered\":false,\"marker\":45,\"spread\":false,\"children\":[{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"时间复杂度： \"},{\"type\":\"inlineMath\",\"value\":\"O(N)\"}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"空间复杂度： \"},{\"type\":\"inlineMath\",\"value\":\"O(1)\"}]}]}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"若链表中存在环，如何找到环的入口呢？\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"因为快指针（不妨记为 \"},{\"type\":\"inlineMath\",\"value\":\"x\"},{\"type\":\"text\",\"value\":\"）的速度是慢指针（不妨记为 \"},{\"type\":\"inlineMath\",\"value\":\"y\"},{\"type\":\"text\",\"value\":\"）的两倍，因此当慢指针在环内未走完一圈时就会被快指针追上\\n\"},{\"type\":\"footnoteReference\",\"label\":\"3\",\"identifier\":\"footnote-3\"},{\"type\":\"text\",\"value\":\"。不妨假设从出发位置到达环的起点的距离是 \"},{\"type\":\"inlineMath\",\"value\":\"d_0\"},{\"type\":\"text\",\"value\":\" 步，从相遇位置出发再走 \"},{\"type\":\"inlineMath\",\"value\":\"d_1\"},{\"type\":\"text\",\"value\":\" 步首次到达环的起始点，环的长度为 \"},{\"type\":\"inlineMath\",\"value\":\"l\"},{\"type\":\"text\",\"value\":\"，则有：\"}]},{\"type\":\"math\",\"value\":\"\\\\begin{aligned}\\n  \u0026d_0 + k_x \\\\cdot l - d_1 = 2(d_0 + k_y \\\\cdot l - d_1)\\\\\\\\\\n  \\\\Rightarrow\\\\quad\u0026k_x \\\\cdot l = d_0 + 2k_y \\\\cdot l - d_1\\\\\\\\\\n  \\\\Rightarrow\\\\quad\u0026d_1 = d_0 + (k_x-2k_y) \\\\cdot l\\\\\\\\\\n\\\\end{aligned}\\n\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"其中 \"},{\"type\":\"inlineMath\",\"value\":\"k_x,k_y\"},{\"type\":\"text\",\"value\":\" 为正整数，分表表示快指针和慢指针走的圈数 \"},{\"type\":\"inlineMath\",\"value\":\"+1\"},{\"type\":\"text\",\"value\":\"（根据前面的分析，我们知道此处 \"},{\"type\":\"inlineMath\",\"value\":\"k_y=1\"},{\"type\":\"text\",\"value\":\"，虽然这对算法并没有影响）。观察上式可以发现，若慢指针再行走 \"},{\"type\":\"inlineMath\",\"value\":\"d_0\"},{\"type\":\"text\",\"value\":\" 步，即可到达环的起点。这给了我们一个启发，即当慢指针和快指针相遇时，我们再放一个新的慢指针 \"},{\"type\":\"inlineMath\",\"value\":\"z\"},{\"type\":\"text\",\"value\":\" 让它从链表起点出发，在它走到环的起点时，恰好走了\\n\"},{\"type\":\"inlineMath\",\"value\":\"d_0\"},{\"type\":\"text\",\"value\":\" 步，并与慢指针 \"},{\"type\":\"inlineMath\",\"value\":\"x\"},{\"type\":\"text\",\"value\":\" 相遇。\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"综上，我们仅需在快指针和慢指针相遇时，放一个新的慢指针从链表起点出发，当两个慢指针相遇时，即到达环的入口。\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"因为在找到环的基础上至多走 \"},{\"type\":\"inlineMath\",\"value\":\"d_0\"},{\"type\":\"text\",\"value\":\" 步，所以算法复杂度为：\"}]},{\"type\":\"list\",\"ordered\":false,\"marker\":45,\"spread\":false,\"children\":[{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"时间复杂度： \"},{\"type\":\"inlineMath\",\"value\":\"O(N)\"}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"空间复杂度： \"},{\"type\":\"inlineMath\",\"value\":\"O(1)\"}]}]}]}]},{\"type\":\"heading\",\"depth\":3,\"children\":[{\"type\":\"text\",\"value\":\"算法描述\"}],\"identifier\":\"heading-算法描述-2\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"因为原题中的数列的数值范围在 \"},{\"type\":\"inlineMath\",\"value\":\"[1,N]\"},{\"type\":\"text\",\"value\":\" 之间，而这些值都属于原数列的有效下标，因此不妨假设原数组描述的是一个下标指向值的链表，即 \"},{\"type\":\"inlineMath\",\"value\":\"i \\\\rightarrow a_i\"},{\"type\":\"text\",\"value\":\"，下一步再将\\n\"},{\"type\":\"inlineMath\",\"value\":\"a_i\"},{\"type\":\"text\",\"value\":\" 看做新的位置，指向 \"},{\"type\":\"inlineMath\",\"value\":\"a_{a_i}\"},{\"type\":\"text\",\"value\":\"，以此类推。\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"不难发现这个链表中一定存在环，因为若不存在环，且走过了 \"},{\"type\":\"inlineMath\",\"value\":\"k\"},{\"type\":\"text\",\"value\":\" 个位置，则这 \"},{\"type\":\"inlineMath\",\"value\":\"k\"},{\"type\":\"text\",\"value\":\" 个位置对应的数值必然不相同\\n\"},{\"type\":\"footnoteReference\",\"label\":\"4\",\"identifier\":\"footnote-4\"},{\"type\":\"text\",\"value\":\"，则最后一个数字会指向一个新的下标，直到空间 \"},{\"type\":\"inlineMath\",\"value\":\"[1,N]\"},{\"type\":\"text\",\"value\":\" 内的所有下标都被消耗完。而因为总共有 \"},{\"type\":\"inlineMath\",\"value\":\"N+1\"},{\"type\":\"text\",\"value\":\" 个数却只有 \"},{\"type\":\"inlineMath\",\"value\":\"N\"},{\"type\":\"text\",\"value\":\" 个下标，根据鸽巢原理可知，必然至少有一个下标会被重复使用。\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"根据前面的分析，不难有：\"}]},{\"type\":\"list\",\"ordered\":false,\"marker\":42,\"spread\":false,\"children\":[{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"从任意位置出发，都必然到达环；\"}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"text\",\"value\":\"环的起始位置对应的数值即为原问题中的重复的数；\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"不妨从位置 \"},{\"type\":\"inlineMath\",\"value\":\"0\"},{\"type\":\"text\",\"value\":\" 出发，假设从 \"},{\"type\":\"inlineMath\",\"value\":\"a_x\"},{\"type\":\"text\",\"value\":\" 位置进入环，则环内必然存在一个位置 \"},{\"type\":\"inlineMath\",\"value\":\"j\"},{\"type\":\"text\",\"value\":\"，满足\\n\"},{\"type\":\"inlineMath\",\"value\":\"a_j=a_x\"},{\"type\":\"text\",\"value\":\"，即环的入口处是原数列中的一个重复数字：\"}]},{\"type\":\"code\",\"lang\":\"graphviz\",\"meta\":\"embed engine=dot\",\"value\":\"digraph g2 {\\n  graph [pad=\\\"0.212,0.055\\\" bgcolor=transparent]\\n  rankdir=LR\\n  node [\\n    fillcolor=\\\"#808080\\\"\\n    fixedsize=true\\n    fontcolor=\\\"#ffffff\\\"\\n    fontsize=14\\n    ordering=out\\n    shape=circle\\n    style=filled\\n    width=0.4\\n  ]\\n\\n  a [label=\\\"i=0\\\"]\\n  b [label=\\\"a[i]\\\"]\\n  c [label=\\\"a[a[i]]\\\" width=0.6]\\n  d [label=\\\"...\\\"]\\n  e [label=\\\"x\\\"]\\n  f [label=\\\"a[x]\\\"]\\n  g [label=\\\"a[a[x]]\\\" width=0.6]\\n  h [label=\\\"...\\\"]\\n  i [label=\\\"j\\\"]\\n\\n  a -\u003e b\\n  b -\u003e c\\n  c -\u003e d\\n  d -\u003e e\\n  e -\u003e f\\n  f -\u003e g\\n  g -\u003e h\\n  h -\u003e i\\n  i -\u003e f\\n}\\n\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"剩下的问题按照前文求链表的入口的算法求解即可，此处不再赘述。\"}]},{\"type\":\"heading\",\"depth\":3,\"children\":[{\"type\":\"text\",\"value\":\"程序实现\"}],\"identifier\":\"heading-程序实现-2\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"时间复杂度： \"},{\"type\":\"inlineMath\",\"value\":\"O(N)\"},{\"type\":\"break\"},{\"type\":\"text\",\"value\":\"\\n空间复杂度（额外）： \"},{\"type\":\"inlineMath\",\"value\":\"O(1)\"}]},{\"type\":\"code\",\"lang\":\"cpp\",\"meta\":\"title=\\\"追击法.cpp\\\" sourcefile=\\\"./追击法.cpp\\\" sourceline=\\\"9-23\\\" collapsed linenos\",\"value\":\"int duplicateInArray(std::vector\u003cint\u003e\u0026 nums) {\\n  int x = 0, y = 0;\\n\\n  while (x == 0 || x != y) {\\n    x = nums[nums[x]];\\n    y = nums[y];\\n  }\\n\\n  for (x = 0; x != y;) {\\n    x = nums[x];\\n    y = nums[y];\\n  }\\n\\n  return x;\\n}\"},{\"type\":\"heading\",\"depth\":2,\"children\":[{\"type\":\"text\",\"value\":\"Related\"}],\"identifier\":\"heading-related\"},{\"type\":\"list\",\"ordered\":false,\"marker\":42,\"spread\":false,\"children\":[{\"type\":\"listItem\",\"children\":[{\"type\":\"link\",\"url\":\"https://www.acwing.com/problem/content/15/\",\"children\":[{\"type\":\"text\",\"value\":\"不修改数组找出重复的数字 | AcWing\"}]}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"link\",\"url\":\"https://www.acwing.com/solution/content/1220/\",\"children\":[{\"type\":\"text\",\"value\":\"不修改数组找出重复的数字 - \"},{\"type\":\"inlineMath\",\"value\":\"O(n)\"},{\"type\":\"text\",\"value\":\" 解法\"}]}]},{\"type\":\"listItem\",\"children\":[{\"type\":\"link\",\"url\":\"https://www.acwing.com/solution/content/46422/\",\"children\":[{\"type\":\"text\",\"value\":\"不修改数组找出重复的数字 \"},{\"type\":\"inlineMath\",\"value\":\"O(n)\"},{\"type\":\"text\",\"value\":\" 的证明 | AcWing 题解\"}]}]}]}]},\"toc\":{\"children\":[{\"depth\":2,\"identifier\":\"heading-问题描述\",\"contents\":[{\"type\":\"text\",\"value\":\"问题描述\"}],\"children\":[]},{\"depth\":2,\"identifier\":\"heading-分治法\",\"contents\":[{\"type\":\"text\",\"value\":\"分治法\"}],\"children\":[{\"depth\":3,\"identifier\":\"heading-算法描述\",\"contents\":[{\"type\":\"text\",\"value\":\"算法描述\"}],\"children\":[]},{\"depth\":3,\"identifier\":\"heading-程序实现\",\"contents\":[{\"type\":\"text\",\"value\":\"程序实现\"}],\"children\":[]}]},{\"depth\":2,\"identifier\":\"heading-追击法\",\"contents\":[{\"type\":\"text\",\"value\":\"追击法\"}],\"children\":[{\"depth\":3,\"identifier\":\"heading-前置知识\",\"contents\":[{\"type\":\"text\",\"value\":\"前置知识\"}],\"children\":[]},{\"depth\":3,\"identifier\":\"heading-算法描述-2\",\"contents\":[{\"type\":\"text\",\"value\":\"算法描述\"}],\"children\":[]},{\"depth\":3,\"identifier\":\"heading-程序实现-2\",\"contents\":[{\"type\":\"text\",\"value\":\"程序实现\"}],\"children\":[]}]},{\"depth\":2,\"identifier\":\"heading-related\",\"contents\":[{\"type\":\"text\",\"value\":\"Related\"}],\"children\":[]}]},\"ecmaImports\":[],\"definitionMap\":{},\"footnoteDefinitionMap\":{\"footnote-1\":{\"type\":\"footnoteDefinition\",\"identifier\":\"footnote-1\",\"label\":\"1\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"可以用反证法来证明：若至多有 \"},{\"type\":\"inlineMath\",\"value\":\"x\"},{\"type\":\"text\",\"value\":\" 个数的值落在区间 \"},{\"type\":\"inlineMath\",\"value\":\"[1,x]\"},{\"type\":\"text\",\"value\":\" 中，至多有 \"},{\"type\":\"inlineMath\",\"value\":\"N-x-1\"},{\"type\":\"text\",\"value\":\"\\n个值落在区间 \"},{\"type\":\"inlineMath\",\"value\":\"[x+1,N)\"},{\"type\":\"text\",\"value\":\" 中，则数字总数为 \"},{\"type\":\"inlineMath\",\"value\":\"x+(N-x-1)=N-1 \\\\neq N\"},{\"type\":\"text\",\"value\":\"，与原数列大小矛盾。\"}]}]},\"footnote-2\":{\"type\":\"footnoteDefinition\",\"identifier\":\"footnote-2\",\"label\":\"2\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"需要注意的是，快指针是每次走两步，而不是直接跳两步。显然快指针会先进入环，慢指针后进入环，之后在环内快指针一定会和慢指针相遇。\"}]}]},\"footnote-3\":{\"type\":\"footnoteDefinition\",\"identifier\":\"footnote-3\",\"label\":\"3\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"在环内走的时候，若慢指针刚好走完一圈，此时快指针走完两圈，必然会遇见慢指针，因此慢指针最多走一圈；又因为慢指针刚好走完一圈时相遇则慢指针在刚入环时也必然和快指针相遇，故慢指针未走完一圈就会被快指针追上；不过这个条件其实不是必要的，事实上使用任意步长都不会影响算法的结果\"}]}]},\"footnote-4\":{\"type\":\"footnoteDefinition\",\"identifier\":\"footnote-4\",\"label\":\"4\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"text\",\"value\":\"可用反证法证明：若存在相同的两个值，根据定义，下一步它门将作为位置，即存在相同的两个位置，即链表中出现了环，与假设矛盾。\"}]}]}},\"images\":[],\"paginationUrl\":\"/posts/2\",\"prev\":{\"title\":\"背包九讲\",\"slug\":\"/post/algorithm/knapsack\"},\"next\":{\"title\":\"剑指offer 解题报告\",\"slug\":\"/post/acm/oj/nowcoder/jz-offer\"},\"aplayerOptions\":null}}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"不修改数组找出重复的数字 | guanghechen\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"不修改数组找出重复的数字\"}],[\"$\",\"meta\",\"4\",{\"name\":\"application-name\",\"content\":\"guanghechen\"}],[\"$\",\"link\",\"5\",{\"rel\":\"author\",\"href\":\"https://github.com/guanghechen\"}],[\"$\",\"meta\",\"6\",{\"name\":\"author\",\"content\":\"光和尘\"}],[\"$\",\"link\",\"7\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"meta\",\"8\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"7:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>