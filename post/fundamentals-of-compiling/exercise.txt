3:I[5613,[],""]
5:I[31778,[],""]
7:I[79286,["74","static/chunks/74-7e282a0396d7f2a7.js","32","static/chunks/32-143da17bc4ec1cff.js","800","static/chunks/800-912054c186d8d8b2.js","185","static/chunks/app/layout-a504c198bdaef95d.js"],"SiteProvider"]
8:I[54110,["74","static/chunks/74-7e282a0396d7f2a7.js","32","static/chunks/32-143da17bc4ec1cff.js","800","static/chunks/800-912054c186d8d8b2.js","185","static/chunks/app/layout-a504c198bdaef95d.js"],""]
9:I[74117,["74","static/chunks/74-7e282a0396d7f2a7.js","32","static/chunks/32-143da17bc4ec1cff.js","800","static/chunks/800-912054c186d8d8b2.js","185","static/chunks/app/layout-a504c198bdaef95d.js"],"MaterialThemeProvider"]
a:I[55153,["74","static/chunks/74-7e282a0396d7f2a7.js","800","static/chunks/800-912054c186d8d8b2.js","160","static/chunks/app/not-found-6312c913f6df2e0d.js"],"NotFoundView"]
4:["slug","fundamentals-of-compiling/exercise","c"]
0:["3Q2KX2Rv2j3rmtnDDMcDO",[[["",{"children":["(post)",{"children":["post",{"children":[["slug","fundamentals-of-compiling/exercise","c"],{"children":["__PAGE__?{\"slug\":[\"fundamentals-of-compiling\",\"exercise\"]}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(post)",{"children":["post",{"children":[["slug","fundamentals-of-compiling/exercise","c"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children","$4","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,"$L6",null]]},[null,["$","html",null,{"lang":"en","className":"__className_324942","children":[["$","head",null,{"children":[["$","meta",null,{"charSet":"utf8"}],["$","meta","viewport",{"name":"viewport","content":"initial-scale=1.0, width=device-width"}],["$","meta",null,{"name":"application-name","content":"guanghechen"}],["$","meta",null,{"name":"apple-mobile-web-app-title","content":"光和尘"}],["$","meta",null,{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta",null,{"name":"description","content":"Guanghechen's personal site"}],["$","meta",null,{"name":"format-detection","content":"telephone=no"}],["$","meta",null,{"name":"mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"msapplication-config","content":"/icons/browserconfig.xml"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#2B5797"}],["$","meta",null,{"name":"msapplication-tap-highlight","content":"no"}],["$","meta",null,{"name":"theme-color","content":"#a2466c"}],["$","meta",null,{"property":"og:type","content":"website"}],["$","meta",null,{"property":"og:title","content":"光和尘"}],["$","meta",null,{"property":"og:description","content":"光和尘的个人站点"}],["$","meta",null,{"property":"og:site_name","content":"guanghechen"}],["$","meta",null,{"property":"og:url","content":"https://preview.me.guanghechen.com"}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon.png"}]]}],["$","body",null,{"children":["$","$L7",null,{"children":["$","$L8",null,{"children":["$","$L9",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$La",null,{}],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2159a4b672631e08.css","precedence":"next","crossOrigin":""}]]}]}]}]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f2ccec9f31141b1c.css","precedence":"next","crossOrigin":""}]],"$Lb"]]]]
c:I[56057,["74","static/chunks/74-7e282a0396d7f2a7.js","32","static/chunks/32-143da17bc4ec1cff.js","438","static/chunks/438-0d453acf8ab6d73f.js","810","static/chunks/810-f40f89b0985f349e.js","659","static/chunks/659-9371700cffe803b3.js","646","static/chunks/646-7cf2544bb825810c.js","800","static/chunks/800-912054c186d8d8b2.js","448","static/chunks/448-b8230364e725d567.js","422","static/chunks/app/(post)/layout-094b6638f80e2940.js"],"YozoraThemeProvider"]
d:I[20593,["74","static/chunks/74-7e282a0396d7f2a7.js","32","static/chunks/32-143da17bc4ec1cff.js","438","static/chunks/438-0d453acf8ab6d73f.js","810","static/chunks/810-f40f89b0985f349e.js","659","static/chunks/659-9371700cffe803b3.js","646","static/chunks/646-7cf2544bb825810c.js","800","static/chunks/800-912054c186d8d8b2.js","448","static/chunks/448-b8230364e725d567.js","422","static/chunks/app/(post)/layout-094b6638f80e2940.js"],"PostLayoutView"]
e:I[59627,["74","static/chunks/74-7e282a0396d7f2a7.js","32","static/chunks/32-143da17bc4ec1cff.js","438","static/chunks/438-0d453acf8ab6d73f.js","810","static/chunks/810-f40f89b0985f349e.js","659","static/chunks/659-9371700cffe803b3.js","646","static/chunks/646-7cf2544bb825810c.js","595","static/chunks/595-b703eb015ecb0ded.js","551","static/chunks/551-fe68223b52683631.js","800","static/chunks/800-912054c186d8d8b2.js","448","static/chunks/448-b8230364e725d567.js","918","static/chunks/app/(post)/post/%5B...slug%5D/page-b8779ac8ae859451.js"],"PostDetailPageView"]
6:["$","$Lc",null,{"children":["$","$Ld",null,{"data":{"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数 e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"storageKey":"@kyokuya/react-layout-post/#page","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]}]}]
f:["编译原理","语法制导翻译","计算机"]
10:T16a2,#include <algorithm>
#include <cstdio>
#include <cstring>
#include <exception>
#include <iostream>
#include <vector>
using namespace std;

struct node {
  int id, syn, inh;
  node(int id = 0, int syn = 0, int inh = 0) : id(id), syn(syn), inh(inh) {
  }
};
char ll1Idx[128];
int ll1Table[10][10];
vector<int> ssdTable[10];

inline int idx(char c) {
  return ll1Idx[c];
}

inline void initLL1Table() {
  memset(ll1Idx, 0, sizeof ll1Idx);
  memset(ll1Table, -1, sizeof ll1Table);

  for (int k = '0'; k <= '9'; ++k) ll1Idx[k] = 1;
  ll1Idx['('] = 2;
  ll1Idx[')'] = 3;
  ll1Idx['+'] = 4;
  ll1Idx['-'] = 5;
  ll1Idx['*'] = 6;
  ll1Idx['/'] = 7;
  ll1Idx['$'] = 8;

  ll1Idx['A'] = -1;
  ll1Idx['B'] = -2;
  ll1Idx['C'] = -3;
  ll1Idx['D'] = -4;
  ll1Idx['E'] = -5;

  // 0: A -> BD
  ll1Table[1][1] = 0;
  ll1Table[1][2] = 0;

  // 1: A -> +BD
  ll1Table[1][4] = 1;

  // 2: A -> -BD
  ll1Table[1][5] = 2;

  // 3: B --> CE
  ll1Table[2][1] = 3;
  ll1Table[2][2] = 3;

  // 4: C --> digit
  ll1Table[3][1] = 4;

  // 5: C --> (A)
  ll1Table[3][2] = 5;

  // 6: D --> +BD
  ll1Table[4][4] = 6;

  // 7: D --> -BD
  ll1Table[4][5] = 7;

  // 8: D --> \varepsilon
  ll1Table[4][3] = 8;
  ll1Table[4][8] = 8;

  // 9: E --> *CE
  ll1Table[5][6] = 9;

  // 10: E --> /CE
  ll1Table[5][7] = 10;

  // 11: E --> \varepsilon
  ll1Table[5][3] = 11;
  ll1Table[5][4] = 11;
  ll1Table[5][5] = 11;
  ll1Table[5][8] = 11;
}


inline void initSSDTable() {
#define pb push_back
  for (int i = 0; i < 10; ++i) ssdTable[i].clear();

  // 0: A --> BD
  ssdTable[0].pb(idx('B'));
  ssdTable[0].pb(idx('D'));

  // 1: A --> +BD
  ssdTable[1].pb(idx('+'));
  ssdTable[1].pb(idx('B'));
  ssdTable[1].pb(idx('D'));

  // 2: A --> -BD
  ssdTable[2].pb(idx('-'));
  ssdTable[2].pb(idx('B'));
  ssdTable[2].pb(idx('D'));

  // 3: B --> CE
  ssdTable[3].pb(idx('C'));
  ssdTable[3].pb(idx('E'));

  // 4: C --> digit
  ssdTable[4].pb(idx('0'));

  // 5: C -> (A)
  ssdTable[5].pb(idx('('));
  ssdTable[5].pb(idx('A'));
  ssdTable[5].pb(idx(')'));

  // 6: D --> +BD
  ssdTable[6].pb(idx('+'));
  ssdTable[6].pb(idx('B'));
  ssdTable[6].pb(idx('D'));

  // 7: D --> -BD
  ssdTable[7].pb(idx('-'));
  ssdTable[7].pb(idx('B'));
  ssdTable[7].pb(idx('D'));

  // 8: D --> \varepsilon

  // 9: E --> *CE
  ssdTable[9].pb(idx('*'));
  ssdTable[9].pb(idx('C'));
  ssdTable[9].pb(idx('E'));

  // 10: E --> /CE
  ssdTable[10].pb(idx('/'));
  ssdTable[10].pb(idx('C'));
  ssdTable[10].pb(idx('E'));

  // 11: E --> \varepsilon
#undef pb
}

int getnum(const char*& s) {
  int num = 0;
  for (; isdigit(*s); ++s) num = num * 10 + *s - '0';
  return num;
}

const int endsym = idx('$');
void calculate(const char*& s, node& sy, int cur) {
  int id = idx(*s);
  if (!id) throw "Syntax Error";

  if (sy.id != endsym) {
    if (sy.id == id) {
      if (id == 1) {
        sy.syn = getnum(s);
      } else {
        ++s;
      }
      return;
    }
    if (sy.id > 0) throw "Syntax Error!";

    int Mid = ll1Table[-sy.id][id];
    if (Mid < 0) throw "Syntax Error!";

    node sym[4];

    for (int i = 0; i < ssdTable[Mid].size(); ++i) sym[i].id = ssdTable[Mid][i];
    if (ssdTable[Mid].size()) calculate(s, sym[0], cur + 1);

    switch (Mid) {
      // 0: A --> BD
      case 0:
        sym[1].inh = sym[0].syn;
        calculate(s, sym[1], cur + 1);
        sy.syn = sym[1].syn;
        break;

      // 1: A --> +BD
      case 1:
        calculate(s, sym[1], cur + 1);
        sym[2].inh = sym[1].syn;
        calculate(s, sym[2], cur + 1);
        sy.syn = sym[2].syn;
        break;

      // 2: A --> -BD
      case 2:
        calculate(s, sym[1], cur + 1);
        sym[2].inh = -sym[1].syn;
        calculate(s, sym[2], cur + 1);
        sy.syn = sym[2].syn;
        break;

      // 3: B --> CE
      case 3:
        sym[1].inh = sym[0].syn;
        calculate(s, sym[1], cur + 1);
        sy.syn = sym[1].syn;
        break;

      // 4: C --> digit
      case 4:
        sy.syn = sym[0].syn;
        break;

      // 5: C --> (A)
      case 5:
        calculate(s, sym[1], cur + 1);
        sy.syn = sym[1].syn;
        calculate(s, sym[2], cur + 1);
        break;

      // 6: D --> +BD
      case 6:
        calculate(s, sym[1], cur + 1);
        sym[2].inh = sy.inh + sym[1].syn;
        calculate(s, sym[2], cur + 1);
        sy.syn = sym[2].syn;
        break;

      // 7: D --> -BD
      case 7:
        calculate(s, sym[1], cur + 1);
        sym[2].inh = sy.inh - sym[1].syn;
        calculate(s, sym[2], cur + 1);
        sy.syn = sym[2].syn;
        break;

      // 8: D --> \varepsilon
      case 8:
        sy.syn = sy.inh;
        break;

      // 9: E --> *CE
      case 9:
        calculate(s, sym[1], cur + 1);
        sym[2].inh = sy.inh * sym[1].syn;
        calculate(s, sym[2], cur + 1);
        sy.syn = sym[2].syn;
        break;

      // 10: E --> /CE
      case 10:
        calculate(s, sym[1], cur + 1);
        sym[2].inh = sy.inh / sym[1].syn;
        calculate(s, sym[2], cur + 1);
        sy.syn = sym[2].syn;
        break;

      // 11: E --> \varepsilon
      case 11:
        sy.syn = sy.inh;
        break;
    }
  }
}

int main() {
  string in;
  string coin;
  initLL1Table();
  initSSDTable();
  while (getline(cin, in)) {
    in.push_back('$');
    int len = in.length();
    const char* s = in.c_str();

    // 去除空格
    coin.clear();
    for (int i = 0; i < len; ++i)
      if (s[i] != ' ' && s[i] != '\t' && s[i] != '\n') coin.push_back(s[i]);
    coin.push_back('\0');

    try {
      node sy = node(idx('A'));
      s = coin.c_str();
      calculate(s, sy, 0);
      int ans = sy.syn;
      for (int i = 0; i < len - 1; ++i) putchar(in[i]);
      printf(" = %d\n", ans);
      printf("succuss!\n");
    } catch (const char* str) {
      puts(str);
    }
  }
  return 0;
}
11:T13df,export enum TokenSymbol {
  DIGIT = 1,
  OPEN_PAREN = 2,
  CLOSE_PAREN = 3,
  PLUS = 4,
  MINUS = 5,
  MULTI = 6,
  DIVIDE = 7,
  END = 8,
  A = -1,
  B = -2,
  C = -3,
  D = -4,
  E = -5,
}

/**
 * Priority map.
 */
const ll1IdxMap: Record<string, TokenSymbol> = Object.freeze({
  '0': TokenSymbol.DIGIT,
  '1': TokenSymbol.DIGIT,
  '2': TokenSymbol.DIGIT,
  '3': TokenSymbol.DIGIT,
  '4': TokenSymbol.DIGIT,
  '5': TokenSymbol.DIGIT,
  '6': TokenSymbol.DIGIT,
  '7': TokenSymbol.DIGIT,
  '8': TokenSymbol.DIGIT,
  '9': TokenSymbol.DIGIT,
  '(': TokenSymbol.OPEN_PAREN,
  ')': TokenSymbol.CLOSE_PAREN,
  '+': TokenSymbol.PLUS,
  '-': TokenSymbol.MINUS,
  '*': TokenSymbol.MULTI,
  '/': TokenSymbol.DIVIDE,
  $: TokenSymbol.END,
  A: TokenSymbol.A,
  B: TokenSymbol.B,
  C: TokenSymbol.C,
  D: TokenSymbol.D,
  E: TokenSymbol.E,
})

export const idx = (c: string): number => ll1IdxMap[c]

export const sddTable: number[][] = [
  'BD', //    0: A --> BD
  '+BD', //   1: A --> +BD
  '-BD', //   2: A --> -BD
  'CE', //    3: B --> CE
  '0', //     4: C --> digit
  '(A)', //   5: C --> (A)
  '+BD', //   6: D --> +BD
  '-BD', //   7: D --> -BD
  '', //      8: D --> \varepsilon
  '*CE', //   9: E --> *CE
  '/CE', //  10: E --> /CE
  '', //     11: E --> \varepsilon
].map(x => x.split('').map(idx))

// tokens: A,B,C,D,E
export const MAX_TOKENS = 5

// symbols: digit, (, ), +, -, *, /, $
export const MAX_SYMBOLS = 8

// LL1 table.
export const ll1Table: Int8Array[] = new Array(MAX_TOKENS + 1)

// Initialize LL1Table
{
  for (let i = 0; i <= MAX_TOKENS; ++i) {
    ll1Table[i] = new Int8Array(MAX_SYMBOLS + 1).fill(-1)
  }

  // 0: A -> BD
  ll1Table[1][1] = 0
  ll1Table[1][2] = 0

  // 1: A -> +BD
  ll1Table[1][4] = 1

  // 2: A -> -BD
  ll1Table[1][5] = 2

  // 3: B --> CE
  ll1Table[2][1] = 3
  ll1Table[2][2] = 3

  // 4: C --> digit
  ll1Table[3][1] = 4

  // 5: C --> (A)
  ll1Table[3][2] = 5

  // 6: D --> +BD
  ll1Table[4][4] = 6

  // 7: D --> -BD
  ll1Table[4][5] = 7

  // 8: D --> \varepsilon
  ll1Table[4][3] = 8
  ll1Table[4][8] = 8

  // 9: E --> *CE
  ll1Table[5][6] = 9

  // 10: E --> /CE
  ll1Table[5][7] = 10

  // 11: E --> \varepsilon
  ll1Table[5][3] = 11
  ll1Table[5][4] = 11
  ll1Table[5][5] = 11
  ll1Table[5][8] = 11
}

export function getNum(s: string, start: number): [number, number] {
  let result = 0
  let i: number = start
  for (; i < s.length; ++i) {
    const c = s[i]
    if (!/\d/.test(c)) break
    result = result * 10 + Number(c)
  }
  return [i, result]
}

export function calculate(rawExpression: string): number {
  let cur = 0
  const expression = rawExpression.replace(/[\s]+/g, '')
  const result: number = dfs(idx('A'), 0, 0)
  return cur === expression.length ? result : Number.NaN

  function dfs(id: number, syn: number, inh: number): number {
    if (cur === expression.length) {
      // Only D and E could be parsed as \varepsilon
      if (id === TokenSymbol.D || id === TokenSymbol.E) return inh
      return Number.NaN
    }

    const id0 = idx(expression[cur])

    // Unrecognized symbol.
    if (id0 === undefined) return Number.NaN

    // Matched an operator.
    if (id === id0) {
      // Matched digits.
      if (id0 === TokenSymbol.DIGIT) {
        const [nextCur, value] = getNum(expression, cur)

        // No valid digit found.
        if (cur === nextCur) return Number.NaN

        cur = nextCur
        return value
      }

      cur += 1
      return syn
    }

    // Syntax error.
    if (id > 0) return Number.NaN

    const ssdId = ll1Table[-id][id0]
    if (ssdId < 0) return Number.NaN

    const tokens: ReadonlyArray<number> = sddTable[ssdId]
    const syn0: number = tokens.length > 0 ? dfs(tokens[0], 0, 0) : 0

    switch (ssdId) {
      // 0: A --> BD
      case 0:
        return dfs(tokens[1], 0, syn0)

      // 1: A --> +BD
      case 1: {
        const val1: number = dfs(tokens[1], 0, 0)
        return dfs(tokens[2], 0, val1)
      }

      // 2: A --> -BD
      case 2: {
        const val1: number = dfs(tokens[1], 0, 0)
        return dfs(tokens[2], 0, -val1)
      }

      // 3: B --> CE
      case 3:
        return dfs(tokens[1], 0, syn0)

      // 4: C --> digit
      case 4:
        return syn0

      // 5: C --> (A)
      case 5: {
        const result: number = dfs(tokens[1], 0, 0)
        dfs(tokens[2], 0, 0)
        return result
      }

      // 6: D --> +BD
      case 6: {
        const val1: number = dfs(tokens[1], 0, 0)
        return dfs(tokens[2], 0, inh + val1)
      }

      // 7: D --> -BD
      case 7: {
        const val1: number = dfs(tokens[1], 0, 0)
        return dfs(tokens[2], 0, inh - val1)
      }

      // 8: D --> \varepsilon
      case 8:
        return inh

      // 9: E --> *CE
      case 9: {
        const val1: number = dfs(tokens[1], 0, 0)
        return dfs(tokens[2], 0, inh * val1)
      }

      // 10: E --> /CE
      case 10: {
        const val1: number = dfs(tokens[1], 0, 0)
        return dfs(tokens[2], 0, inh / val1)
      }

      // 11: E --> \varepsilon
      case 11:
        return inh
    }

    return 0
  }
}
2:["$","$Le",null,{"data":{"title":"编译原理-语法制导翻译实现计算器","titleAst":{"type":"paragraph","children":[{"type":"text","value":"编译原理-语法制导翻译实现计算器"}]},"slug":"/post/fundamentals-of-compiling/exercise","createdAt":"Jun 23, 2016","updatedAt":"Jun 04, 2023","timeToRead":"03min 31s","tags":"$f","categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"前言"}],"identifier":"heading-前言"},{"type":"paragraph","children":[{"type":"text","value":"设计一个文法，匹配合法的计算式，并返回正确计算式的结果。"}]},{"type":"paragraph","children":[{"type":"text","value":"一些定义："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"语法制导定义（Syntax-directed definitions, "},{"type":"strong","children":[{"type":"text","value":"SDD"}]},{"type":"text","value":"）"}]},{"type":"listItem","children":[{"type":"text","value":"语法制导翻译方案（Syntax-directed Translation Schema, "},{"type":"strong","children":[{"type":"text","value":"SDT"}]},{"type":"text","value":"）"}]}]},{"type":"paragraph","children":[{"type":"text","value":"其它一些编译原理相关的前置知识可以参考： "},{"type":"linkReference","identifier":"compiling-grammar","label":"compiling-grammar","referenceType":"full","children":[{"type":"text","value":"编译原理-语法分析 | 光和尘"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"文法"}],"identifier":"heading-文法"},{"type":"paragraph","children":[{"type":"text","value":"对于一个只支持加减乘除、括号、正负数的计算表达式，不难得到其产生式："}]},{"type":"math","value":"  \\begin{aligned}\n    &A \\rightarrow BD \\mid +BD \\mid -BD \\\\\n    &B \\rightarrow CE \\\\\n    &C \\rightarrow digit \\mid (A) \\\\\n    &D \\rightarrow +BD \\mid -BD \\mid \\varepsilon \\\\\n    &E \\rightarrow \\times CE \\mid \\div CE \\mid \\varepsilon \\\\\n  \\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"可求得它的 "},{"type":"inlineMath","value":"\\mathsf{FIRST}"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"\\mathsf{FOLLOW}"},{"type":"text","value":" 集为："}]},{"type":"math","value":"  \\begin{aligned}\n    \\mathsf{FIRST}(A)   &= \\Big\\lbrace digit,(,+,- \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(A)  &= \\Big\\lbrace \\$,) \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(B)   &= \\Big\\lbrace digit,( \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(B)  &= \\Big\\lbrace \\$,),+,- \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(C)   &= \\Big\\lbrace digit,( \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(C)  &= \\Big\\lbrace \\$,),*,\\div,+,- \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(D)   &= \\Big\\lbrace +,-,\\varepsilon \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(D)  &= \\Big\\lbrace \\$,) \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(E)   &= \\Big\\lbrace \\times,\\div,\\varepsilon \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(E)  &= \\Big\\lbrace \\$,),+,- \\Big\\rbrace\\\\\n  \\end{aligned}\n"},{"type":"heading","depth":3,"children":[{"type":"text","value":"LL(1) 预测分析表："}],"identifier":"heading-ll-1-预测分析表"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Token"}]},{"type":"tableCell","children":[{"type":"text","value":"digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"("}]},{"type":"tableCell","children":[{"type":"inlineMath","value":")"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"+"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"-"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"*"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\div"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\$"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"A"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow -BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"B"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"C"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow (A)"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"D"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow -BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"E"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\times CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\div CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"SDD"}],"identifier":"heading-sdd"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"#"}]},{"type":"tableCell","children":[{"type":"text","value":"产生式"}]},{"type":"tableCell","children":[{"type":"text","value":"语义规则"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow -BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= -B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E.inh    &= C.syn\\\\ B.syn &= E.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} C.syn    &= digit.lexval \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow (A)"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} C.syn    &= A.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow +BD_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D_1.inh  &= D.inh + B.syn\\\\ D.syn  &= D_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"7"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow -BD_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D_1.inh  &= D.inh - B.syn\\\\ D.syn  &= D_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"8"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.syn    &= D.inh \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"9"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\times CE_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E_1.inh  &= E.inh \\times C.syn\\\\ E.syn &= E_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"10"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\div CE_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E_1.inh  &= E.inh \\div C.syn\\\\ E.syn &= E_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"11"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E.syn    &= E.inh \\end{align}"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"C++"}]},{"type":"code","lang":"cpp","meta":"title=\"calculator.cpp\" sourcefile=\"./calculator.cpp\" maxlines=\"20\" collapsed linenos","value":"$10"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"Typescript (可以直接使用 "},{"type":"linkReference","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/calculate"}]},{"type":"text","value":")"}]},{"type":"code","lang":"typescript","meta":"title=\"calculator.ts\" sourcefile=\"./calculator.ts\" maxlines=\"20\" collapsed linenos","value":"$11"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"linkReference","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/calculate"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"compiling-grammar","label":"compiling-grammar","referenceType":"full","children":[{"type":"text","value":"编译原理-语法分析 | 光和尘"}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-前言","contents":[{"type":"text","value":"前言"}],"children":[]},{"depth":2,"identifier":"heading-文法","contents":[{"type":"text","value":"文法"}],"children":[{"depth":3,"identifier":"heading-ll-1-预测分析表","contents":[{"type":"text","value":"LL(1) 预测分析表："}],"children":[]},{"depth":3,"identifier":"heading-sdd","contents":[{"type":"text","value":"SDD"}],"children":[]}]},{"depth":2,"identifier":"heading-程序实现","contents":[{"type":"text","value":"程序实现"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"@algorithm.ts/calculate":{"type":"definition","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","url":"https://github.com/guanghechen/algorithm.ts/tree/main/packages/calculate#readme"},"compiling-grammar":{"type":"definition","identifier":"compiling-grammar","label":"compiling-grammar","url":"/post/fundamentals-of-compiling/grammar/"}},"footnoteDefinitionMap":{},"images":[],"paginationUrl":"/posts/5","prev":{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar"},"next":{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E"},"aplayerOptions":null}}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"编译原理-语法制导翻译实现计算器 | guanghechen"}],["$","meta","3",{"name":"description","content":"编译原理-语法制导翻译实现计算器"}],["$","meta","4",{"name":"application-name","content":"guanghechen"}],["$","link","5",{"rel":"author","href":"https://github.com/guanghechen"}],["$","meta","6",{"name":"author","content":"光和尘"}],["$","link","7",{"rel":"icon","href":"/favicon.png"}],["$","meta","8",{"name":"next-size-adjust"}]]
1:null
