3:I[5613,[],""]
5:I[31778,[],""]
7:I[79286,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-c863019bb2b3aef0.js"],"SiteProvider"]
8:I[54110,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-c863019bb2b3aef0.js"],""]
9:I[74117,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-c863019bb2b3aef0.js"],"MaterialThemeProvider"]
a:I[55153,["74","static/chunks/74-31f764c22632bceb.js","800","static/chunks/800-4848173b49d8d689.js","160","static/chunks/app/not-found-79f3557760569a3b.js"],"NotFoundView"]
4:["slug","algorithm/knapsack","c"]
0:["eyS7yEHAsi6_ceCdSwHos",[[["",{"children":["(post)",{"children":["post",{"children":[["slug","algorithm/knapsack","c"],{"children":["__PAGE__?{\"slug\":[\"algorithm\",\"knapsack\"]}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(post)",{"children":["post",{"children":[["slug","algorithm/knapsack","c"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children","$4","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,"$L6",null]]},[null,["$","html",null,{"lang":"en","className":"__className_324942","children":[["$","head",null,{"children":[["$","meta",null,{"charSet":"utf8"}],["$","meta","viewport",{"name":"viewport","content":"initial-scale=1.0, width=device-width"}],["$","meta",null,{"name":"application-name","content":"guanghechen"}],["$","meta",null,{"name":"apple-mobile-web-app-title","content":"光和尘"}],["$","meta",null,{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta",null,{"name":"description","content":"Guanghechen's personal site"}],["$","meta",null,{"name":"format-detection","content":"telephone=no"}],["$","meta",null,{"name":"mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"msapplication-config","content":"/icons/browserconfig.xml"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#2B5797"}],["$","meta",null,{"name":"msapplication-tap-highlight","content":"no"}],["$","meta",null,{"name":"theme-color","content":"#a2466c"}],["$","meta",null,{"property":"og:type","content":"website"}],["$","meta",null,{"property":"og:title","content":"光和尘"}],["$","meta",null,{"property":"og:description","content":"光和尘的个人站点"}],["$","meta",null,{"property":"og:site_name","content":"guanghechen"}],["$","meta",null,{"property":"og:url","content":"https://preview.me.guanghechen.com"}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon.png"}]]}],["$","body",null,{"children":["$","$L7",null,{"children":["$","$L8",null,{"children":["$","$L9",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$La",null,{}],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2159a4b672631e08.css","precedence":"next","crossOrigin":""}]]}]}]}]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f2ccec9f31141b1c.css","precedence":"next","crossOrigin":""}]],"$Lb"]]]]
c:I[56057,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-62c186fb5283557d.js","422","static/chunks/app/(post)/layout-dfa2e09a2a72ad66.js"],"YozoraThemeProvider"]
d:I[20593,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-62c186fb5283557d.js","422","static/chunks/app/(post)/layout-dfa2e09a2a72ad66.js"],"PostLayoutView"]
e:I[59627,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","595","static/chunks/595-60215c9a9c19277d.js","551","static/chunks/551-68df0022cc950ef8.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-62c186fb5283557d.js","918","static/chunks/app/(post)/post/%5B...slug%5D/page-80cd6d5787edd594.js"],"PostDetailPageView"]
6:["$","$Lc",null,{"children":["$","$Ld",null,{"data":{"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数 e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"storageKey":"@kyokuya/react-layout-post/#page","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]}]}]
f:["acm","算法","动态规划","背包问题"]
2:["$","$Le",null,{"data":{"title":"背包九讲","titleAst":{"type":"paragraph","children":[{"type":"text","value":"背包九讲"}]},"slug":"/post/algorithm/knapsack","createdAt":"Jun 27, 2021","updatedAt":"Nov 03, 2021","timeToRead":"34min 21s","tags":"$f","categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"01背包"}],"identifier":"heading-01背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 件物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析"},{"type":"paragraph","children":[{"type":"text","value":"因为每件物品只有两种选择：放或不放入背包。且每件物品之间相互独立，即无论第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":"\n件物品怎么选都不影响第 "},{"type":"inlineMath","value":"j\\;(i < j \\leqslant N)"},{"type":"text","value":" 件物品的决策 "},{"type":"footnoteReference","identifier":"2","label":"2"},{"type":"text","value":"。故可以考虑前\n"},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品在背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 时的最佳决策，即记 "},{"type":"inlineMath","value":"f(i, c)"},{"type":"text","value":" 表示当背包剩余容量为\n"},{"type":"inlineMath","value":"c"},{"type":"text","value":"，在前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品中做选择时可以获得的最大价值，不难得到状态转移方程："}]},{"type":"math","value":"f(i,c) = \\max \\big\\lbrace f(i-1, c),\\; f(i-1, c-v_i) + w_i \\big\\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"即枚举背包的剩余容量，在每个容量下，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品有“放”和“不放”两种决策，取所有可行决策中的最大值即为在指定容量下选取前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品能获得的最大价值。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"算法优化"}],"identifier":"heading-算法优化"},{"type":"paragraph","children":[{"type":"text","value":"在上述转移方程中，不难发现第一维始终是递增的，因此可以使用滚动数组。进一步的，注意到第二维也是具有单调性的，如果我们从 "},{"type":"inlineMath","value":"c=C"},{"type":"text","value":" 枚举到 "},{"type":"inlineMath","value":"c=0"},{"type":"text","value":"，不难发现，在求 "},{"type":"inlineMath","value":"f(i,c)"},{"type":"text","value":" 时，"},{"type":"inlineMath","value":"f(i-1,c)"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"f(i-1, c-v_i)"},{"type":"text","value":" 所占据的第二维下标均小于或等于\n"},{"type":"inlineMath","value":"c"},{"type":"text","value":"。也就是说如果我们只用一个一维数组 "},{"type":"inlineMath","value":"F(c)"},{"type":"text","value":" 表示 "},{"type":"inlineMath","value":"f(i-1,c)"},{"type":"text","value":"，则在求 "},{"type":"inlineMath","value":"f(i,c)"},{"type":"text","value":" 时，此时 "},{"type":"inlineMath","value":"F(c)=f(i-1,c)"},{"type":"text","value":"，"},{"type":"inlineMath","value":"F(c-v_i)=f(i-1,c-v_i)"},{"type":"text","value":"，若此时将 "},{"type":"inlineMath","value":"f(i,c)"},{"type":"text","value":" 赋值给 "},{"type":"inlineMath","value":"F(c)"},{"type":"text","value":"，则有："}]},{"type":"math","value":"F(x)=\\left\\lbrace\n  \\begin{aligned}\n    &f(i-1,x), &0 \\leqslant x < c\\\\\n    &f(i,x), &c \\leqslant x \\leqslant C\\\\\n  \\end{aligned}\n\\right.\n"},{"type":"paragraph","children":[{"type":"text","value":"而在求 "},{"type":"inlineMath","value":"f(i, c-1)"},{"type":"text","value":" 时再也不需要用到\n"},{"type":"inlineMath","value":"\\lbrace f(i-1,x) \\;\\mid\\; c \\leqslant x \\leqslant C \\rbrace"},{"type":"text","value":" 了。"}]},{"type":"paragraph","children":[{"type":"text","value":"综上，仅需一个一维数组即可完成状态转移，空间复杂度为 "},{"type":"inlineMath","value":"O(C)"},{"type":"text","value":"。同时，由于第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 个物品仅当背包剩余容量大于等于 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 时才能做“放入”的决策，因此我们在枚举 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 时只要枚举到 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 就够了 "},{"type":"footnoteReference","identifier":"3","label":"3"},{"type":"text","value":"。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"初始化细节"}],"identifier":"heading-初始化细节"},{"type":"paragraph","children":[{"type":"text","value":"01背包问题存在两个变种，仅需改变初始化方式即可求解："}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"恰好装满背包时可以获得到的最大价值"}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"将 "},{"type":"inlineMath","value":"F"},{"type":"text","value":" 初始化为："},{"type":"inlineMath","value":"\\displaystyle F(c) = \\left\\lbrace \\begin{align}&0,&c=0\\\\&-\\infty,&0<c\\leqslant C\\end{align}\\right."},{"type":"text","value":"."}]},{"type":"paragraph","children":[{"type":"text","value":"这样初始化相当于强制转移只能沿着“剩余容量恰好消耗完”的方向进行，若最后\n"},{"type":"inlineMath","value":"F(C)"},{"type":"text","value":" 不为 "},{"type":"inlineMath","value":"-\\infty"},{"type":"text","value":"，则说明可构造出一条转移路径使得背包容量恰好被消耗完，反之，则说明无解。"}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"无需恰好装满背包时，可以获得的最大价值"}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"将 "},{"type":"inlineMath","value":"F"},{"type":"text","value":" 初始化为："},{"type":"inlineMath","value":"\\displaystyle F(c) = 0, \\; 0 \\leqslant c \\leqslant C"},{"type":"text","value":"."}]},{"type":"paragraph","children":[{"type":"text","value":"即转移时无需考虑剩余容量是否有多余。"}]}]}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结"},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"O(N \\times C)"}]},{"type":"code","lang":"cpp","meta":"{9} title=\"01背包.cpp\" sourcefile=\"./01背包问题-01.cpp\" sourceline=\"5-18\" collapsed linenos","value":"const int MAX_C = 20000 + 10;\nint F[MAX_C];\n\nint solution(int N, int C) {\n  memset(F, 0, (C + 1) * sizeof(int));\n\n  for (int i = 0, V, W; i < N; ++i) {\n    scanf(\"%d%d\", &V, &W);\n    for (int c = C; c >= V; --c) {\n      F[c] = std::max(F[c], F[c - V] + W);\n    }\n  }\n  return F[C];\n}"},{"type":"heading","depth":2,"children":[{"type":"text","value":"完全背包"}],"identifier":"heading-完全背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 种物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"，且有无限件。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析-2"},{"type":"paragraph","children":[{"type":"text","value":"将第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品拆分成 "},{"type":"inlineMath","value":"\\displaystyle \\left\\lfloor \\frac{C}{v_i} \\right\\rfloor"},{"type":"text","value":"\n个，则问题转换成了 01背包问题，物品数量总计 "},{"type":"inlineMath","value":"\\displaystyle \\sum_{i=1}^N \\left\\lfloor \\frac{C}{v_i} \\right\\rfloor"},{"type":"text","value":"\n个。"}]},{"type":"paragraph","children":[{"type":"text","value":"基于此，存在两个优化："}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"若两种物品 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 满足 "},{"type":"inlineMath","value":"v_i \\leqslant v_j"},{"type":"text","value":" 且 "},{"type":"inlineMath","value":"w_i \\geqslant w_j"},{"type":"text","value":"，则删除第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 种物品，仅考虑第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品。因为如果最优解中选用了物品 "},{"type":"inlineMath","value":"j"},{"type":"text","value":"，那么把它取出来换成物品 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 放进去，得到的结果不会更差；"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"将第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品拆分成 "},{"type":"inlineMath","value":"\\left\\lbrace 2^0, 2^1, 2^2, \\cdots, ... 2^k \\right\\rbrace"},{"type":"text","value":"\n个 "},{"type":"footnoteReference","identifier":"4","label":"4"},{"type":"text","value":"，其中 "},{"type":"inlineMath","value":"\\displaystyle 2^k \\leqslant \\left\\lfloor \\frac{C}{v_i} \\right\\rfloor < 2^{k+1}"},{"type":"text","value":"，则无论最优结果种物品 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 选了多少个，都能保证存在这样的组合能选到这个数量（如果理解不了，可以想象成二进制表示法）。复杂度降为\n"},{"type":"inlineMath","value":"\\displaystyle O\\left( C \\times \\sum_{i=1}^N \\log \\left( \\left\\lfloor \\frac{C}{v_i} \\right\\rfloor \\right) \\right)"},{"type":"text","value":"."}]}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"算法优化"}],"identifier":"heading-算法优化-2"},{"type":"paragraph","children":[{"type":"text","value":"之前的分析中展示了可以通过拆分物品的方式将原问题转换为 01背包问题，其实原题和\n01背包问题的差别只是在前 "},{"type":"inlineMath","value":"i-1"},{"type":"text","value":" 种物品中做完选择后，在第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品中可以进行多次选择。那么什么时候能继续从第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品种进行选择呢？不难发现只要背包剩余容量大于 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 就可以继续做此决策。"}]},{"type":"paragraph","children":[{"type":"text","value":"记 "},{"type":"inlineMath","value":"f(i, c)"},{"type":"text","value":" 表示当背包容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"，在前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品中做选择时可以获得的最大价值，则状态转移方程为："}]},{"type":"math","value":"f(i,c) = \\max \\big\\lbrace f(i-1, c),\\; f(i, c - v_i) + w_i \\big\\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"观察上面的转移方程，不难发现前面"},{"type":"linkReference","identifier":"01背包-算法优化","label":"01背包-算法优化","referenceType":"collapsed","children":[{"type":"text","value":"01背包-算法优化"}]},{"type":"text","value":"中提到的优化策略仍然适用，不同的是，"},{"type":"inlineMath","value":"c"},{"type":"text","value":" 的枚举要从 "},{"type":"inlineMath","value":"0"},{"type":"text","value":" 到 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 方向进行。则有（注意观察，这里 "},{"type":"inlineMath","value":"F"},{"type":"text","value":" 值和01背包中的不同）："}]},{"type":"math","value":"F(x)=\\left\\lbrace\n  \\begin{aligned}\n    &f(i,x), &0 \\leqslant x < c\\\\\n    &f(i-1,x), &c \\leqslant x \\leqslant C\\\\\n  \\end{aligned}\n\\right.\n"},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结-2"},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"O(N \\times C)"}]},{"type":"code","lang":"cpp","meta":"{9} title=\"完全背包.cpp\" sourcefile=\"./完全背包问题-01.cpp\" sourceline=\"5-18\" collapsed linenos","value":"const int MAX_C = 20000 + 10;\nint F[MAX_C];\n\nint solution(int N, int C) {\n  memset(F, 0, (C + 1) * sizeof(int));\n\n  for (int i = 0, V, W; i < N; ++i) {\n    scanf(\"%d%d\", &V, &W);\n    for (int c = V; c <= C; ++c) {\n      F[c] = std::max(F[c], F[c - V] + W);\n    }\n  }\n  return F[C];\n}"},{"type":"heading","depth":2,"children":[{"type":"text","value":"多重背包"}],"identifier":"heading-多重背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 种物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"，共有 "},{"type":"inlineMath","value":"s_i"},{"type":"text","value":" 件。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析-3"},{"type":"paragraph","children":[{"type":"text","value":"可以延续"},{"type":"linkReference","identifier":"solution-完全背包","label":"solution-完全背包","referenceType":"full","children":[{"type":"text","value":"完全背包"}]},{"type":"text","value":"的拆分思路，将第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品拆分成\n"},{"type":"inlineMath","value":"\\left\\lbrace 2^0, 2^1, 2^2, \\cdots, 2^{k-1}, s_i-(2^{k} - 1) \\right\\rbrace"},{"type":"text","value":"\n个，其中 "},{"type":"inlineMath","value":"\\displaystyle 2^k \\leqslant s_i < 2^{k+1}"},{"type":"text","value":"，这样拆分得到的组合正好可以表达 "},{"type":"inlineMath","value":"0 \\sim s_i"},{"type":"text","value":" 之间的任意整数"},{"type":"footnoteReference","identifier":"5","label":"5"},{"type":"text","value":"。复杂度降为\n"},{"type":"inlineMath","value":"\\displaystyle O\\left( C \\times \\sum_{i=1}^N \\log s_i \\right)"},{"type":"text","value":"."}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"算法优化"}],"identifier":"heading-算法优化-3"},{"type":"paragraph","children":[{"type":"text","value":"记 "},{"type":"inlineMath","value":"f(i, c)"},{"type":"text","value":" 表示当背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"，从前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品中做选择时可以获得的最大价值，则状态转移方程为："}]},{"type":"math","value":"f(i,c) = \\max \\left\\lbrace f(i-1, c - m \\cdot v_i) + m \\cdot w_i \\;\\mid\\; 0 \\leqslant m \\leqslant s_i \\right\\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"不妨记 "},{"type":"inlineMath","value":"g=f(i-1), \\; h=f(i)"},{"type":"text","value":"。在描述算法前，先观察下列转移方程组（其中 "},{"type":"inlineMath","value":"0 \\leqslant m \\leqslant s_i"},{"type":"text","value":"）："}]},{"type":"math","value":"\\begin{aligned}\n  h(c)          &= \\max \\Big\\lbrace g(c - mv_i) + mw_i,\\, \\cdots,\\, g(c-v_i) + w_i,\\, g(c) \\Big\\rbrace\\\\\n  h(c+v_i)      &= \\max \\Big\\lbrace g(c - (m-1)v_i) + mw_i,\\, \\cdots,\\, g(c) + w_i,\\, g(c+v_i) \\Big\\rbrace\\\\\n  \\cdots\\\\\n  h(c+tv_i)     &= \\max \\Big\\lbrace g(c - (m-t)v_i) + mw_i,\\, \\cdots,\\, g(c + (t-1)v_i) + w_i,\\, g(c + tv_i) \\Big\\rbrace\\\\\n  h(c+(t+1)v_i) &= \\max \\Big\\lbrace g(c - (m-t-1)v_i) + mw_i,\\, \\cdots,\\, g(c + tv_i) + w_i,\\, g(c + (t+1)v_i) \\Big\\rbrace\\\\\n  \\cdots\\\\\n\\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"由上述转移方程组，可以列出 "},{"type":"inlineMath","value":"h(c+nv_i)"},{"type":"text","value":" 所需的 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 元素列表："}]},{"type":"math","value":"\\begin{aligned}\n  h(c)          &\\leftarrow g(c - mv_i),\\, \\cdots,\\, g(c-v_i),\\, g(c)\\\\\n  h(c+v_i)      &\\leftarrow g(c - (m-1)v_i),\\, \\cdots,\\, g(c),\\, g(c+v_i)\\\\\n  \\cdots\\\\\n  h(c+tv_i)     &\\leftarrow g(c - (m-t)v_i),\\, \\cdots,\\, g(c + (t-1)v_i),\\, g(c + tv_i)\\\\\n  h(c+(t+1)v_i) &\\leftarrow g(c - (m-t-1)v_i),\\, \\cdots,\\, g(c + tv_i),\\, g(c + (t+1)v_i)\\\\\n  \\cdots\\\\\n\\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"可以发现，对于 "},{"type":"inlineMath","value":"h(c+t \\cdot v_i)"},{"type":"text","value":" 来说，更新它所需要的 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 数列元素中除了首项（"},{"type":"inlineMath","value":"g(c - (m-t)v_i)"},{"type":"text","value":"）外，其它元素构成了 "},{"type":"inlineMath","value":"h(c+(t+1) \\cdot v_i)"},{"type":"text","value":" 所需的 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 数列元素的前缀子串。更一般地，记"}]},{"type":"math","value":"\\begin{aligned}\n  G(x)&=\\left\\lbrace g(x + mv_i) \\;\\middle|\\; 0 \\leqslant m \\leqslant \n    \\left\\lfloor\\frac{C-x}{v_i}\\right\\rfloor \\right\\rbrace, 0 \\leqslant x < v_i\\\\\n  H(x)&=\\left\\lbrace h(x + mv_i) \\;\\middle|\\; 0 \\leqslant m \\leqslant \n    \\left\\lfloor\\frac{C-x}{v_i}\\right\\rfloor \\right\\rbrace, 0 \\leqslant x < v_i\\\\\n\\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"则在求 "},{"type":"inlineMath","value":"H(x)"},{"type":"text","value":" 中任意项时，仅需要用到 "},{"type":"inlineMath","value":"G(x)"},{"type":"text","value":" 的子串元素，这启发我们可以对 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 进行分组。进一步观察，对比 "},{"type":"inlineMath","value":"h(c)"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"h(c+v_i)"},{"type":"text","value":" 所共同需要的 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 元素项中，后者每一项都加上了一个相同的 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":" 值，即 "},{"type":"inlineMath","value":"h(c)"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"h(c+v_i)"},{"type":"text","value":" 所需的 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 元素列表中，每项之间的值大小关系始终保持不变，于是问题可以转换为对数列 "},{"type":"inlineMath","value":"G(x)"},{"type":"text","value":" 查询固定长度的区间内的最大值，这是一个经典的滑动窗口问题，利用单调栈可以在均摊 "},{"type":"inlineMath","value":"O(1)"},{"type":"text","value":" 的复杂度完成查询。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结-3"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"二进制优化"}]},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"\\displaystyle O\\left( C \\times \\sum_{i=1}^N \\log s_i \\right)"}]},{"type":"code","lang":"cpp","meta":"{9-10,15} title=\"多重背包-01.cpp\" sourcefile=\"./多重背包问题-01.cpp\" sourceline=\"5-25\" collapsed linenos","value":"const int MAX_C = 20000 + 10;\nint F[MAX_C];\n\nint solution(int N, int C) {\n  memset(F, 0, (C + 1) * sizeof(int));\n\n  for (int i = 0, V, W, M; i < N; ++i) {\n    scanf(\"%d%d%d\", &V, &W, &M);\n    for (int k = 1; k <= M; k <<= 1) {\n      int m = (k << 1) <= M ? k : M - k + 1;\n      int V2 = m * V;\n      if (V2 > C) break;\n\n      int W2 = m * W;\n      for (int c = C; c >= V2; --c) {\n        F[c] = std::max(F[c], F[c - V2] + W2);\n      }\n    }\n  }\n  return F[C];\n}"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"单调栈优化"}]},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"O(N \\times C)"}]},{"type":"code","lang":"cpp","meta":"{19} title=\"多重背包-02.cpp\" sourcefile=\"./多重背包问题-02.cpp\" sourceline=\"5-40\" collapsed linenos","value":"const int MAX_C = 20000 + 10;\nint g[MAX_C], h[MAX_C];\nint ms[MAX_C];   // 单调栈\n\nint solution(int N, int C) {\n  memset(g, 0, sizeof(int) * (C + 1));\n\n  for (int i = 0, V, W, M, ss, tt; i < N; ++i) {\n    scanf(\"%d%d%d\", &V, &W, &M);\n\n    std::swap(g, h);\n    for (int x = 0; x < V; ++x) {\n      // 初始化单调栈\n      ss = 0;\n      tt = 1;\n      ms[0] = 0;\n      h[x] = g[x];\n\n      for (int c = x + V, k = 1; c <= C; c += V, k += 1) {\n        // 窗口长度最大为 M\n        if (k - ms[ss] > M) ss += 1;\n\n        // 单调栈中，栈底元素的值最大\n        h[c] = std::max(g[c], g[x + ms[ss] * V] + (k - ms[ss]) * W);\n\n        // 压栈\n        for (; ss < tt; --tt) {\n          int top = ms[tt - 1];\n          if (g[x + top * V] + (k - top) * W > g[c]) break;\n        }\n        ms[tt++] = k;\n      }\n    }\n  }\n  return h[C];\n}"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"混合背包"}],"identifier":"heading-混合背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 种物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 种物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n每种物品的件数可能为 1 件（[01背包][solution-01背包），无限件（"},{"type":"linkReference","identifier":"solution-完全背包","label":"solution-完全背包","referenceType":"full","children":[{"type":"text","value":"完全背包"}]},{"type":"text","value":"）及有限件（"},{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包"}]},{"type":"text","value":"）。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析-4"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"可以看做物品件数为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的\n"},{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包问题"}]},{"type":"text","value":"；"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"类似地，"},{"type":"linkReference","identifier":"solution-完全背包","label":"solution-完全背包","referenceType":"full","children":[{"type":"text","value":"完全背包问题"}]},{"type":"text","value":"可以看做物品件数为\n"},{"type":"inlineMath","value":"\\displaystyle \\left\\lfloor \\frac{C}{v_i} \\right\\rfloor"},{"type":"text","value":" （再多也装不下了）的"},{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包问题"}]},{"type":"text","value":"；"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"故而，问题规约成"},{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包问题"}]},{"type":"text","value":"。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结-4"},{"type":"paragraph","children":[{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"、"},{"type":"linkReference","identifier":"solution-完全背包","label":"solution-完全背包","referenceType":"full","children":[{"type":"text","value":"完全背包问题"}]},{"type":"text","value":"均可看做\n"},{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包问题"}]},{"type":"text","value":"的特例，因此混合背包问题也可以规约成多重背包问题。直接套用多重背包问题的解法即可得到复杂度为 "},{"type":"inlineMath","value":"O(C \\times V)"},{"type":"text","value":" 的算法。"}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"二进制优化"}]},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"\\displaystyle O\\left( C \\times \\sum_{i=1}^N \\log s_i \\right)"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"单调栈优化"}]},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"O(N \\times C)"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"二维费用的背包"}],"identifier":"heading-二维费用的背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 件物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":"、最大承重为 "},{"type":"inlineMath","value":"L"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，重量为 "},{"type":"inlineMath","value":"m_i"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析-5"},{"type":"paragraph","children":[{"type":"text","value":"虽然增加了重量一维，但是转移的状态并没有发生改变，可以完全套用 01背包的思路，只是在判断是否可以转移时要多检查一次重量是否满足条件。"}]},{"type":"paragraph","children":[{"type":"text","value":"记 "},{"type":"inlineMath","value":"f(i,c,l)"},{"type":"text","value":" 表示当背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"、剩余最大承重为 "},{"type":"inlineMath","value":"l"},{"type":"text","value":" 时，在前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品中做选择时可以获得的最大价值，不难得到状态转移方程："}]},{"type":"math","value":"f(i,c,l) = \\max \\big\\lbrace f(i-1,c,l),\\; f(i-1,c-v_i,l-m_i) + w_i \\big\\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"即枚举背包的剩余容量和剩余承重值，此时第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品有“放”和“不放”两种决策，取所有可行决策中的最大值即为在指定容量和最大承重下选取前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品能获得的最大价值。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"算法优化"}],"identifier":"heading-算法优化-4"},{"type":"paragraph","children":[{"type":"text","value":"类似"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包"}]},{"type":"text","value":"中提到的空间优化，二维费用的背包问题也可以省略掉物品数这一维："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"用一个二维数组 "},{"type":"inlineMath","value":"F(c,l)"},{"type":"text","value":" 表示 "},{"type":"inlineMath","value":"f(i-1, c, l)"},{"type":"text","value":"，则在求 "},{"type":"inlineMath","value":"f(i, c, l)"},{"type":"text","value":" 时，此时 "},{"type":"inlineMath","value":"F(c,l)=f(i-1,l)"},{"type":"text","value":"，"},{"type":"inlineMath","value":"F(c-v_i,l-m_i)=f(i-1,c-v_i, l-m_i)"},{"type":"text","value":"，若此时将 "},{"type":"inlineMath","value":"f(i,c,l)"},{"type":"text","value":"\n赋值给 "},{"type":"inlineMath","value":"F(c,l)"},{"type":"text","value":"，则有："}]},{"type":"math","value":"  F(x, y)=\\left\\lbrace\n    \\begin{aligned}\n    &f(i-1,x, y), &0 \\leqslant x < c, \\;\\text{或}\\; 0 \\leqslant y < l\\\\\n    &f(i,x, y), &c \\leqslant x \\leqslant C \\;\\text{且}\\; l \\leqslant y \\leqslant L\\\\\n    \\end{aligned}\n  \\right.\n"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结-5"},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(C \\times L)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"O(N \\times C \\times L)"}]},{"type":"code","lang":"cpp","meta":"{10} title=\"二维费用的背包问题.cpp\" sourcefile=\"./二维费用的背包问题-01.cpp\" sourceline=\"5-21\" collapsed linenos","value":"const int MAX_C = 100 + 10;\nconst int MAX_M = 100 + 10;\nint F[MAX_C][MAX_M];\n\nint solution(int N, int C, int T) {\n  memset(F, 0, sizeof(F));\n\n  for (int i = 0, V, W, M; i < N; ++i) {\n    scanf(\"%d%d%d\", &V, &M, &W);\n    for (int c = C; c >= V; --c) {\n      for (int m = T; m >= M; --m) {\n        F[c][m] = std::max(F[c][m], F[c - V][m - M] + W);\n      }\n    }\n  }\n  return F[C][T];\n}"},{"type":"heading","depth":2,"children":[{"type":"text","value":"分组背包"}],"identifier":"heading-分组背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 件物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_j"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n所有物品被划分成 "},{"type":"inlineMath","value":"K"},{"type":"text","value":" 组，其中第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 组物品中有 "},{"type":"inlineMath","value":"K_k"},{"type":"text","value":" 件物品；组内的物品相互冲突，即每组中最多选一件物品。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析-6"},{"type":"paragraph","children":[{"type":"text","value":"类似"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"，只不过在"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包"}]},{"type":"text","value":"中考虑的是“要不要取第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品”，而在分组背包中考虑的是“要不要取第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 组物品，要的话该取哪一件”；基于此不难想到，只要在内层循环中依次考虑第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 组物品内的所有物品的选取与否"},{"type":"footnoteReference","identifier":"6","label":"6"},{"type":"text","value":"就可以等效为"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"了。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结-6"},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"O(N \\times C)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"O(N \\times C)"}]},{"type":"code","lang":"cpp","meta":"{12,14} title=\"分组背包问题.cpp\" sourcefile=\"./分组背包问题-01.cpp\" sourceline=\"5-24\" collapsed linenos","value":"const int MAX_C = 10000 + 10;\nconst int MAX_N = 100 + 10;\nint F[MAX_C], V[MAX_N], W[MAX_N];\n\nint solution(int N, int C) {\n  memset(F, 0, sizeof(F));\n\n  for (int i = 0, K; i < N; ++i) {\n    scanf(\"%d\", &K);\n    for (int k = 0; k < K; ++k) scanf(\"%d%d\", V + k, W + k);\n\n    for (int c = C; c >= 0; --c) {\n      int& ans = F[c];\n      for (int k = 0; k < K; ++k) {\n        if (c >= V[k]) ans = std::max(ans, F[c - V[k]] + W[k]);\n      }\n    }\n  }\n  return F[C];\n}"},{"type":"heading","depth":2,"children":[{"type":"text","value":"有依赖的背包"}],"identifier":"heading-有依赖的背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 个物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n物品之间具有依赖关系，比如 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 依赖于 "},{"type":"inlineMath","value":"y"},{"type":"text","value":"，则在选择 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 时必须同时选取 "},{"type":"inlineMath","value":"y"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"简化版的问题"}],"identifier":"heading-简化版的问题"},{"type":"paragraph","children":[{"type":"text","value":"简单起见，不妨假设所有的物品的依赖关系构成一棵树，即除根节点外的所有物品恰好依赖一个物品，且不存在循环依赖。如下图所示，"},{"type":"inlineMath","value":"B"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 依赖 "},{"type":"inlineMath","value":"A"},{"type":"text","value":"，"},{"type":"inlineMath","value":"D"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"E"},{"type":"text","value":" 依赖于 "},{"type":"inlineMath","value":"B"},{"type":"text","value":"."}]},{"type":"code","lang":"graphviz","meta":"embed engine=dot","value":"graph tree1 {\n  graph [pad=\"0.212,0.055\" bgcolor=transparent]\n  node [\n    fillcolor=\"#ffffff\"\n    fixedsize=true\n    fontsize=18\n    shape=circle\n    style=filled\n    width=0.5\n  ]\n  A -- B\n  A -- C\n  B -- D\n  B -- E\n}\n"},{"type":"paragraph","children":[{"type":"text","value":"不难发现，如果要选取树上的某个节点，则其所有祖先节点都需要选取，但如果我们选取了两个节点，其公共祖先只要选取一次就可以了。反过来思考，如果我们决定要选取某个节点，则其所有的子节点都可选或可不选，此时考虑子节点的选取情况是一个\n"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"。类似地，递归地考虑决定选取某个子节点时其子节点列表的选取情况。于是问题变成了逐层跑"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包"}]},{"type":"text","value":"进行状态转移的树形DP。"}]},{"type":"paragraph","children":[{"type":"text","value":"不妨记 "},{"type":"inlineMath","value":"f(i,v)"},{"type":"text","value":" 表示选择了节点 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 及其若干子孙节点（所有选择的子孙节点都满足在以 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 为根节点的子树中的依赖关系）且消耗 "},{"type":"inlineMath","value":"v"},{"type":"text","value":" 容量时可以获得到的最大价值"},{"type":"footnoteReference","identifier":"7","label":"7"},{"type":"text","value":"，则初始状态为"},{"type":"footnoteReference","identifier":"8","label":"8"},{"type":"text","value":"："}]},{"type":"math","value":"  f(i,c) = \\left\\lbrace\\begin{aligned}\n    &w_i, &c = v_i\\\\\n    &0, &c \\neq v_i\\\\\n  \\end{aligned}\\right.\n"},{"type":"paragraph","children":[{"type":"text","value":"转移方程为："}]},{"type":"math","value":"  f(i,c) = \\max \\Big\\lbrace f(i, c-k) + f(s, k) \\;\\Big|\\; s \\in \\text{children of}\\; i, 0 \\leqslant k \\leqslant c \\Big\\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"之后沿着树递归进行状态转移就好了。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"较一般的问题"}],"identifier":"heading-较一般的问题"},{"type":"paragraph","children":[{"type":"text","value":"依然假设依赖关系中不存在环，则所有节点根据依赖关系连边构成的图是一个“森林”，问题变成了以“树”为分组的"},{"type":"linkReference","identifier":"solution-分组背包","label":"solution-分组背包","referenceType":"full","children":[{"type":"text","value":"分组背包"}]},{"type":"text","value":"问题。而“森林”中的每棵树都可以应用"},{"type":"linkReference","identifier":"有依赖的背包-简化版的问题","label":"有依赖的背包-简化版的问题","referenceType":"full","children":[{"type":"text","value":"简化版的问题"}]},{"type":"text","value":"中提到的算法来求解。"}]},{"type":"paragraph","children":[{"type":"text","value":"因为分组背包的时间也复杂度为 "},{"type":"inlineMath","value":"O(N \\times C)"},{"type":"text","value":"，所以最后合并森林时的复杂度和合并树中子节点的复杂度相同，故总时间复杂度仍为 "},{"type":"inlineMath","value":"O(N \\times C^2)"},{"type":"text","value":"."}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"小结"}],"identifier":"heading-小结-7"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"简化版的问题"}]},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"\\displaystyle O\\left(N \\times C \\right)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"\\displaystyle O\\left(N \\times C^2 \\right)"}]},{"type":"code","lang":"cpp","meta":"{10,13,15,31} title=\"有依赖的背包问题.cpp\" sourcefile=\"./有依赖的背包问题-01.cpp\" sourceline=\"6-46\" collapsed linenos","value":"const int MAX_N = 100 + 10;\nconst int MAX_C = 1000 + 10;\nint N, C, f[MAX_N][MAX_C], V[MAX_N];\nstd::vector<int> G[MAX_N];\n\nvoid dfs(int u) {\n  int* h = f[u];\n  for (int v : G[u]) {\n    // 计算子节点的泛化背包值\n    dfs(v);\n\n    int* g = f[v];\n    for (int c = C; c >= V[u]; --c) {\n      int& ans = h[c];\n      for (int k = c - V[u]; k >= 0; --k) {\n        ans = std::max(ans, h[c - k] + g[k]);\n      }\n    }\n  }\n}\n\nint solution() {\n  int root = -1;\n\n  scanf(\"%d%d\", &N, &C);\n  for (int i = 0, v, w, p; i < N; ++i) {\n    scanf(\"%d%d%d\", &v, &w, &p);\n\n    V[i] = v;\n    memset(f[i], 0, sizeof(int) * (C + 1));\n    if (v <= C) f[i][v] = w;\n\n    if (p == -1)\n      root = i;\n    else\n      G[p - 1].push_back(i);\n  }\n  dfs(root);\n\n  return f[root][C];\n}"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"较一般的问题"}]},{"type":"paragraph","children":[{"type":"text","value":"空间复杂度： "},{"type":"inlineMath","value":"\\displaystyle O\\left(N \\times C \\right)"},{"type":"break"},{"type":"text","value":"\n时间复杂度： "},{"type":"inlineMath","value":"\\displaystyle O\\left(N \\times C^2 \\right)"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"泛化物品"}],"identifier":"heading-泛化物品"},{"type":"heading","depth":3,"children":[{"type":"text","value":"定义"}],"identifier":"heading-定义"},{"type":"paragraph","children":[{"type":"text","value":"泛化物品指的是某类虚拟的物品，它的价值随着被分配给它的费用而变化，本质上是对于一类特殊数列或函数的概括和解释，引入它的本质是为了描述在求解背包问题是得到的中间数列，如在"},{"type":"linkReference","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","referenceType":"full","children":[{"type":"text","value":"有依赖的背包"}]},{"type":"text","value":"中所所提到的，通过计算子节点而合成的描述父节点关于容量和费用的一个数列。比如，一件费用为 "},{"type":"inlineMath","value":"v"},{"type":"text","value":" 价值为 "},{"type":"inlineMath","value":"w"},{"type":"text","value":" 的物品："}]},{"type":"blockquote","children":[{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"如果它是"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"中的物品，那么用于描述它的费用函数为："}]},{"type":"math","value":"  h(c) = \\left\\lbrace \\begin{aligned}\n  &w, &c=v\\\\\n  &0, &c \\neq v\\\\\n  \\end{aligned}\\right.\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"如果它是"},{"type":"linkReference","identifier":"solution-完全背包","label":"solution-完全背包","referenceType":"full","children":[{"type":"text","value":"完全背包"}]},{"type":"text","value":"中的物品，那么用于描述它的费用函数为："}]},{"type":"math","value":"  h(c) = \\left\\lbrace \\begin{aligned}\n  &\\frac{c}{v} \\cdot w, &v \\mid c\\\\\n  &0, &v \\nmid c\\\\\n  \\end{aligned}\\right.\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"如果它是"},{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包"}]},{"type":"text","value":"中的物品，不妨记它有 "},{"type":"inlineMath","value":"s"},{"type":"text","value":" 件，那么用于描述它的费用函数为："}]},{"type":"math","value":"  h(c) = \\left\\lbrace \\begin{aligned}\n  &\\frac{c}{v} \\cdot w, &v \\mid c \\quad\\text{and}\\quad \\frac{c}{v} \\leqslant s\\\\\n  &0, &v \\nmid c \\quad\\text{or}\\quad \\frac{c}{v} > s\\\\\n  \\end{aligned}\\right.\n"}]}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"泛化物品的和"}],"identifier":"heading-泛化物品的和"},{"type":"paragraph","children":[{"type":"text","value":"对于给定的费用 "},{"type":"inlineMath","value":"C"},{"type":"text","value":"，如何求从两个泛化物品中进行选取可以获得的最大价值呢？"},{"type":"footnoteReference","identifier":"9","label":"9"}]},{"type":"paragraph","children":[{"type":"text","value":"其实只需要枚举分配给其中一件物品的费用额度，将剩余的费用额度分配给另一件物品，对它们在给定额度下能获得的最大值求和，则答案是所有枚举情况下能获得价值的最大值。不妨记两件物品的费用函数为 "},{"type":"inlineMath","value":"h_1"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"h_2"},{"type":"text","value":"，则："}]},{"type":"math","value":"f(C)=\\max \\lbrace h_1(c) + h_2(C-c) \\;|\\; 0 \\leqslant c \\leqslant C \\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"得到的仍然是一个泛化物品的费用函数，即泛化物品的和仍为一个泛化物品，这或许可以更直观地解释"},{"type":"linkReference","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","referenceType":"full","children":[{"type":"text","value":"有依赖的背包"}]},{"type":"text","value":"中合并相邻兄弟节点或两棵树的含义。"}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"背包问题变种"}],"identifier":"heading-背包问题变种"},{"type":"heading","depth":3,"children":[{"type":"text","value":"打印方案"}],"identifier":"heading-打印方案"},{"type":"paragraph","children":[{"type":"text","value":"以总体积不超过背包容量的"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"为例。先考虑第 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 个物品是否"},{"type":"strong","children":[{"type":"text","value":"能够"}]},{"type":"text","value":"出现在答案中，若是，则必然有 "},{"type":"inlineMath","value":"f(N,C) = f(N-1, C-v_i) + w_i"},{"type":"text","value":"，则问题变成了打印前 "},{"type":"inlineMath","value":"N-1"},{"type":"text","value":" 个物品中放入容量为 "},{"type":"inlineMath","value":"C-v_i"},{"type":"text","value":" 的背包中的方案问题了。"}]},{"type":"paragraph","children":[{"type":"text","value":"几个细节："}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"在检查是否可以选取物品 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 时需要判断背包剩余容量是否能装下它；"}]},{"type":"listItem","children":[{"type":"text","value":"因为检查时都是通过 "},{"type":"inlineMath","value":"f(i-1)"},{"type":"text","value":" 进行判断的，因此对 "},{"type":"inlineMath","value":"i=0"},{"type":"text","value":" 要做特判；"}]}]},{"type":"code","lang":"cpp","meta":"{13,14,28,34} title=\"01背包-方案打印.cpp\" sourcefile=\"./01背包-方案打印.cpp\" sourceline=\"6-40\" collapsed linenos","value":"const int MAX_C = 1000 + 10;\nconst int MAX_N = 1000 + 10;\nint F[MAX_N][MAX_C], V[MAX_N], W[MAX_N];\nstd::vector<int> ans;\n\nvoid solution(int N, int C) {\n  ans.clear();\n  if (N <= 0) return;\n\n  for (int i = 0; i < N; ++i) scanf(\"%d%d\", V + i, W + i);\n\n  // Initialize.\n  memset(F[0], 0, std::min(C + 1, V[0]) * sizeof(int));\n  for (int c = V[0], w = W[0]; c <= C; ++c) F[0][c] = w;\n\n  for (int i = 1; i < N; ++i) {\n    const int v = V[i];\n    const int w = W[i];\n\n    memcpy(F[i], F[i - 1], std::min(C + 1, v) * sizeof(int));\n    for (int c = v; c <= C; ++c) {\n      F[i][c] = std::max(F[i - 1][c], F[i - 1][c - v] + w);\n    }\n  }\n\n  int c = C;\n  for (int i = N - 1, w = F[i][C]; i > 0; --i) {\n    if (c >= V[i] && F[i - 1][c - V[i]] + W[i] == w) {\n      ans.push_back(i + 1);\n      c -= V[i];\n      w -= W[i];\n    }\n  }\n  if (c >= V[0]) ans.push_back(1);\n}"},{"type":"heading","depth":3,"children":[{"type":"text","value":"最小字典序方案"}],"identifier":"heading-最小字典序方案"},{"type":"paragraph","children":[{"type":"text","value":"此处的“最小字典序”指的是可行方案中的物品编号排成的序列的字典序最小。"}]},{"type":"paragraph","children":[{"type":"text","value":"仍以总体积不超过背包容量的"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"为例，在前面的分析中，我们其实得到了“最大字典序”方案，因为每次都是优先考虑编号大的物品，所以即便存在多个方案，我们也是优先取的大编号物品，因而得到的字典序是最大的。"}]},{"type":"paragraph","children":[{"type":"text","value":"不难想到，只要将原数组"},{"type":"emphasis","children":[{"type":"text","value":"reverse"}]},{"type":"text","value":"一下再跑前文所述的打印方案的算法，则得到的就是“最小字典序方案”了。"}]},{"type":"code","lang":"cpp","meta":"{10,13,14,28,34} title=\"01背包-最小字典序方案.cpp\" sourcefile=\"./01背包-最小字典序方案.cpp\" sourceline=\"6-40\" collapsed linenos","value":"const int MAX_C = 1000 + 10;\nconst int MAX_N = 1000 + 10;\nint F[MAX_N][MAX_C], V[MAX_N], W[MAX_N];\nstd::vector<int> ans;\n\nvoid solution(int N, int C) {\n  ans.clear();\n  if (N <= 0) return;\n\n  for (int i = N - 1; i >= 0; --i) scanf(\"%d%d\", V + i, W + i);\n\n  // Initialize.\n  memset(F[0], 0, std::min(C + 1, V[0]) * sizeof(int));\n  for (int c = V[0], w = W[0]; c <= C; ++c) F[0][c] = w;\n\n  for (int i = 1; i < N; ++i) {\n    const int v = V[i];\n    const int w = W[i];\n\n    memcpy(F[i], F[i - 1], std::min(C + 1, v) * sizeof(int));\n    for (int c = v; c <= C; ++c) {\n      F[i][c] = std::max(F[i - 1][c], F[i - 1][c - v] + w);\n    }\n  }\n\n  int c = C;\n  for (int i = N - 1, w = F[i][C]; i > 0; --i) {\n    if (c >= V[i] && F[i - 1][c - V[i]] + W[i] == w) {\n      ans.push_back(N - i);\n      c -= V[i];\n      w -= W[i];\n    }\n  }\n  if (c >= V[0]) ans.push_back(N);\n}"},{"type":"heading","depth":3,"children":[{"type":"text","value":"方案总数"}],"identifier":"heading-方案总数"},{"type":"paragraph","children":[{"type":"text","value":"仍以总体积不超过背包容量的"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"为例，记 "},{"type":"inlineMath","value":"f(i,c)"},{"type":"text","value":" 表示当背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 时，在前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品中做选择的方案总数；因为是否选取第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品和前 "},{"type":"inlineMath","value":"i-1"},{"type":"text","value":" 个物品无关，所以简单枚举第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品的选取情况，然后进行求和即可。不难得到转移方程："}]},{"type":"math","value":"f(i,c) = f(i-1,c) + f(i-1,c-v)\n"},{"type":"paragraph","children":[{"type":"text","value":"几个细节："}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"初始化：可能最优方案中一个物品也装不下，所以初始化时要将所有的 "},{"type":"inlineMath","value":"f(0, c)"},{"type":"text","value":" 设置为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":"，因为什么都不装也是一个方案；"}]},{"type":"listItem","children":[{"type":"text","value":"仍可以利用"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"中提到的滚动数组来优化空间，方法类似；"}]}]},{"type":"code","lang":"cpp","meta":"{6,10-12} title=\"01背包-方案总数.cpp\" sourcefile=\"./01背包-方案总数.cpp\" sourceline=\"5-19\" collapsed linenos","value":"const int MAX_C = 20000 + 10;\nint F[MAX_C];\n\nint solution(int N, int C) {\n  // Initialize.\n  for (int c = 0; c <= C; ++c) F[c] = 1;\n\n  for (int i = 0, V; i < N; ++i) {\n    scanf(\"%d\", &V);\n    for (int c = C; c >= V; --c) {\n      F[c] = F[c] + F[c - V];\n    }\n  }\n  return F[C];\n}"},{"type":"heading","depth":3,"children":[{"type":"text","value":"最优方案的总数"}],"identifier":"heading-最优方案的总数"},{"type":"paragraph","children":[{"type":"text","value":"此处的“最优方案”指物品总体积不超过背包容量且总价值最大的方案。"}]},{"type":"paragraph","children":[{"type":"text","value":"仍以总体积不超过背包容量的"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"为例，记"}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineMath","value":"f(i,c)"},{"type":"text","value":" 表示当背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 时，在前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品中做选择时可以获得的最大价值；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"g(i,c)"},{"type":"text","value":" 表示当背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 时，从前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品中进行选择可以获得最大价值的方案数；"}]}]},{"type":"paragraph","children":[{"type":"text","value":"则在转移 "},{"type":"inlineMath","value":"f"},{"type":"text","value":" 时，顺便统计 "},{"type":"inlineMath","value":"g"},{"type":"text","value":" 就可以了："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"若 "},{"type":"inlineMath","value":"f(i-1, c) < f(i-1, c-V_i) + W_i"},{"type":"text","value":"，说明找到了一个新方案，其在容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 的背包中能获得的价值比之前所有的方案都要大，因此新的方案数为 "},{"type":"inlineMath","value":"g(i-1, c-V_i)"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"text","value":"若 "},{"type":"inlineMath","value":"f(i-1, c) = f(i-1, c-V_i) + W_i"},{"type":"text","value":"，说明找到了一个新方案，其在容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 的背包中能获得的价值和之前的方案一样大，因此新的方案数为 "},{"type":"inlineMath","value":"g(i-1, c) + g(i-1, c-V_i)"}]},{"type":"listItem","children":[{"type":"text","value":"若 "},{"type":"inlineMath","value":"f(i-1, c) > f(i-1, c-V_i)"},{"type":"text","value":"，说明未找到新方案，所以方案数仍为 "},{"type":"inlineMath","value":"g(i-1,c)"}]}]},{"type":"paragraph","children":[{"type":"text","value":"几个细节："}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"初始化：可能最优方案中一个物品也装不下，所以初始化时要将所有的 "},{"type":"inlineMath","value":"g(0, c)"},{"type":"text","value":" 设置为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":"，因为什么都不装也是一个方案；"}]},{"type":"listItem","children":[{"type":"text","value":"仍可以利用"},{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]},{"type":"text","value":"中提到的滚动数组来优化空间，只不过在转移 "},{"type":"inlineMath","value":"f"},{"type":"text","value":" 的状态前，要先做记录，因为需要比较 "},{"type":"inlineMath","value":"f(i-1, c)"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"f(i-1, c-V_i) + W_i"},{"type":"text","value":"\n的值；"}]}]},{"type":"code","lang":"cpp","meta":"{9,14,16-21} title=\"01背包-最优方案数.cpp\" sourcefile=\"./01背包-最优方案数.cpp\" sourceline=\"3-27\" collapsed linenos","value":"const int MAX_C = 20000 + 10;\nconst int MOD = 1e9 + 7;\nint F[MAX_C], G[MAX_C];\n\nint solution(int N, int C) {\n  // Initialize.\n  for (int c = 0; c <= C; ++c) {\n    F[c] = 0;\n    G[c] = 1;\n  }\n\n  for (int i = 0, V, W; i < N; ++i) {\n    scanf(\"%d%d\", &V, &W);\n    for (int c = C; c >= V; --c) {\n      int total = F[c - V] + W;\n      if (F[c] < total) {\n        F[c] = total;\n        G[c] = G[c - V];\n      } else if (F[c] == total) {\n        G[c] = (G[c] + G[c - V]) % MOD;\n      }\n    }\n  }\n  return G[C];\n}"},{"type":"heading","depth":3,"children":[{"type":"text","value":"求第 "},{"type":"inlineMath","value":"K"},{"type":"text","value":" 优解"}],"identifier":"heading-求第-k-优解"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","status":"todo","children":[{"type":"text","value":"待补充。"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"题目练习"}]},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Problem"}]},{"type":"tableCell","children":[{"type":"text","value":"Category"}]},{"type":"tableCell","children":[{"type":"text","value":"Solution"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-01背包","label":"problem-01背包","referenceType":"full","children":[{"type":"text","value":"01背包问题"}]}]},{"type":"tableCell","children":[{"type":"text","value":"01背包"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-01背包","label":"solution-01背包","referenceType":"full","children":[{"type":"text","value":"01背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-01背包","label":"problem-01背包","referenceType":"full","children":[{"type":"text","value":"完全背包问题"}]}]},{"type":"tableCell","children":[{"type":"text","value":"完全背包"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-完全背包","label":"solution-完全背包","referenceType":"full","children":[{"type":"text","value":"完全背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-多重背包-2","label":"problem-多重背包-2","referenceType":"full","children":[{"type":"text","value":"多重背包问题 II"}]}]},{"type":"tableCell","children":[{"type":"text","value":"多重背包二进制优化"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-多重背包-3","label":"problem-多重背包-3","referenceType":"full","children":[{"type":"text","value":"多重背包问题 III"}]}]},{"type":"tableCell","children":[{"type":"text","value":"多重背包单调栈优化"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-多重背包","label":"solution-多重背包","referenceType":"full","children":[{"type":"text","value":"多重背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-混合背包","label":"problem-混合背包","referenceType":"full","children":[{"type":"text","value":"混合背包"}]}]},{"type":"tableCell","children":[{"type":"text","value":"混合背包"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-混合背包","label":"solution-混合背包","referenceType":"full","children":[{"type":"text","value":"混合背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-二维费用的背包","label":"problem-二维费用的背包","referenceType":"full","children":[{"type":"text","value":"二维费用的背包"}]}]},{"type":"tableCell","children":[{"type":"text","value":"二维费用的背包"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-二维费用的背包","label":"solution-二维费用的背包","referenceType":"full","children":[{"type":"text","value":"二维费用的背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-分组背包","label":"problem-分组背包","referenceType":"full","children":[{"type":"text","value":"分组背包"}]}]},{"type":"tableCell","children":[{"type":"text","value":"分组背包"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-分组背包","label":"solution-分组背包","referenceType":"full","children":[{"type":"text","value":"分组背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-有依赖的背包","label":"problem-有依赖的背包","referenceType":"full","children":[{"type":"text","value":"有依赖的背包"}]}]},{"type":"tableCell","children":[{"type":"text","value":"有依赖的背包"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","referenceType":"full","children":[{"type":"text","value":"有依赖的背包"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-背包方案数","label":"problem-背包方案数","referenceType":"full","children":[{"type":"text","value":"背包问题求方案数"}]}]},{"type":"tableCell","children":[{"type":"text","value":"最优解方案数"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-最优解方案数","label":"solution-最优解方案数","referenceType":"full","children":[{"type":"text","value":"最优方案的总数"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-最小字典序方案","label":"problem-最小字典序方案","referenceType":"full","children":[{"type":"text","value":"背包问题求具体方案"}]}]},{"type":"tableCell","children":[{"type":"text","value":"背包问题打印方案"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-最小字典序方案","label":"solution-最小字典序方案","referenceType":"full","children":[{"type":"text","value":"最小字典序方案"}]}]}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"背包九讲.pdf","label":"背包九讲.pdf","referenceType":"full","children":[{"type":"text","value":"背包问题九讲 -- 崔添翼"}]}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-01背包","contents":[{"type":"text","value":"01背包"}],"children":[{"depth":3,"identifier":"heading-问题简析","contents":[{"type":"text","value":"问题简析"}],"children":[]},{"depth":3,"identifier":"heading-算法优化","contents":[{"type":"text","value":"算法优化"}],"children":[]},{"depth":3,"identifier":"heading-初始化细节","contents":[{"type":"text","value":"初始化细节"}],"children":[]},{"depth":3,"identifier":"heading-小结","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-完全背包","contents":[{"type":"text","value":"完全背包"}],"children":[{"depth":3,"identifier":"heading-问题简析-2","contents":[{"type":"text","value":"问题简析"}],"children":[]},{"depth":3,"identifier":"heading-算法优化-2","contents":[{"type":"text","value":"算法优化"}],"children":[]},{"depth":3,"identifier":"heading-小结-2","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-多重背包","contents":[{"type":"text","value":"多重背包"}],"children":[{"depth":3,"identifier":"heading-问题简析-3","contents":[{"type":"text","value":"问题简析"}],"children":[]},{"depth":3,"identifier":"heading-算法优化-3","contents":[{"type":"text","value":"算法优化"}],"children":[]},{"depth":3,"identifier":"heading-小结-3","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-混合背包","contents":[{"type":"text","value":"混合背包"}],"children":[{"depth":3,"identifier":"heading-问题简析-4","contents":[{"type":"text","value":"问题简析"}],"children":[]},{"depth":3,"identifier":"heading-小结-4","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-二维费用的背包","contents":[{"type":"text","value":"二维费用的背包"}],"children":[{"depth":3,"identifier":"heading-问题简析-5","contents":[{"type":"text","value":"问题简析"}],"children":[]},{"depth":3,"identifier":"heading-算法优化-4","contents":[{"type":"text","value":"算法优化"}],"children":[]},{"depth":3,"identifier":"heading-小结-5","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-分组背包","contents":[{"type":"text","value":"分组背包"}],"children":[{"depth":3,"identifier":"heading-问题简析-6","contents":[{"type":"text","value":"问题简析"}],"children":[]},{"depth":3,"identifier":"heading-小结-6","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-有依赖的背包","contents":[{"type":"text","value":"有依赖的背包"}],"children":[{"depth":3,"identifier":"heading-简化版的问题","contents":[{"type":"text","value":"简化版的问题"}],"children":[]},{"depth":3,"identifier":"heading-较一般的问题","contents":[{"type":"text","value":"较一般的问题"}],"children":[]},{"depth":3,"identifier":"heading-小结-7","contents":[{"type":"text","value":"小结"}],"children":[]}]},{"depth":2,"identifier":"heading-泛化物品","contents":[{"type":"text","value":"泛化物品"}],"children":[{"depth":3,"identifier":"heading-定义","contents":[{"type":"text","value":"定义"}],"children":[]},{"depth":3,"identifier":"heading-泛化物品的和","contents":[{"type":"text","value":"泛化物品的和"}],"children":[]}]},{"depth":2,"identifier":"heading-背包问题变种","contents":[{"type":"text","value":"背包问题变种"}],"children":[{"depth":3,"identifier":"heading-打印方案","contents":[{"type":"text","value":"打印方案"}],"children":[]},{"depth":3,"identifier":"heading-最小字典序方案","contents":[{"type":"text","value":"最小字典序方案"}],"children":[]},{"depth":3,"identifier":"heading-方案总数","contents":[{"type":"text","value":"方案总数"}],"children":[]},{"depth":3,"identifier":"heading-最优方案的总数","contents":[{"type":"text","value":"最优方案的总数"}],"children":[]},{"depth":3,"identifier":"heading-求第-k-优解","contents":[{"type":"text","value":"求第 "},{"type":"inlineMath","value":"K"},{"type":"text","value":" 优解"}],"children":[]}]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"背包九讲.pdf":{"type":"definition","identifier":"背包九讲.pdf","label":"背包九讲.pdf","url":"/asset/post/file/493cb4c7-0617-55b1-ac05-ac80664c39aa.pdf"},"01背包-算法优化":{"type":"definition","identifier":"01背包-算法优化","label":"01背包-算法优化","url":"#heading-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"},"problem-01背包":{"type":"definition","identifier":"problem-01背包","label":"problem-01背包","url":"https://www.acwing.com/problem/content/2/"},"problem-完全背包":{"type":"definition","identifier":"problem-完全背包","label":"problem-完全背包","url":"https://www.acwing.com/problem/content/3/"},"problem-多重背包-2":{"type":"definition","identifier":"problem-多重背包-2","label":"problem-多重背包-2","url":"https://www.acwing.com/problem/content/5/"},"problem-多重背包-3":{"type":"definition","identifier":"problem-多重背包-3","label":"problem-多重背包-3","url":"https://www.acwing.com/problem/content/6/"},"problem-混合背包":{"type":"definition","identifier":"problem-混合背包","label":"problem-混合背包","url":"https://www.acwing.com/problem/content/7/"},"problem-二维费用的背包":{"type":"definition","identifier":"problem-二维费用的背包","label":"problem-二维费用的背包","url":"https://www.acwing.com/problem/content/8/"},"problem-分组背包":{"type":"definition","identifier":"problem-分组背包","label":"problem-分组背包","url":"https://www.acwing.com/problem/content/9/"},"problem-有依赖的背包":{"type":"definition","identifier":"problem-有依赖的背包","label":"problem-有依赖的背包","url":"https://www.acwing.com/problem/content/10/"},"problem-背包方案数":{"type":"definition","identifier":"problem-背包方案数","label":"problem-背包方案数","url":"https://www.acwing.com/problem/content/11/"},"problem-最小字典序方案":{"type":"definition","identifier":"problem-最小字典序方案","label":"problem-最小字典序方案","url":"https://www.acwing.com/problem/content/12/"},"solution-01背包":{"type":"definition","identifier":"solution-01背包","label":"solution-01背包","url":"#heading-01-%E8%83%8C%E5%8C%85"},"solution-完全背包":{"type":"definition","identifier":"solution-完全背包","label":"solution-完全背包","url":"#heading-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"},"solution-多重背包":{"type":"definition","identifier":"solution-多重背包","label":"solution-多重背包","url":"#heading-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"},"solution-混合背包":{"type":"definition","identifier":"solution-混合背包","label":"solution-混合背包","url":"#heading-%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85"},"solution-二维费用的背包":{"type":"definition","identifier":"solution-二维费用的背包","label":"solution-二维费用的背包","url":"#heading-%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E7%9A%84%E8%83%8C%E5%8C%85"},"solution-分组背包":{"type":"definition","identifier":"solution-分组背包","label":"solution-分组背包","url":"#heading-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"},"solution-有依赖的背包":{"type":"definition","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","url":"#heading-%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85"},"solution-最优解方案数":{"type":"definition","identifier":"solution-最优解方案数","label":"solution-最优解方案数","url":"#heading-%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E7%9A%84%E6%80%BB%E6%95%B0"},"solution-最小字典序方案":{"type":"definition","identifier":"solution-最小字典序方案","label":"solution-最小字典序方案","url":"#heading-%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E6%96%B9%E6%A1%88"},"有依赖的背包-简化版的问题":{"type":"definition","identifier":"有依赖的背包-简化版的问题","label":"有依赖的背包-简化版的问题","url":"#heading-%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84%E9%97%AE%E9%A2%98"}},"footnoteDefinitionMap":{"1":{"type":"footnoteDefinition","identifier":"1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"假设物品消耗的背包容量恰好等于其体积。"}]}]},"2":{"type":"footnoteDefinition","identifier":"2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"这里的影响指的是依赖耦合，如要求“放入第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品时必须也放入第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 件物品；若只是放入第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品导致背包容量不足以放入第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 件物品，这种情况可规约为背包剩余容量是否足以放入第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 件物品，而和前 "},{"type":"inlineMath","value":"j-1"},{"type":"text","value":" 件物品中是否放入了第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品无关。"}]}]},"3":{"type":"footnoteDefinition","identifier":"3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"对于“不放入”的决策，"},{"type":"inlineMath","value":"f(i,x)=f(i-1,x)"}]}]},"4":{"type":"footnoteDefinition","identifier":"4","label":"4","children":[{"type":"paragraph","children":[{"type":"text","value":"将它们分别捆绑到一起，比如 "},{"type":"inlineMath","value":"2^k"},{"type":"text","value":" 个可以视作一个体积为 "},{"type":"inlineMath","value":"2^k \\cdot v_i"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"2^k \\cdot w_i"},{"type":"text","value":" 的物品"}]}]},"5":{"type":"footnoteDefinition","identifier":"5","label":"5","children":[{"type":"paragraph","children":[{"type":"text","value":"因为 "},{"type":"inlineMath","value":"\\left\\lbrace 2^0, 2^1, 2^2, \\cdots, ... 2^{k-1}\\right\\rbrace"},{"type":"text","value":" 可以表示 "},{"type":"inlineMath","value":"0 \\sim 2^k-1"},{"type":"text","value":" 之间的任意整数。"}]}]},"6":{"type":"footnoteDefinition","identifier":"6","label":"6","children":[{"type":"paragraph","children":[{"type":"text","value":"在更新时不记录状态，即仅用 "},{"type":"inlineMath","value":"f(i-1)"},{"type":"text","value":" 去更新 "},{"type":"inlineMath","value":"f(i)"},{"type":"text","value":"，则在第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 组物品中枚举时，所有的考虑都不具有后效性，即状态中不会出现“既选了第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 组物品中的第 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 件物品又选了第 "},{"type":"inlineMath","value":"y"},{"type":"text","value":" 件物品”这种情形。"}]}]},"7":{"type":"footnoteDefinition","identifier":"7","label":"7","children":[{"type":"paragraph","children":[{"type":"inlineMath","value":"f"},{"type":"text","value":" 的定义使用了泛化物品的思想，可参考下一节。"}]}]},"8":{"type":"footnoteDefinition","identifier":"8","label":"8","children":[{"type":"paragraph","children":[{"type":"text","value":"这里实际上应用了一个优化：如果花费 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 就可以获得第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品，则无需考虑任何需要大于 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 的花费才能获得第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品的情形。"}]}]},"9":{"type":"footnoteDefinition","identifier":"9","label":"9","children":[{"type":"paragraph","children":[{"type":"text","value":"这个问题等价于"},{"type":"linkReference","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","referenceType":"full","children":[{"type":"text","value":"有依赖的背包"}]},{"type":"text","value":"中合并两棵树或两个兄弟节点。"}]}]}},"images":[],"paginationUrl":"/posts/2","prev":{"title":"React Reconciliation","slug":"/post/web/react/reconciliation"},"next":{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number"},"aplayerOptions":null}}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"背包九讲 | guanghechen"}],["$","meta","3",{"name":"description","content":"背包九讲"}],["$","meta","4",{"name":"application-name","content":"guanghechen"}],["$","link","5",{"rel":"author","href":"https://github.com/guanghechen"}],["$","meta","6",{"name":"author","content":"光和尘"}],["$","link","7",{"rel":"icon","href":"/favicon.png"}],["$","meta","8",{"name":"next-size-adjust"}]]
1:null
