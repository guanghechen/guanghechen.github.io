<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta name="application-name" content="guanghechen"/><meta name="apple-mobile-web-app-title" content="光和尘"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="description" content="Guanghechen&#x27;s personal site"/><meta name="format-detection" content="telephone=no"/><meta name="mobile-web-app-capable" content="yes"/><meta name="msapplication-config" content="/icons/browserconfig.xml"/><meta name="msapplication-TileColor" content="#2B5797"/><meta name="msapplication-tap-highlight" content="no"/><meta name="theme-color" content="#a2466c"/><link rel="manifest" href="/manifest.json"/><link rel="shortcut icon" href="/favicon.png"/><meta property="og:type" content="website"/><meta property="og:title" content="光和尘"/><meta property="og:description" content="光和尘的个人站点"/><meta property="og:site_name" content="guanghechen"/><meta property="og:url" content="https://me.guanghechen.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Roboto+Mono&amp;display=swap"/><link rel="preload" href="/_next/static/css/f6e2a3135d0744b2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f6e2a3135d0744b2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2159a4b672631e08.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2159a4b672631e08.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-0e254df9656e737c.js" defer=""></script><script src="/_next/static/chunks/framework-18c7e6fcf99e5daa.js" defer=""></script><script src="/_next/static/chunks/main-bc7ec7a4afcf2c61.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2988051bc3250d53.js" defer=""></script><script src="/_next/static/chunks/554-f1e1595f15421db7.js" defer=""></script><script src="/_next/static/chunks/724-d8cff9a7734ecb4d.js" defer=""></script><script src="/_next/static/chunks/997-90aababb639034f3.js" defer=""></script><script src="/_next/static/chunks/865-908a279774f8f37a.js" defer=""></script><script src="/_next/static/chunks/910-a814f4d433bec130.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5B...slug%5D-5ff9d3eabaad16e1.js" defer=""></script><script src="/_next/static/OJnGaMf6Cc9xX4yB8MA4a/_buildManifest.js" defer=""></script><script src="/_next/static/OJnGaMf6Cc9xX4yB8MA4a/_ssgManifest.js" defer=""></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap"/></head><body><div id="__next"><div class="css-pwdx5x"><style data-emotion="css z01bqi animation-61bdi0">.css-z01bqi{display:inline-block;color:#1976d2;-webkit-animation:animation-61bdi0 1.4s linear infinite;animation:animation-61bdi0 1.4s linear infinite;}@-webkit-keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style><span class="MuiCircularProgress-root MuiCircularProgress-indeterminate MuiCircularProgress-colorPrimary css-z01bqi" style="width:40px;height:40px" role="progressbar"><style data-emotion="css 13o7eu2">.css-13o7eu2{display:block;}</style><svg class="MuiCircularProgress-svg css-13o7eu2" viewBox="22 22 44 44"><style data-emotion="css 14891ef animation-1p2h4ri">.css-14891ef{stroke:currentColor;stroke-dasharray:80px,200px;stroke-dashoffset:0;-webkit-animation:animation-1p2h4ri 1.4s ease-in-out infinite;animation:animation-1p2h4ri 1.4s ease-in-out infinite;}@-webkit-keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}@keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}</style><circle class="MuiCircularProgress-circle MuiCircularProgress-circleIndeterminate css-14891ef" cx="44" cy="44" r="20.2" fill="none" stroke-width="3.6"></circle></svg></span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"精确覆盖问题和 DLX 算法","description":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","createdAt":"Jul 24, 2021","updatedAt":"Jun 04, 2023","timeToRead":"09min 12s","tags":["算法","精确覆盖","DLX 算法"],"categories":[],"ast":{"type":"root","children":[{"type":"ecmaImport","moduleName":"@kyokuya/_demo/post/algorithm/dlx/sudoku-solver.tsx","namedImports":[{"src":"SudokuSolverComponent","alias":null}]},{"type":"ecmaImport","moduleName":"@kyokuya/_demo/util/sudoku.ts","namedImports":[{"src":"SudokuSolver","alias":null},{"src":"createSudokuBoardData","alias":null}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"前言"}],"identifier":"heading-前言"},{"type":"paragraph","children":[{"type":"text","value":"很早就想要补一下舞蹈链和精确覆盖算法，却一直各种拖延，趁着最近有空，又重新翻开了刘汝佳的书。大学的时候看过几次，甚至照着书里的思路手敲了一遍并通过了例题，但对于算法的原理一直有些不求甚解。很早以前，一位同学告诉我说“现在看不懂的东西不用勉强，以后慢慢就会懂了”，后来也真的在不断印证这句话；但我很担心随着年纪的增长，记忆力和学习能力不断退化之后，恐怕这个 flag 会逐渐倒下。所以趁着眼下尚能理解进去，尽量用自己的语言做一下记录。"}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"精确覆盖问题"}],"identifier":"heading-精确覆盖问题"},{"type":"paragraph","children":[{"type":"text","value":"有一些由整数 "},{"type":"inlineMath","value":"1 \\sim n"},{"type":"text","value":" 中的数字组成的集合 "},{"type":"inlineMath","value":"S_1, S_2, \\cdots, S_m"},{"type":"text","value":"，要求选择若干个集合 "},{"type":"inlineMath","value":"S_i"},{"type":"text","value":"，使得 "},{"type":"inlineMath","value":"1 \\sim n"},{"type":"text","value":" 中每个整数都在选出的集合中的某个出现且恰好仅出现一次。举个栗子："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"不妨假设 "},{"type":"inlineMath","value":"n=7, m=6"},{"type":"text","value":"，集合为："}]},{"type":"math","value":"\\begin{aligned}\n  S_1\u0026=\\lbrace 1, 4, 7 \\rbrace\\\\\n  S_2\u0026=\\lbrace 1, 4 \\rbrace\\\\\n  S_3\u0026=\\lbrace 4,5,7 \\rbrace\\\\\n  S_4\u0026=\\lbrace 3, 5, 6 \\rbrace\\\\\n  S_5\u0026=\\lbrace 2, 3, 6, 7 \\rbrace\\\\\n  S_6\u0026=\\lbrace 2, 7 \\rbrace\\\\\n\\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"则一个精确覆盖为 "},{"type":"inlineMath","value":"\\lbrace S_2, S_4, S_6 \\rbrace"},{"type":"text","value":"，因为 "},{"type":"inlineMath","value":"\\lbrace 1, 4 \\rbrace"},{"type":"text","value":",\n"},{"type":"inlineMath","value":"\\lbrace 3, 5, 6 \\rbrace"},{"type":"text","value":", "},{"type":"inlineMath","value":"\\lbrace 2, 7 \\rbrace"},{"type":"text","value":" 无重复、无遗漏地包含了 "},{"type":"inlineMath","value":"1 \\sim 7"},{"type":"text","value":"\n中的所有整数。"}]}]},{"type":"paragraph","children":[{"type":"text","value":"我们可以用一个 "},{"type":"inlineMath","value":"m \\times n"},{"type":"text","value":" 的 "},{"type":"inlineMath","value":"01"},{"type":"text","value":" 矩阵来表示集合，其中，"},{"type":"inlineMath","value":"0"},{"type":"text","value":" 表示不包含，"},{"type":"inlineMath","value":"1"},{"type":"text","value":" 表示包含。比如第 "},{"type":"inlineMath","value":"(i, j)"},{"type":"text","value":" 个位置若为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":"，则说明 "},{"type":"inlineMath","value":"S_i"},{"type":"text","value":" 中不包含 "},{"type":"inlineMath","value":"j"},{"type":"text","value":"。上文中的栗子用矩阵表示如下所示："}]},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":" "}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"7"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"则精确覆盖问题可重新表述为：在一个 "},{"type":"inlineMath","value":"m \\times n"},{"type":"text","value":" 的 "},{"type":"inlineMath","value":"01"},{"type":"text","value":" 矩阵中，选择若干行，对这些行做向量加法，得到的结果为 "},{"type":"inlineMath","value":"(1, 1, \\cdots, 1)"},{"type":"text","value":"。即："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"选出的行里，不存在某列同时在两行中值均为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"text","value":"所有选出的行叠加在一起的结果覆盖所有列（每一列的值都不为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":"）。"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"算法 X"}],"identifier":"heading-算法-x"},{"type":"paragraph","children":[{"type":"text","value":"算法 X（Algorithm X），其实就是回溯，可能是专门针对覆盖问题提出的算法吧。算法描述如下："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"每次选择一个没有被删除列，然后枚举该列为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的所有行，尝试删除这些行，递归搜索后再恢复这些行。尝试删除行时，还要将该行中所有值为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的列也一并删除"},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，恢复时也同样。"}]},{"type":"paragraph","children":[{"type":"text","value":"若没有可以选择的列了（即所有列都被删除了），说明已经找到一个精确覆盖的解了"},{"type":"footnoteReference","identifier":"2","label":"2"},{"type":"text","value":"；若还有列但是没有行了"},{"type":"footnoteReference","identifier":"3","label":"3"},{"type":"text","value":"说明原问题无解。"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"舞蹈链"}],"identifier":"heading-舞蹈链"},{"type":"paragraph","children":[{"type":"text","value":"舞蹈链（Dancing Link），一种支持快速删除、恢复列和行的数据结构。"}]},{"type":"paragraph","children":[{"type":"text","value":"舞蹈链是一个十字型双向链表结构，链表中的每个节点对应上述 "},{"type":"inlineMath","value":"01"},{"type":"text","value":" 矩阵中的一个 "},{"type":"inlineMath","value":"1"},{"type":"text","value":"。另外还有 "},{"type":"inlineMath","value":"n+1"},{"type":"text","value":" 个虚拟节点，其中每列最上方一个虚拟节点作为该列链表的头指针，而所有虚拟节点的最前方有一个虚拟节点，作为虚拟节点的头指针，它也是舞蹈链的头指针。如下图所示（图片来源于网络）："}]},{"type":"paragraph","children":[{"type":"imageReference","identifier":"dancing-link.png","label":"dancing-link.png","referenceType":"collapsed","alt":"dancing-link.png"}]},{"type":"paragraph","children":[{"type":"text","value":"使用四个数组 "},{"type":"inlineMath","value":"L"},{"type":"text","value":", "},{"type":"inlineMath","value":"R"},{"type":"text","value":", "},{"type":"inlineMath","value":"U"},{"type":"text","value":", "},{"type":"inlineMath","value":"D"},{"type":"text","value":" 分别表示舞蹈链中节点的左、右、上、下四个方向的指针，下标为节点的编号；同时列编号作为该列的虚拟节点，"},{"type":"inlineMath","value":"0"},{"type":"text","value":" 表示舞蹈链的头指针对应的虚拟节点。"}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"删除行：只需要修改将该行中所有节点的上下行的下、上指针互指就好了。"}]},{"type":"code","lang":"typescript","meta":"title=\"dancing-link.01.ts\" linenos","value":"// 设要删除的某行中某个节点编号为 R[i]\nfor (let j = R[i]; j !== i; j = R[j]) {\n  U[D[j]] = U[j]\n  D[U[j]] = D[j]\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"恢复行：只需要将该行中所有节点的上下行的下、上指针分别指向该该节点就好了。"}]},{"type":"code","lang":"typescript","meta":"title=\"dancing-link.01.ts\" linenos","value":"// 设要删除的某行中某个节点编号为 R[i]\nfor (let j = R[i]; j !== i; j = R[j]) {\n  U[D[j]] = j\n  D[U[j]] = j\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"删除列和恢复列也类似，此处略去。"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"DLX 算法"}],"identifier":"heading-dlx-算法"},{"type":"paragraph","children":[{"type":"text","value":"使用了舞蹈链的算法 X 通常被称为 DLX 算法。此处给出 DLX 算法的 Typescript 实现"},{"type":"footnoteReference","identifier":"4","label":"4"},{"type":"text","value":"。"}]},{"type":"code","lang":"typescript","meta":"title=\"dlx.ts\" sourcefile=\"./dlx.ts\" maxlines=\"15\" collapsed linenos","value":"/**\n * The algorithm X that applied the dancing-link, it is also called as \"DLX\".\n * It is used to solve the exact-cover problem.\n *\n * Dancing-link: A cross doubly linked list, each column has a virtual node as\n * the head pointer, and at the top of all virtual nodes there is an additional\n * virtual node as the head pointer of the virtual node, which is also the head\n * pointer of the entire dancing-link. In the implementation of using an array\n * to simulate a linked list, the virtual node is represented by a column\n * number, and the head pointer of the dancing-link can be represented by 0.\n *\n * @see https://me.guanghechen.com/post/algorithm/dlx/\n */\nexport interface DLX {\n  /**\n   * Initialize the dancing-link.\n   * @param totalColumns   number of columns\n   */\n  init(totalColumns: number): void\n\n  /**\n   * Release memory variables.\n   */\n  destroy(): void\n\n  /**\n   * Add a row to the dancing-link.\n   *\n   * It should be noted that after solving the exact-cover problem, the\n   * result is a list of selected row numbers, so the row number should be\n   * specified as a value that can carry information.\n   *\n   * @param r         the row number\n   * @param columns   columns on the row\n   */\n  addRow(rowNo: number, columns: ReadonlyArray\u003cnumber\u003e): void\n\n  /**\n   * Try to find a precise coverage.\n   *\n   * When a solution is found, return the row numbers of all selected rows,\n   * otherwise return null.\n   */\n  solve(): number[] | null\n}\n\n/**\n * Generate an object that encapsulates the DLX algorithm.\n *\n * @param MAX_N   maximum number of nodes in the dancing-link\n * @returns\n */\nexport function createDLX(MAX_N: number): DLX {\n  // The number of nodes in the dancing-link (including the virtual nodes on\n  // the column).\n  let sz: number\n\n  // the number of columns in the dancing-link.\n  let totalColumns: number\n\n  const selectedRowNos: number[] = new Array(MAX_N) // list of row numbers of selected rows\n  let countOfSelectedRows: number // the number of selected rows\n\n  const count: number[] = new Array(MAX_N) // lhe number of nodes of a column in the dancing-link\n  const row: number[] = new Array(MAX_N) // the row number of a node in the dancing-link\n  const col: number[] = new Array(MAX_N) // the column number of a node in the dancing-link\n  const L: number[] = new Array(MAX_N) // left pointer of cross-link list\n  const R: number[] = new Array(MAX_N) // right pointer of cross-link list\n  const U: number[] = new Array(MAX_N) // up pointer of cross-link list\n  const D: number[] = new Array(MAX_N) // down pointer of cross-link list\n  return { init, destroy, addRow, solve }\n\n  /**\n   * @see DLX#init\n   * @public\n   */\n  function init(_totalColumns: number): void {\n    totalColumns = _totalColumns\n    sz = _totalColumns + 1\n\n    // Resize arrays.\n    if (selectedRowNos.length \u003c sz) {\n      selectedRowNos.length = sz\n      count.length = sz\n      row.length = sz\n      col.length = sz\n      L.length = sz\n      R.length = sz\n      U.length = sz\n      D.length = sz\n    }\n\n    for (let i = 0; i \u003c sz; ++i) {\n      L[i] = i - 1\n      R[i] = i + 1\n      U[i] = i\n      D[i] = i\n    }\n    R[_totalColumns] = 0\n    L[0] = _totalColumns\n\n    count.fill(0, 0, sz)\n  }\n\n  /**\n   * @see DLX#destroy\n   * @public\n   */\n  function destroy(): void {\n    selectedRowNos.length = 0\n    count.length = 0\n    row.length = 0\n    col.length = 0\n    L.length = 0\n    R.length = 0\n    U.length = 0\n    D.length = 0\n  }\n\n  /**\n   * @see DLX#addRow\n   * @public\n   */\n  function addRow(r: number, columns: ReadonlyArray\u003cnumber\u003e): void {\n    const first = sz\n    for (let i = 0; i \u003c columns.length; ++i, ++sz) {\n      const c = columns[i]\n      row[sz] = r\n      col[sz] = c\n      count[c] += 1\n\n      // Connect left and right nodes\n      L[sz] = sz - 1\n      R[sz] = sz + 1\n\n      // Connect top and bottom nodes,\n      // c is the virtual node on the c-th column, and is also the head pointer\n      // of the linked list of the column, so at this time U[c] is the last\n      // element of the column\n      D[sz] = c\n      D[U[c]] = sz\n      U[sz] = U[c]\n      U[c] = sz\n    }\n\n    // Since this is a circular linked list, the first and last columns of the\n    // current row are connected to each other.\n    R[sz - 1] = first\n    L[first] = sz - 1\n  }\n\n  /**\n   * @see DLX#solve\n   * @public\n   */\n  function solve(): number[] | null {\n    if (!algorithmX(0)) return null\n    return selectedRowNos.slice(0, countOfSelectedRows)\n  }\n\n  /**\n   * Remove a column from the dancing-link.\n   * @param c   column number\n   * @private\n   */\n  function removeColumn(c: number): void {\n    L[R[c]] = L[c]\n    R[L[c]] = R[c]\n    for (let i = D[c]; i !== c; i = D[i]) {\n      for (let j = R[i]; j !== i; j = R[j]) {\n        U[D[j]] = U[j]\n        D[U[j]] = D[j]\n        count[col[j]] -= 1\n      }\n    }\n  }\n\n  /**\n   * Restore a previously deleted column\n   * @param c   column number\n   * @private\n   */\n  function restoreColumn(c: number): void {\n    for (let i = U[c]; i !== c; i = U[i]) {\n      for (let j = L[i]; j !== i; j = L[j]) {\n        count[col[j]] += 1\n        U[D[j]] = j\n        D[U[j]] = j\n      }\n    }\n    L[R[c]] = c\n    R[L[c]] = c\n  }\n\n  /**\n   * Algorithm X.\n   *\n   * Recursively solve the problem of precise coverage, enumerate which rows are\n   * selected in the recursive process, remove the selected rows and all the\n   * columns on the rows, and restore these rows and columns during the\n   * backtrack.\n   *\n   * @param dep   recursion depth\n   * @private\n   */\n  function algorithmX(dep: number): boolean {\n    // Find a solution when the dancing-link is empty.\n    if (R[0] === 0) {\n      // Record the length of the solution.\n      countOfSelectedRows = dep\n      return true\n    }\n\n    /**\n     * Optimization: Find the column with the least number of nodes, and try to\n     * cover from this column.\n     */\n    let c = R[0]\n    for (let i = R[0]; i !== 0; i = R[i]) {\n      if (count[i] \u003c count[c]) c = i\n    }\n\n    // Remove this column.\n    removeColumn(c)\n    for (let i = D[c]; i !== c; i = D[i]) {\n      selectedRowNos[dep] = row[i]\n      for (let j = R[i]; j !== i; j = R[j]) removeColumn(col[j])\n\n      // Recursively processing.\n      if (algorithmX(dep + 1)) return true\n\n      // Backtrack.\n      for (let j = L[i]; j !== i; j = L[j]) restoreColumn(col[j])\n    }\n    // Backtrack.\n    restoreColumn(c)\n\n    return false\n  }\n}\n"},{"type":"paragraph","children":[{"type":"text","value":"我把它封装在了 "},{"type":"linkReference","identifier":"@algorithm.ts/dlx","label":"@algorithm.ts/dlx","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/dlx"}]},{"type":"text","value":" 中，你可以通过 npm 包导入它："}]},{"type":"code","lang":"typescript","meta":"\"dlx.demo.ts\" linenos","value":"import { createDLX } from 'algorithm.ts/dlx'\n\n// 创建一个基于至多有 1000 个节点的舞蹈链的 dlx 算法\nconst dlx = createDLX(1000)\n\n// 初始化 dlx 算法，总共有 1000 列\ndlx.init(1000)\n\n// 添加行，此处为伪代码\ndlx.addRow(...)\n\n// 尝试找到一个精确覆盖\ndlx.solve()\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"求解数独问题"}],"identifier":"heading-求解数独问题"},{"type":"paragraph","children":[{"type":"text","value":"数独是精确覆盖问题的一个特例。为了套用 DLX 算法框架，首先需要弄清楚如何构建 "},{"type":"inlineMath","value":"01"},{"type":"text","value":"\n矩阵。一般来说，可以将列对应成约束，而将行对应到策略，即选择某个策略时能够满足哪些约束。比如考虑经典 "},{"type":"inlineMath","value":"x^2 \\times x^2"},{"type":"text","value":" 数独游戏，其有如下类型的约束："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineMath","value":"Slot(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 行第 "},{"type":"inlineMath","value":"b"},{"type":"text","value":" 列格子要有数字；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"Row(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 行要有数字 "},{"type":"inlineMath","value":"b"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"Col(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 列要有数字 "},{"type":"inlineMath","value":"b"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"Sub(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 个子方阵中要有方阵 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"；"}]}]},{"type":"paragraph","children":[{"type":"text","value":"一共有 "},{"type":"inlineMath","value":"x^2 \\times x^2 \\times 4"},{"type":"text","value":" 中约束。再考虑可选择的策略，即在第 "},{"type":"inlineMath","value":"r"},{"type":"text","value":" 行第 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"\n列填入数字 "},{"type":"inlineMath","value":"v"},{"type":"text","value":"，且可以满足约束 "},{"type":"inlineMath","value":"Slot(r,c)"},{"type":"text","value":"、"},{"type":"inlineMath","value":"Row(r,v)"},{"type":"text","value":"、"},{"type":"inlineMath","value":"Col(c,v)"},{"type":"text","value":"、\n"},{"type":"inlineMath","value":"\\displaystyle Sub\\left(\\left\\lfloor \\frac{r}{x} \\right\\rfloor \\times x + \\left\\lfloor \\frac{c}{x} \\right\\rfloor,v\\right)"},{"type":"text","value":"。"}]},{"type":"paragraph","children":[{"type":"text","value":"代码如下："}]},{"type":"code","lang":"typescript","meta":"{29-33} title=\"sudoku.ts\" sourcefile=\"./sudoku.ts\" maxlines=\"15\" collapsed linenos","value":"import { createDLX } from './dlx'\n\n/**\n * @param SUDOKU_SIZE_SQRT 数独子方阵大小（即数独行数的平方根)\n */\nexport function createSudokuSolver(SUDOKU_SIZE_SQRT: number): SudokuSolver {\n  const ebs = 1e-6\n  const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT\n  const SUDOKU_SIZE_SQUARE = SUDOKU_SIZE * SUDOKU_SIZE\n  const MAX_NODES = SUDOKU_SIZE_SQUARE * 4\n\n  let codeA: number, codeB: number, codeC: number\n  const columns: number[] = new Array\u003cnumber\u003e(4)\n  const solver = createDLX(MAX_NODES)\n  return { solve }\n\n  function solve(puzzle: number[][]): boolean {\n    solver.init(MAX_NODES)\n    for (let r = 0; r \u003c SUDOKU_SIZE; ++r) {\n      for (let c = 0; c \u003c SUDOKU_SIZE; ++c) {\n        const w = puzzle[r][c]\n\n        // (r,c) 所属的子方阵编号\n        const s =\n          Math.floor(r / SUDOKU_SIZE_SQRT + ebs) * SUDOKU_SIZE_SQRT +\n          Math.floor(c / SUDOKU_SIZE_SQRT + ebs)\n        for (let v = 0; v \u003c SUDOKU_SIZE; ++v) {\n          if (w === -1 || w === v) {\n            columns[0] = encode(SudokuConstraint.SLOT, r, c)\n            columns[1] = encode(SudokuConstraint.ROW, r, v)\n            columns[2] = encode(SudokuConstraint.COL, c, v)\n            columns[3] = encode(SudokuConstraint.SUB, s, v)\n            solver.addRow(encode(r, c, v), columns)\n          }\n        }\n      }\n    }\n\n    const answer: number[] | null = solver.solve()\n    if (answer === null) return false\n\n    for (const code of answer) {\n      decode(code)\n      // eslint-disable-next-line no-param-reassign\n      puzzle[codeA][codeB] = codeC\n    }\n\n    return true\n  }\n\n  function encode(a: number, b: number, c: number): number {\n    return a * SUDOKU_SIZE_SQUARE + b * SUDOKU_SIZE + c + 1\n  }\n\n  function decode(code: number): void {\n    let c = code - 1\n    codeC = c % SUDOKU_SIZE\n\n    c = Math.floor(c / SUDOKU_SIZE + ebs)\n    codeB = c % SUDOKU_SIZE\n\n    c = Math.floor(c / SUDOKU_SIZE + ebs)\n    codeA = c\n  }\n}\n\n/**\n * Sudoku constraints.\n */\nexport enum SudokuConstraint {\n  SLOT = 0, // Slot(a, b) 表示第 a 行 b 列个格子上要有数字\n  ROW = 1, // Row(a, b) 表示第 a 行要有数字 b\n  COL = 2, // Col(a, b) 表示第 a 列要有数字 b\n  SUB = 3, // Sub(a, b) 表示第 a 个子方阵要有数字 b\n}\n\nexport interface SudokuSolver {\n  /**\n   * 数独的谜题格子，从 0 开始填，若某个格子未被填，则将其置为 -1\n   * @param puzzle\n   */\n  solve(puzzle: number[][]): boolean\n}\n"},{"type":"paragraph","children":[{"type":"text","value":"我把求解数独的算法封装在了 "},{"type":"linkReference","identifier":"@algorithm.ts/sudoku","label":"@algorithm.ts/sudoku","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sudoku"}]},{"type":"text","value":" 中，下面是求解 "},{"type":"inlineMath","value":"3^2 \\times 3^2"},{"type":"text","value":"\n数独谜题的示例"},{"type":"footnoteReference","label":"5","identifier":"footnote-5"},{"type":"text","value":"："}]},{"type":"code","lang":"jsx","meta":"live title=\"sudoku live demo\" jsxmode=\"block\" maxlines=\"10\" linenos","value":"// import { SudokuSolver, createSudokuBoardData } from '@algorithm.ts/sudoku'\nconst solver = new SudokuSolver({ childMatrixWidth: 3 })\n\nrender(\u003cSudokuLiveSolver /\u003e)\n\nfunction SudokuLiveSolver() {\n  const [puzzle, setPuzzle] = React.useState(() =\u003e ([\n     5,  0,  6,  7,  8, -1, -1,  3,  2,\n     1,  4,  2,  3, -1, -1,  8,  7,  6,\n     7,  3, -1, -1, -1, -1,  4,  0, -1,\n     8,  7,  3,  0,  6, -1, -1,  4,  1,\n     2, -1,  5,  1,  4,  3,  0,  8,  7,\n    -1,  1, -1,  8, -1, -1, -1, -1, -1,\n    -1,  8,  0, -1, -1, -1,  5,  1,  4,\n    -1,  5,  1,  4,  0,  6, -1,  2,  8,\n    -1, -1,  7,  5,  1,  8, -1,  6, -1\n  ]))\n\n  // Resolve sudoku puzzle.\n  const solution = React.useMemo(() =\u003e {\n    // Solve a sudoku puzzle and write the result into the `solution` array.\n    const solution = createSudokuBoardData(solver.size)\n    solver.solve(puzzle, solution)\n    return solution\n  }, [puzzle])\n\n  return (\n    \u003cSudokuSolverComponent\n      puzzle={puzzle}\n      solution={solution}\n      onPuzzleChange={setPuzzle}\n    /\u003e\n  )\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"刘汝佳《算法竞赛入门经典──训练指南》 P406 6.3.3 精确覆盖问题和 DLX 算法"}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-前言","contents":[{"type":"text","value":"前言"}],"children":[]},{"depth":2,"identifier":"heading-精确覆盖问题","contents":[{"type":"text","value":"精确覆盖问题"}],"children":[]},{"depth":2,"identifier":"heading-算法-x","contents":[{"type":"text","value":"算法 X"}],"children":[]},{"depth":2,"identifier":"heading-舞蹈链","contents":[{"type":"text","value":"舞蹈链"}],"children":[]},{"depth":2,"identifier":"heading-dlx-算法","contents":[{"type":"text","value":"DLX 算法"}],"children":[]},{"depth":2,"identifier":"heading-求解数独问题","contents":[{"type":"text","value":"求解数独问题"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[{"type":"ecmaImport","moduleName":"@kyokuya/_demo/post/algorithm/dlx/sudoku-solver.tsx","namedImports":[{"src":"SudokuSolverComponent","alias":null}]},{"type":"ecmaImport","moduleName":"@kyokuya/_demo/util/sudoku.ts","namedImports":[{"src":"SudokuSolver","alias":null},{"src":"createSudokuBoardData","alias":null}]}],"definitionMap":{"dancing-link.png":{"type":"definition","identifier":"dancing-link.png","label":"dancing-link.png","url":"/asset/img/post/adfc77b1-1fc0-59ba-bd69-b69726d6cdc2.png?width=744\u0026height=638"},"@algorithm.ts/dlx":{"type":"definition","identifier":"@algorithm.ts/dlx","label":"@algorithm.ts/dlx","url":"https://github.com/guanghechen/algorithm.ts/blob/main/packages/dlx/README.md"},"@algorithm.ts/sudoku":{"type":"definition","identifier":"@algorithm.ts/sudoku","label":"@algorithm.ts/sudoku","url":"https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md"}},"footnoteDefinitionMap":{"1":{"type":"footnoteDefinition","identifier":"1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"需要注意的是，此处并没有构成递归删除，因为只有被选择的行才需要删除行上的其余列，而删除这些列时所删除的其它行并未被选择（被选择行的此时均已被删除），也就不会进一步删除它们的列了。"}]}]},"2":{"type":"footnoteDefinition","identifier":"2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"每次删除时都是选择一个未被覆盖的列，然后枚举覆盖此列的行，之后删除该行上的其它列。即每次选取了一个集合 "},{"type":"inlineMath","value":"s"},{"type":"text","value":"，将目标集合中所有在 "},{"type":"inlineMath","value":"s"},{"type":"text","value":" 中出现的数字都删去，同时删除所有与 "},{"type":"inlineMath","value":"s"},{"type":"text","value":" 有非空交集的那些集合，也就是每次选择集合都保证了和之前已选择的集合间没有交集。而当目标集合为空时，说明所有数字都在已选择的集合中出现过了，也就是已选择的集合中无重叠、无遗漏的覆盖了目标集合中的所有数字。"}]}]},"3":{"type":"footnoteDefinition","identifier":"3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"这里指的是虚拟列，即相当于目标集合中的未被覆盖的元素，对应于下文中将提到的舞蹈链中中的列虚拟节点，所以即便所有行都被删除，列虚拟节点构成的链表仍可能不为空。"}]}]},"4":{"type":"footnoteDefinition","identifier":"4","label":"4","children":[{"type":"paragraph","children":[{"type":"text","value":"在使用数组模拟链表的实现中，虚拟节点用列号表示就行了。而舞蹈链的头指针有\n"},{"type":"inlineMath","value":"0"},{"type":"text","value":" 表示即可。需要注意的是，舞蹈链中所有列号均为正整数。"}]}]},"footnote-5":{"type":"footnoteDefinition","identifier":"footnote-5","label":"5","children":[{"type":"paragraph","children":[{"type":"text","value":"需要注意的是，"},{"type":"linkReference","identifier":"@algorithm.ts/sudoku","label":"@algorithm.ts/sudoku","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sudoku"}]},{"type":"text","value":" 中对于一个 "},{"type":"inlineMath","value":"x^2 \\times x^2"},{"type":"text","value":"\n的数独，使用 "},{"type":"inlineMath","value":"[-1, x^2)"},{"type":"text","value":" 之间的整数作为数独格子的值，其中 "},{"type":"inlineMath","value":"-1"},{"type":"text","value":" 代表对应格子未预置值"}]}]}},"paginationUrl":"/posts/1","prev":{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle"},"next":{"title":"当你想来一把数独","slug":"/post/game/sudoku"},"aplayerOptions":null,"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"__N_SSG":true},"page":"/post/[...slug]","query":{"slug":["algorithm","dlx"]},"buildId":"OJnGaMf6Cc9xX4yB8MA4a","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>