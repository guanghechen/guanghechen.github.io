3:I[5613,[],""]
5:I[31778,[],""]
7:I[79286,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-3cfcff3dbdfef710.js"],"SiteProvider"]
8:I[54110,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-3cfcff3dbdfef710.js"],""]
9:I[74117,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-3cfcff3dbdfef710.js"],"MaterialThemeProvider"]
a:I[55153,["74","static/chunks/74-31f764c22632bceb.js","800","static/chunks/800-4848173b49d8d689.js","160","static/chunks/app/not-found-7a4f60c8a23c275c.js"],"NotFoundView"]
4:["slug","algorithm/dlx","c"]
0:["ljSkOJjfmWVTbqkBtclKC",[[["",{"children":["(post)",{"children":["post",{"children":[["slug","algorithm/dlx","c"],{"children":["__PAGE__?{\"slug\":[\"algorithm\",\"dlx\"]}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(post)",{"children":["post",{"children":[["slug","algorithm/dlx","c"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children","$4","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,"$L6",null]]},[null,["$","html",null,{"lang":"en","className":"__className_324942","children":[["$","head",null,{"children":[["$","meta",null,{"charSet":"utf8"}],["$","meta","viewport",{"name":"viewport","content":"initial-scale=1.0, width=device-width"}],["$","meta",null,{"name":"application-name","content":"guanghechen"}],["$","meta",null,{"name":"apple-mobile-web-app-title","content":"光和尘"}],["$","meta",null,{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta",null,{"name":"description","content":"Guanghechen's personal site"}],["$","meta",null,{"name":"format-detection","content":"telephone=no"}],["$","meta",null,{"name":"mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"msapplication-config","content":"/icons/browserconfig.xml"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#2B5797"}],["$","meta",null,{"name":"msapplication-tap-highlight","content":"no"}],["$","meta",null,{"name":"theme-color","content":"#a2466c"}],["$","meta",null,{"property":"og:type","content":"website"}],["$","meta",null,{"property":"og:title","content":"光和尘"}],["$","meta",null,{"property":"og:description","content":"光和尘的个人站点"}],["$","meta",null,{"property":"og:site_name","content":"guanghechen"}],["$","meta",null,{"property":"og:url","content":"https://preview.me.guanghechen.com"}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon.png"}]]}],["$","body",null,{"children":["$","$L7",null,{"children":["$","$L8",null,{"children":["$","$L9",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$La",null,{}],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2159a4b672631e08.css","precedence":"next","crossOrigin":""}]]}]}]}]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f2ccec9f31141b1c.css","precedence":"next","crossOrigin":""}]],"$Lb"]]]]
c:I[56057,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-9f2189f8d08bfc42.js","63","static/chunks/app/(essay)/layout-0026ac321c51c13c.js"],"YozoraThemeProvider"]
d:I[20593,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-9f2189f8d08bfc42.js","63","static/chunks/app/(essay)/layout-0026ac321c51c13c.js"],"PostLayoutView"]
e:I[59627,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","595","static/chunks/595-60215c9a9c19277d.js","551","static/chunks/551-68df0022cc950ef8.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-9f2189f8d08bfc42.js","918","static/chunks/app/(post)/post/%5B...slug%5D/page-80cd6d5787edd594.js"],"PostDetailPageView"]
6:["$","$Lc",null,{"children":["$","$Ld",null,{"data":{"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数 e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]}]}]
f:["算法","精确覆盖","DLX 算法"]
10:T18f3,/**
 * The algorithm X that applied the dancing-link, it is also called as "DLX".
 * It is used to solve the exact-cover problem.
 *
 * Dancing-link: A cross doubly linked list, each column has a virtual node as
 * the head pointer, and at the top of all virtual nodes there is an additional
 * virtual node as the head pointer of the virtual node, which is also the head
 * pointer of the entire dancing-link. In the implementation of using an array
 * to simulate a linked list, the virtual node is represented by a column
 * number, and the head pointer of the dancing-link can be represented by 0.
 *
 * @see https://me.guanghechen.com/post/algorithm/dlx/
 */
export interface DLX {
  /**
   * Initialize the dancing-link.
   * @param totalColumns   number of columns
   */
  init(totalColumns: number): void

  /**
   * Release memory variables.
   */
  destroy(): void

  /**
   * Add a row to the dancing-link.
   *
   * It should be noted that after solving the exact-cover problem, the
   * result is a list of selected row numbers, so the row number should be
   * specified as a value that can carry information.
   *
   * @param r         the row number
   * @param columns   columns on the row
   */
  addRow(rowNo: number, columns: ReadonlyArray<number>): void

  /**
   * Try to find a precise coverage.
   *
   * When a solution is found, return the row numbers of all selected rows,
   * otherwise return null.
   */
  solve(): number[] | null
}

/**
 * Generate an object that encapsulates the DLX algorithm.
 *
 * @param MAX_N   maximum number of nodes in the dancing-link
 * @returns
 */
export function createDLX(MAX_N: number): DLX {
  // The number of nodes in the dancing-link (including the virtual nodes on
  // the column).
  let sz: number

  // the number of columns in the dancing-link.
  let totalColumns: number

  const selectedRowNos: number[] = new Array(MAX_N) // list of row numbers of selected rows
  let countOfSelectedRows: number // the number of selected rows

  const count: number[] = new Array(MAX_N) // lhe number of nodes of a column in the dancing-link
  const row: number[] = new Array(MAX_N) // the row number of a node in the dancing-link
  const col: number[] = new Array(MAX_N) // the column number of a node in the dancing-link
  const L: number[] = new Array(MAX_N) // left pointer of cross-link list
  const R: number[] = new Array(MAX_N) // right pointer of cross-link list
  const U: number[] = new Array(MAX_N) // up pointer of cross-link list
  const D: number[] = new Array(MAX_N) // down pointer of cross-link list
  return { init, destroy, addRow, solve }

  /**
   * @see DLX#init
   * @public
   */
  function init(_totalColumns: number): void {
    totalColumns = _totalColumns
    sz = _totalColumns + 1

    // Resize arrays.
    if (selectedRowNos.length < sz) {
      selectedRowNos.length = sz
      count.length = sz
      row.length = sz
      col.length = sz
      L.length = sz
      R.length = sz
      U.length = sz
      D.length = sz
    }

    for (let i = 0; i < sz; ++i) {
      L[i] = i - 1
      R[i] = i + 1
      U[i] = i
      D[i] = i
    }
    R[_totalColumns] = 0
    L[0] = _totalColumns

    count.fill(0, 0, sz)
  }

  /**
   * @see DLX#destroy
   * @public
   */
  function destroy(): void {
    selectedRowNos.length = 0
    count.length = 0
    row.length = 0
    col.length = 0
    L.length = 0
    R.length = 0
    U.length = 0
    D.length = 0
  }

  /**
   * @see DLX#addRow
   * @public
   */
  function addRow(r: number, columns: ReadonlyArray<number>): void {
    const first = sz
    for (let i = 0; i < columns.length; ++i, ++sz) {
      const c = columns[i]
      row[sz] = r
      col[sz] = c
      count[c] += 1

      // Connect left and right nodes
      L[sz] = sz - 1
      R[sz] = sz + 1

      // Connect top and bottom nodes,
      // c is the virtual node on the c-th column, and is also the head pointer
      // of the linked list of the column, so at this time U[c] is the last
      // element of the column
      D[sz] = c
      D[U[c]] = sz
      U[sz] = U[c]
      U[c] = sz
    }

    // Since this is a circular linked list, the first and last columns of the
    // current row are connected to each other.
    R[sz - 1] = first
    L[first] = sz - 1
  }

  /**
   * @see DLX#solve
   * @public
   */
  function solve(): number[] | null {
    if (!algorithmX(0)) return null
    return selectedRowNos.slice(0, countOfSelectedRows)
  }

  /**
   * Remove a column from the dancing-link.
   * @param c   column number
   * @private
   */
  function removeColumn(c: number): void {
    L[R[c]] = L[c]
    R[L[c]] = R[c]
    for (let i = D[c]; i !== c; i = D[i]) {
      for (let j = R[i]; j !== i; j = R[j]) {
        U[D[j]] = U[j]
        D[U[j]] = D[j]
        count[col[j]] -= 1
      }
    }
  }

  /**
   * Restore a previously deleted column
   * @param c   column number
   * @private
   */
  function restoreColumn(c: number): void {
    for (let i = U[c]; i !== c; i = U[i]) {
      for (let j = L[i]; j !== i; j = L[j]) {
        count[col[j]] += 1
        U[D[j]] = j
        D[U[j]] = j
      }
    }
    L[R[c]] = c
    R[L[c]] = c
  }

  /**
   * Algorithm X.
   *
   * Recursively solve the problem of precise coverage, enumerate which rows are
   * selected in the recursive process, remove the selected rows and all the
   * columns on the rows, and restore these rows and columns during the
   * backtrack.
   *
   * @param dep   recursion depth
   * @private
   */
  function algorithmX(dep: number): boolean {
    // Find a solution when the dancing-link is empty.
    if (R[0] === 0) {
      // Record the length of the solution.
      countOfSelectedRows = dep
      return true
    }

    /**
     * Optimization: Find the column with the least number of nodes, and try to
     * cover from this column.
     */
    let c = R[0]
    for (let i = R[0]; i !== 0; i = R[i]) {
      if (count[i] < count[c]) c = i
    }

    // Remove this column.
    removeColumn(c)
    for (let i = D[c]; i !== c; i = D[i]) {
      selectedRowNos[dep] = row[i]
      for (let j = R[i]; j !== i; j = R[j]) removeColumn(col[j])

      // Recursively processing.
      if (algorithmX(dep + 1)) return true

      // Backtrack.
      for (let j = L[i]; j !== i; j = L[j]) restoreColumn(col[j])
    }
    // Backtrack.
    restoreColumn(c)

    return false
  }
}
11:T982,import { createDLX } from './dlx'

/**
 * Sudoku constraints.
 */
export enum SudokuConstraint {
  SLOT = 0, // Slot(a, b) 表示第 a 行 b 列个格子上要有数字
  ROW = 1, // Row(a, b) 表示第 a 行要有数字 b
  COL = 2, // Col(a, b) 表示第 a 列要有数字 b
  SUB = 3, // Sub(a, b) 表示第 a 个子方阵要有数字 b
}

export interface SudokuSolver {
  /**
   * 数独的谜题格子，从 0 开始填，若某个格子未被填，则将其置为 -1
   * @param puzzle
   */
  solve(puzzle: number[][]): boolean
}

/**
 * @param SUDOKU_SIZE_SQRT 数独子方阵大小（即数独行数的平方根)
 */
export function createSudokuSolver(SUDOKU_SIZE_SQRT: number): SudokuSolver {
  const ebs = 1e-6
  const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT
  const SUDOKU_SIZE_SQUARE = SUDOKU_SIZE * SUDOKU_SIZE
  const MAX_NODES = SUDOKU_SIZE_SQUARE * 4

  let codeA: number, codeB: number, codeC: number
  const columns: number[] = new Array<number>(4)
  const solver = createDLX(MAX_NODES)
  return { solve }

  function solve(puzzle: number[][]): boolean {
    solver.init(MAX_NODES)
    for (let r = 0; r < SUDOKU_SIZE; ++r) {
      for (let c = 0; c < SUDOKU_SIZE; ++c) {
        const w = puzzle[r][c]

        // (r,c) 所属的子方阵编号
        const s =
          Math.floor(r / SUDOKU_SIZE_SQRT + ebs) * SUDOKU_SIZE_SQRT +
          Math.floor(c / SUDOKU_SIZE_SQRT + ebs)
        for (let v = 0; v < SUDOKU_SIZE; ++v) {
          if (w === -1 || w === v) {
            columns[0] = encode(SudokuConstraint.SLOT, r, c)
            columns[1] = encode(SudokuConstraint.ROW, r, v)
            columns[2] = encode(SudokuConstraint.COL, c, v)
            columns[3] = encode(SudokuConstraint.SUB, s, v)
            solver.addRow(encode(r, c, v), columns)
          }
        }
      }
    }

    const answer: number[] | null = solver.solve()
    if (answer === null) return false

    for (const code of answer) {
      decode(code)
      // eslint-disable-next-line no-param-reassign
      puzzle[codeA][codeB] = codeC
    }

    return true
  }

  function encode(a: number, b: number, c: number): number {
    return a * SUDOKU_SIZE_SQUARE + b * SUDOKU_SIZE + c + 1
  }

  function decode(code: number): void {
    let c = code - 1
    codeC = c % SUDOKU_SIZE

    c = Math.floor(c / SUDOKU_SIZE + ebs)
    codeB = c % SUDOKU_SIZE

    c = Math.floor(c / SUDOKU_SIZE + ebs)
    codeA = c
  }
}
2:["$","$Le",null,{"data":{"title":"精确覆盖问题和 DLX 算法","titleAst":{"type":"paragraph","children":[{"type":"text","value":"精确覆盖问题和 DLX 算法"}]},"slug":"/post/algorithm/dlx","createdAt":"Jul 24, 2021","updatedAt":"Jun 04, 2023","timeToRead":"09min 12s","tags":"$f","categories":[],"ast":{"type":"root","children":[{"type":"ecmaImport","moduleName":"@kyokuya/_demo/post/algorithm/dlx/sudoku-solver.tsx","namedImports":[{"src":"SudokuSolverDemo","alias":null}]},{"type":"ecmaImport","moduleName":"@kyokuya/_demo/util/sudoku.ts","namedImports":[{"src":"SudokuSolver","alias":null},{"src":"createSudokuBoardData","alias":null}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"前言"}],"identifier":"heading-前言"},{"type":"paragraph","children":[{"type":"text","value":"很早就想要补一下舞蹈链和精确覆盖算法，却一直各种拖延，趁着最近有空，又重新翻开了刘汝佳的书。大学的时候看过几次，甚至照着书里的思路手敲了一遍并通过了例题，但对于算法的原理一直有些不求甚解。很早以前，一位同学告诉我说“现在看不懂的东西不用勉强，以后慢慢就会懂了”，后来也真的在不断印证这句话；但我很担心随着年纪的增长，记忆力和学习能力不断退化之后，恐怕这个 flag 会逐渐倒下。所以趁着眼下尚能理解进去，尽量用自己的语言做一下记录。"}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"精确覆盖问题"}],"identifier":"heading-精确覆盖问题"},{"type":"paragraph","children":[{"type":"text","value":"有一些由整数 "},{"type":"inlineMath","value":"1 \\sim n"},{"type":"text","value":" 中的数字组成的集合 "},{"type":"inlineMath","value":"S_1, S_2, \\cdots, S_m"},{"type":"text","value":"，要求选择若干个集合 "},{"type":"inlineMath","value":"S_i"},{"type":"text","value":"，使得 "},{"type":"inlineMath","value":"1 \\sim n"},{"type":"text","value":" 中每个整数都在选出的集合中的某个出现且恰好仅出现一次。举个栗子："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"不妨假设 "},{"type":"inlineMath","value":"n=7, m=6"},{"type":"text","value":"，集合为："}]},{"type":"math","value":"\\begin{aligned}\n  S_1&=\\lbrace 1, 4, 7 \\rbrace\\\\\n  S_2&=\\lbrace 1, 4 \\rbrace\\\\\n  S_3&=\\lbrace 4,5,7 \\rbrace\\\\\n  S_4&=\\lbrace 3, 5, 6 \\rbrace\\\\\n  S_5&=\\lbrace 2, 3, 6, 7 \\rbrace\\\\\n  S_6&=\\lbrace 2, 7 \\rbrace\\\\\n\\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"则一个精确覆盖为 "},{"type":"inlineMath","value":"\\lbrace S_2, S_4, S_6 \\rbrace"},{"type":"text","value":"，因为 "},{"type":"inlineMath","value":"\\lbrace 1, 4 \\rbrace"},{"type":"text","value":",\n"},{"type":"inlineMath","value":"\\lbrace 3, 5, 6 \\rbrace"},{"type":"text","value":", "},{"type":"inlineMath","value":"\\lbrace 2, 7 \\rbrace"},{"type":"text","value":" 无重复、无遗漏地包含了 "},{"type":"inlineMath","value":"1 \\sim 7"},{"type":"text","value":"\n中的所有整数。"}]}]},{"type":"paragraph","children":[{"type":"text","value":"我们可以用一个 "},{"type":"inlineMath","value":"m \\times n"},{"type":"text","value":" 的 "},{"type":"inlineMath","value":"01"},{"type":"text","value":" 矩阵来表示集合，其中，"},{"type":"inlineMath","value":"0"},{"type":"text","value":" 表示不包含，"},{"type":"inlineMath","value":"1"},{"type":"text","value":" 表示包含。比如第 "},{"type":"inlineMath","value":"(i, j)"},{"type":"text","value":" 个位置若为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":"，则说明 "},{"type":"inlineMath","value":"S_i"},{"type":"text","value":" 中不包含 "},{"type":"inlineMath","value":"j"},{"type":"text","value":"。上文中的栗子用矩阵表示如下所示："}]},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":" "}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"7"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"S_6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"1"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"则精确覆盖问题可重新表述为：在一个 "},{"type":"inlineMath","value":"m \\times n"},{"type":"text","value":" 的 "},{"type":"inlineMath","value":"01"},{"type":"text","value":" 矩阵中，选择若干行，对这些行做向量加法，得到的结果为 "},{"type":"inlineMath","value":"(1, 1, \\cdots, 1)"},{"type":"text","value":"。即："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"选出的行里，不存在某列同时在两行中值均为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"text","value":"所有选出的行叠加在一起的结果覆盖所有列（每一列的值都不为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":"）。"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"算法 X"}],"identifier":"heading-算法-x"},{"type":"paragraph","children":[{"type":"text","value":"算法 X（Algorithm X），其实就是回溯，可能是专门针对覆盖问题提出的算法吧。算法描述如下："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"每次选择一个没有被删除列，然后枚举该列为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的所有行，尝试删除这些行，递归搜索后再恢复这些行。尝试删除行时，还要将该行中所有值为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的列也一并删除"},{"type":"footnoteReference","identifier":"1","label":"1"},{"type":"text","value":"，恢复时也同样。"}]},{"type":"paragraph","children":[{"type":"text","value":"若没有可以选择的列了（即所有列都被删除了），说明已经找到一个精确覆盖的解了"},{"type":"footnoteReference","identifier":"2","label":"2"},{"type":"text","value":"；若还有列但是没有行了"},{"type":"footnoteReference","identifier":"3","label":"3"},{"type":"text","value":"说明原问题无解。"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"舞蹈链"}],"identifier":"heading-舞蹈链"},{"type":"paragraph","children":[{"type":"text","value":"舞蹈链（Dancing Link），一种支持快速删除、恢复列和行的数据结构。"}]},{"type":"paragraph","children":[{"type":"text","value":"舞蹈链是一个十字型双向链表结构，链表中的每个节点对应上述 "},{"type":"inlineMath","value":"01"},{"type":"text","value":" 矩阵中的一个 "},{"type":"inlineMath","value":"1"},{"type":"text","value":"。另外还有 "},{"type":"inlineMath","value":"n+1"},{"type":"text","value":" 个虚拟节点，其中每列最上方一个虚拟节点作为该列链表的头指针，而所有虚拟节点的最前方有一个虚拟节点，作为虚拟节点的头指针，它也是舞蹈链的头指针。如下图所示（图片来源于网络）："}]},{"type":"paragraph","children":[{"type":"imageReference","identifier":"dancing-link.png","label":"dancing-link.png","referenceType":"collapsed","alt":"dancing-link.png"}]},{"type":"paragraph","children":[{"type":"text","value":"使用四个数组 "},{"type":"inlineMath","value":"L"},{"type":"text","value":", "},{"type":"inlineMath","value":"R"},{"type":"text","value":", "},{"type":"inlineMath","value":"U"},{"type":"text","value":", "},{"type":"inlineMath","value":"D"},{"type":"text","value":" 分别表示舞蹈链中节点的左、右、上、下四个方向的指针，下标为节点的编号；同时列编号作为该列的虚拟节点，"},{"type":"inlineMath","value":"0"},{"type":"text","value":" 表示舞蹈链的头指针对应的虚拟节点。"}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"删除行：只需要修改将该行中所有节点的上下行的下、上指针互指就好了。"}]},{"type":"code","lang":"typescript","meta":"title=\"dancing-link.01.ts\" linenos","value":"// 设要删除的某行中某个节点编号为 R[i]\nfor (let j = R[i]; j !== i; j = R[j]) {\n  U[D[j]] = U[j]\n  D[U[j]] = D[j]\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"恢复行：只需要将该行中所有节点的上下行的下、上指针分别指向该该节点就好了。"}]},{"type":"code","lang":"typescript","meta":"title=\"dancing-link.01.ts\" linenos","value":"// 设要删除的某行中某个节点编号为 R[i]\nfor (let j = R[i]; j !== i; j = R[j]) {\n  U[D[j]] = j\n  D[U[j]] = j\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"删除列和恢复列也类似，此处略去。"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"DLX 算法"}],"identifier":"heading-dlx-算法"},{"type":"paragraph","children":[{"type":"text","value":"使用了舞蹈链的算法 X 通常被称为 DLX 算法。此处给出 DLX 算法的 Typescript 实现"},{"type":"footnoteReference","identifier":"4","label":"4"},{"type":"text","value":"。"}]},{"type":"code","lang":"typescript","meta":"title=\"dlx.ts\" sourcefile=\"./dlx.ts\" maxlines=\"15\" collapsed linenos","value":"$10"},{"type":"paragraph","children":[{"type":"text","value":"我把它封装在了 "},{"type":"linkReference","identifier":"@algorithm.ts/dlx","label":"@algorithm.ts/dlx","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/dlx"}]},{"type":"text","value":" 中，你可以通过 npm 包导入它："}]},{"type":"code","lang":"typescript","meta":"\"dlx.demo.ts\" linenos","value":"import { createDLX } from 'algorithm.ts/dlx'\n\n// 创建一个基于至多有 1000 个节点的舞蹈链的 dlx 算法\nconst dlx = createDLX(1000)\n\n// 初始化 dlx 算法，总共有 1000 列\ndlx.init(1000)\n\n// 添加行，此处为伪代码\ndlx.addRow(...)\n\n// 尝试找到一个精确覆盖\ndlx.solve()\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"求解数独问题"}],"identifier":"heading-求解数独问题"},{"type":"paragraph","children":[{"type":"text","value":"数独是精确覆盖问题的一个特例。为了套用 DLX 算法框架，首先需要弄清楚如何构建 "},{"type":"inlineMath","value":"01"},{"type":"text","value":"\n矩阵。一般来说，可以将列对应成约束，而将行对应到策略，即选择某个策略时能够满足哪些约束。比如考虑经典 "},{"type":"inlineMath","value":"x^2 \\times x^2"},{"type":"text","value":" 数独游戏，其有如下类型的约束："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineMath","value":"Slot(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 行第 "},{"type":"inlineMath","value":"b"},{"type":"text","value":" 列格子要有数字；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"Row(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 行要有数字 "},{"type":"inlineMath","value":"b"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"Col(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 列要有数字 "},{"type":"inlineMath","value":"b"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"Sub(a,b)"},{"type":"text","value":": 第 "},{"type":"inlineMath","value":"a"},{"type":"text","value":" 个子方阵中要有方阵 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"；"}]}]},{"type":"paragraph","children":[{"type":"text","value":"一共有 "},{"type":"inlineMath","value":"x^2 \\times x^2 \\times 4"},{"type":"text","value":" 中约束。再考虑可选择的策略，即在第 "},{"type":"inlineMath","value":"r"},{"type":"text","value":" 行第 "},{"type":"inlineMath","value":"c"},{"type":"text","value":"\n列填入数字 "},{"type":"inlineMath","value":"v"},{"type":"text","value":"，且可以满足约束 "},{"type":"inlineMath","value":"Slot(r,c)"},{"type":"text","value":"、"},{"type":"inlineMath","value":"Row(r,v)"},{"type":"text","value":"、"},{"type":"inlineMath","value":"Col(c,v)"},{"type":"text","value":"、\n"},{"type":"inlineMath","value":"\\displaystyle Sub\\left(\\left\\lfloor \\frac{r}{x} \\right\\rfloor \\times x + \\left\\lfloor \\frac{c}{x} \\right\\rfloor,v\\right)"},{"type":"text","value":"。"}]},{"type":"paragraph","children":[{"type":"text","value":"代码如下："}]},{"type":"code","lang":"typescript","meta":"{29-33} title=\"sudoku.ts\" sourcefile=\"./sudoku.ts\" maxlines=\"15\" collapsed linenos","value":"$11"},{"type":"paragraph","children":[{"type":"text","value":"我把求解数独的算法封装在了 "},{"type":"linkReference","identifier":"@algorithm.ts/sudoku","label":"@algorithm.ts/sudoku","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sudoku"}]},{"type":"text","value":" 中，下面是求解 "},{"type":"inlineMath","value":"3^2 \\times 3^2"},{"type":"text","value":"\n数独谜题的示例"},{"type":"footnoteReference","label":"5","identifier":"footnote-5"},{"type":"text","value":"："}]},{"type":"code","lang":"jsx","meta":"live title=\"sudoku live demo\" jsxmode=\"block\" maxlines=\"10\" linenos","value":"// import { SudokuSolver, createSudokuBoardData } from '@algorithm.ts/sudoku'\nconst solver = new SudokuSolver({ childMatrixWidth: 3 })\n\nrender(<SudokuLiveSolver />)\n\nfunction SudokuLiveSolver() {\n  const [puzzle, setPuzzle] = React.useState(() => ([\n     5,  0,  6,  7,  8, -1, -1,  3,  2,\n     1,  4,  2,  3, -1, -1,  8,  7,  6,\n     7,  3, -1, -1, -1, -1,  4,  0, -1,\n     8,  7,  3,  0,  6, -1, -1,  4,  1,\n     2, -1,  5,  1,  4,  3,  0,  8,  7,\n    -1,  1, -1,  8, -1, -1, -1, -1, -1,\n    -1,  8,  0, -1, -1, -1,  5,  1,  4,\n    -1,  5,  1,  4,  0,  6, -1,  2,  8,\n    -1, -1,  7,  5,  1,  8, -1,  6, -1\n  ]))\n\n  // Resolve sudoku puzzle.\n  const solution = React.useMemo(() => {\n    // Solve a sudoku puzzle and write the result into the `solution` array.\n    const solution = createSudokuBoardData(solver.size)\n    solver.solve(puzzle, solution)\n    return solution\n  }, [puzzle])\n\n  return (\n    <SudokuSolverDemo\n      puzzle={puzzle}\n      solution={solution}\n      onPuzzleChange={setPuzzle}\n    />\n  )\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"刘汝佳《算法竞赛入门经典──训练指南》 P406 6.3.3 精确覆盖问题和 DLX 算法"}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-前言","contents":[{"type":"text","value":"前言"}],"children":[]},{"depth":2,"identifier":"heading-精确覆盖问题","contents":[{"type":"text","value":"精确覆盖问题"}],"children":[]},{"depth":2,"identifier":"heading-算法-x","contents":[{"type":"text","value":"算法 X"}],"children":[]},{"depth":2,"identifier":"heading-舞蹈链","contents":[{"type":"text","value":"舞蹈链"}],"children":[]},{"depth":2,"identifier":"heading-dlx-算法","contents":[{"type":"text","value":"DLX 算法"}],"children":[]},{"depth":2,"identifier":"heading-求解数独问题","contents":[{"type":"text","value":"求解数独问题"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[{"type":"ecmaImport","moduleName":"@kyokuya/_demo/post/algorithm/dlx/sudoku-solver.tsx","namedImports":[{"src":"SudokuSolverDemo","alias":null}]},{"type":"ecmaImport","moduleName":"@kyokuya/_demo/util/sudoku.ts","namedImports":[{"src":"SudokuSolver","alias":null},{"src":"createSudokuBoardData","alias":null}]}],"definitionMap":{"dancing-link.png":{"type":"definition","identifier":"dancing-link.png","label":"dancing-link.png","url":"/asset/post/img/63e2f05d-1f14-51d1-ba76-e375f2c86ee8.png?width=744&height=638"},"@algorithm.ts/dlx":{"type":"definition","identifier":"@algorithm.ts/dlx","label":"@algorithm.ts/dlx","url":"https://github.com/guanghechen/algorithm.ts/blob/main/packages/dlx/README.md"},"@algorithm.ts/sudoku":{"type":"definition","identifier":"@algorithm.ts/sudoku","label":"@algorithm.ts/sudoku","url":"https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md"}},"footnoteDefinitionMap":{"1":{"type":"footnoteDefinition","identifier":"1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"需要注意的是，此处并没有构成递归删除，因为只有被选择的行才需要删除行上的其余列，而删除这些列时所删除的其它行并未被选择（被选择行的此时均已被删除），也就不会进一步删除它们的列了。"}]}]},"2":{"type":"footnoteDefinition","identifier":"2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"每次删除时都是选择一个未被覆盖的列，然后枚举覆盖此列的行，之后删除该行上的其它列。即每次选取了一个集合 "},{"type":"inlineMath","value":"s"},{"type":"text","value":"，将目标集合中所有在 "},{"type":"inlineMath","value":"s"},{"type":"text","value":" 中出现的数字都删去，同时删除所有与 "},{"type":"inlineMath","value":"s"},{"type":"text","value":" 有非空交集的那些集合，也就是每次选择集合都保证了和之前已选择的集合间没有交集。而当目标集合为空时，说明所有数字都在已选择的集合中出现过了，也就是已选择的集合中无重叠、无遗漏的覆盖了目标集合中的所有数字。"}]}]},"3":{"type":"footnoteDefinition","identifier":"3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"这里指的是虚拟列，即相当于目标集合中的未被覆盖的元素，对应于下文中将提到的舞蹈链中中的列虚拟节点，所以即便所有行都被删除，列虚拟节点构成的链表仍可能不为空。"}]}]},"4":{"type":"footnoteDefinition","identifier":"4","label":"4","children":[{"type":"paragraph","children":[{"type":"text","value":"在使用数组模拟链表的实现中，虚拟节点用列号表示就行了。而舞蹈链的头指针有\n"},{"type":"inlineMath","value":"0"},{"type":"text","value":" 表示即可。需要注意的是，舞蹈链中所有列号均为正整数。"}]}]},"footnote-5":{"type":"footnoteDefinition","identifier":"footnote-5","label":"5","children":[{"type":"paragraph","children":[{"type":"text","value":"需要注意的是，"},{"type":"linkReference","identifier":"@algorithm.ts/sudoku","label":"@algorithm.ts/sudoku","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/sudoku"}]},{"type":"text","value":" 中对于一个 "},{"type":"inlineMath","value":"x^2 \\times x^2"},{"type":"text","value":"\n的数独，使用 "},{"type":"inlineMath","value":"[-1, x^2)"},{"type":"text","value":" 之间的整数作为数独格子的值，其中 "},{"type":"inlineMath","value":"-1"},{"type":"text","value":" 代表对应格子未预置值"}]}]}},"images":[{"alt":"dancing-link.png","src":"/asset/post/img/63e2f05d-1f14-51d1-ba76-e375f2c86ee8.png?width=744&height=638"}],"paginationUrl":"/posts/1","prev":{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle"},"next":{"title":"当你想来一把数独","slug":"/post/game/sudoku"},"aplayerOptions":null}}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"精确覆盖问题和 DLX 算法 | guanghechen"}],["$","meta","3",{"name":"description","content":"精确覆盖问题和 DLX 算法"}],["$","meta","4",{"name":"application-name","content":"guanghechen"}],["$","link","5",{"rel":"author","href":"https://github.com/guanghechen"}],["$","meta","6",{"name":"author","content":"光和尘"}],["$","link","7",{"rel":"icon","href":"/favicon.png"}],["$","meta","8",{"name":"next-size-adjust"}]]
1:null
