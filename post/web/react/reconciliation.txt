3:I[5613,[],""]
5:I[31778,[],""]
7:I[79286,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-c863019bb2b3aef0.js"],"SiteProvider"]
8:I[54110,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-c863019bb2b3aef0.js"],""]
9:I[74117,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","800","static/chunks/800-4848173b49d8d689.js","185","static/chunks/app/layout-c863019bb2b3aef0.js"],"MaterialThemeProvider"]
a:I[55153,["74","static/chunks/74-31f764c22632bceb.js","800","static/chunks/800-4848173b49d8d689.js","160","static/chunks/app/not-found-79f3557760569a3b.js"],"NotFoundView"]
4:["slug","web/react/reconciliation","c"]
0:["eyS7yEHAsi6_ceCdSwHos",[[["",{"children":["(post)",{"children":["post",{"children":[["slug","web/react/reconciliation","c"],{"children":["__PAGE__?{\"slug\":[\"web\",\"react\",\"reconciliation\"]}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(post)",{"children":["post",{"children":[["slug","web/react/reconciliation","c"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children","$4","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children","post","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,"$L6",null]]},[null,["$","html",null,{"lang":"en","className":"__className_324942","children":[["$","head",null,{"children":[["$","meta",null,{"charSet":"utf8"}],["$","meta","viewport",{"name":"viewport","content":"initial-scale=1.0, width=device-width"}],["$","meta",null,{"name":"application-name","content":"guanghechen"}],["$","meta",null,{"name":"apple-mobile-web-app-title","content":"光和尘"}],["$","meta",null,{"name":"apple-mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"apple-mobile-web-app-status-bar-style","content":"default"}],["$","meta",null,{"name":"description","content":"Guanghechen's personal site"}],["$","meta",null,{"name":"format-detection","content":"telephone=no"}],["$","meta",null,{"name":"mobile-web-app-capable","content":"yes"}],["$","meta",null,{"name":"msapplication-config","content":"/icons/browserconfig.xml"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#2B5797"}],["$","meta",null,{"name":"msapplication-tap-highlight","content":"no"}],["$","meta",null,{"name":"theme-color","content":"#a2466c"}],["$","meta",null,{"property":"og:type","content":"website"}],["$","meta",null,{"property":"og:title","content":"光和尘"}],["$","meta",null,{"property":"og:description","content":"光和尘的个人站点"}],["$","meta",null,{"property":"og:site_name","content":"guanghechen"}],["$","meta",null,{"property":"og:url","content":"https://preview.me.guanghechen.com"}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","link",null,{"rel":"shortcut icon","href":"/favicon.png"}]]}],["$","body",null,{"children":["$","$L7",null,{"children":["$","$L8",null,{"children":["$","$L9",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$La",null,{}],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2159a4b672631e08.css","precedence":"next","crossOrigin":""}]]}]}]}]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f2ccec9f31141b1c.css","precedence":"next","crossOrigin":""}]],"$Lb"]]]]
c:I[56057,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-62c186fb5283557d.js","422","static/chunks/app/(post)/layout-dfa2e09a2a72ad66.js"],"YozoraThemeProvider"]
d:I[20593,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-62c186fb5283557d.js","422","static/chunks/app/(post)/layout-dfa2e09a2a72ad66.js"],"PostLayoutView"]
e:I[59627,["74","static/chunks/74-31f764c22632bceb.js","32","static/chunks/32-c49bb5d7213019d7.js","4","static/chunks/4-1f47c029a7fba46f.js","810","static/chunks/810-8ebda3a4770496e8.js","659","static/chunks/659-7f246e0fb997ad2e.js","714","static/chunks/714-13c64a7806ea4ae0.js","595","static/chunks/595-60215c9a9c19277d.js","551","static/chunks/551-68df0022cc950ef8.js","800","static/chunks/800-4848173b49d8d689.js","448","static/chunks/448-62c186fb5283557d.js","918","static/chunks/app/(post)/post/%5B...slug%5D/page-80cd6d5787edd594.js"],"PostDetailPageView"]
6:["$","$Lc",null,{"children":["$","$Ld",null,{"data":{"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数 e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"storageKey":"@kyokuya/react-layout-post/#page","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(post)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]}]}]
f:["react","react reconciliation"]
2:["$","$Le",null,{"data":{"title":"React Reconciliation","titleAst":{"type":"paragraph","children":[{"type":"text","value":"React Reconciliation"}]},"slug":"/post/web/react/reconciliation","createdAt":"Jun 26, 2021","updatedAt":"Nov 03, 2021","timeToRead":"14min 46s","tags":"$f","categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"预备知识"}],"identifier":"heading-预备知识"},{"type":"heading","depth":3,"children":[{"type":"text","value":"Reconciliation"}],"identifier":"heading-reconciliation"},{"type":"paragraph","children":[{"type":"text","value":"使用 React 构建的应用，在初次渲染时 React 会调用的 "},{"type":"inlineCode","value":"render()"},{"type":"text","value":" 方法生成一棵\nReact Elements 树，在下一次 "},{"type":"inlineCode","value":"props"},{"type":"text","value":", "},{"type":"inlineCode","value":"state"},{"type":"text","value":" 发生变化时，将重新调用 "},{"type":"inlineCode","value":"render()"},{"type":"text","value":"\n方法并得到一棵新的 React Elements 树。为了高效地完成更新，需要计算出两棵树之间的差异，然后仅对差异部分应用更新。收集差异的过程被称为\n"},{"type":"linkReference","identifier":"react-reconciliation","label":"react-reconciliation","referenceType":"full","children":[{"type":"text","value":"Reconciliation"}]},{"type":"text","value":"（React@15 及其之前的协调算法又被称为\nStack Reconciler），有些地方也直接将它等同于 "},{"type":"linkReference","identifier":"react-the-diffing-algorithm","label":"react-the-diffing-algorithm","referenceType":"full","children":[{"type":"text","value":"diffing 算法"}]},{"type":"text","value":"。"}]},{"type":"paragraph","children":[{"type":"text","value":"还有一个关于 Reconciliation 的定义：React 拥有多个渲染器，如 "},{"type":"inlineCode","value":"react-dom"},{"type":"text","value":" 负责\nweb 端渲染，"},{"type":"inlineCode","value":"react-native"},{"type":"text","value":" 负责移动端渲染，它们都是依赖具体平台的，但中间有大量的逻辑是平台无关的，可以进行复用的，如协调算法（Diffing），自定义组件、state、生命周期方法和 refs 等特性；这部分共享的逻辑称为 Reconciler。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"Scheduling"}],"identifier":"heading-scheduling"},{"type":"paragraph","children":[{"type":"text","value":"在前端应用中存在多种类型的任务，如用户交互、动画、网络请求、后台计算任务等，为了得到更好的用户体验，有些任务具有更高的优先级，如动画应该优先于依赖网络请求的任务\n"},{"type":"footnoteReference","label":"1","identifier":"footnote-1"},{"type":"text","value":"，用户交互优于后台计算任务等。Scheduling 过程是给任务安排执行的顺序和时机，使得高优先级的任务优先得到执行。"}]},{"type":"paragraph","children":[{"type":"text","value":"React 使用 "},{"type":"inlineCode","value":"pull"},{"type":"text","value":" 模型来构建 UI，使得计算动作可以推迟到需要的时候再执行"},{"type":"footnoteReference","label":"2","identifier":"footnote-2"},{"type":"text","value":"，比如某些元素在屏幕外面，则可以拖迟所有与它相关的计算动作。尽管理论上 React 拥有这样的能力，但是在 Stack Reconciliation 算法中，React 使用了原生的函数栈进行递归处理，使得所有的动作都在单一工作流中，无法被打断，也就无法使用这样的能力"},{"type":"footnoteReference","label":"3","identifier":"footnote-3"},{"type":"text","value":"。"}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"计算两棵树之间的差异"}],"identifier":"heading-计算两棵树之间的差异"},{"type":"paragraph","children":[{"type":"text","value":"计算从一棵树转换成另一个树所需要的最小操作次数的问题，即便使用\n"},{"type":"linkReference","identifier":"a survey on tree edit distance and related problems","label":"A Survey on Tree Edit Distance and Related Problems","referenceType":"full","children":[{"type":"text","value":"最优算法（树的最小编辑距离算法)"}]},{"type":"text","value":"，其复杂度也达到了 "},{"type":"inlineMath","value":"O(N^3)"},{"type":"text","value":"，这样是的复杂度是无法承受的。为了快速完成两棵树的对比，\nReact 提出了一个 "},{"type":"inlineMath","value":"O(N)"},{"type":"text","value":" 的启发式算法，这基于以下两个假设："}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"两个不同类型的元素对应两棵不同的树；"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"开发者可通过 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 属性来显式地告知 React 哪些子元素在不同的渲染过程中可以保持不变；"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"上述的启发式算法实际上是通过放弃最优解而达到降低复杂度的目的："}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"其第一个假设本质上相当于“树中节点跨层级变动的可能性是很小的”（实际上也与实际情况相符），从而将差异对比限制在同层级的兄弟节点列表中，此时复杂度降为 "},{"type":"inlineMath","value":"O(N^2)"},{"type":"text","value":"\n（这是一个宽松上界）。"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"第二个假设相当于提供了一个安全舱口，让开发者自行判断哪些同级节点是可以复用的，以避免后续高昂的卸载旧树、重建新树的操作。同时，因为要求指定 "},{"type":"inlineCode","value":"key"},{"type":"text","value":"（默认情况下可以认为使用其在父节点的子节点列表中的索引作为 "},{"type":"inlineCode","value":"key"},{"type":"text","value":"），因此仅需考虑那些在旧树中相同 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 的节点；"},{"type":"strong","children":[{"type":"text","value":"这部分也是我没有想清楚的，假设新旧子元素列表长度为别为 "},{"type":"inlineMath","value":"k_1, k_2"},{"type":"text","value":"，则这个比较过程复杂度应是 "},{"type":"inlineMath","value":"O(k_1 \\cdot k_2)"},{"type":"text","value":" 的"}]},{"type":"text","value":"。"}]},{"type":"paragraph","children":[{"type":"text","value":"尽管如此，对于同层级节点的比较至少存在一个优化策略（没有看源码，不知道 React\n是否采用了此策略）："}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"不妨记两个元素列表分别为："},{"type":"inlineMath","value":"A=\\lbrace a_1, a_2, \\cdots, a_{k_1} \\rbrace"},{"type":"text","value":" 和\n"},{"type":"inlineMath","value":"B=\\lbrace b_1, b_2, \\cdots, b_{k_2} \\rbrace"}]},{"type":"paragraph","children":[{"type":"text","value":"先顺序遍历 "},{"type":"inlineMath","value":"A"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"B"},{"type":"text","value":"，检查同索引情况下（不妨记当前索引为 "},{"type":"inlineMath","value":"i"},{"type":"text","value":"），"},{"type":"inlineMath","value":"a_i"},{"type":"text","value":" 和\n"},{"type":"inlineMath","value":"b_i"},{"type":"text","value":" 的 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 是否相同，若相同，则直接复用此节点；若不相同，将\n"},{"type":"inlineMath","value":"\\lbrace b_i, b_{i+1}, \\cdots, b_{k_2} \\rbrace"},{"type":"text","value":" 建立成 "},{"type":"inlineMath","value":"<key, x>"},{"type":"text","value":" 的 hash\n表，其中 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 表示 "},{"type":"inlineMath","value":"B"},{"type":"text","value":" 的下标，然后依次检查 "},{"type":"inlineMath","value":"\\lbrace a_i, a_{i+1}, \\cdots a_{k_1} \\rbrace"},{"type":"text","value":"\n均通过 hash 表进行判断），若存在，则复用，否则新建节点。"}]},{"type":"paragraph","children":[{"type":"text","value":"这个优化将创建 hash 表的动作延迟到同层级节点 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 的顺序发生变化时进行，若同层级节点的结构保持一致，"},{"type":"inlineCode","value":"key"},{"type":"text","value":" 值没有发生改变，则相当于一次普通的遍历就完成了 diff 动作，此时总复杂度降为 "},{"type":"inlineMath","value":"O(N)"},{"type":"text","value":"。"}]},{"type":"paragraph","children":[{"type":"text","value":"上面的 hash 表使用 "},{"type":"inlineMath","value":"B"},{"type":"text","value":" 的下标作为值，是因为这样可以快速判断 "},{"type":"inlineMath","value":"a_i"},{"type":"text","value":" 对应的 "},{"type":"inlineMath","value":"b_x"},{"type":"text","value":"，其在 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 的后面还是前面，若在 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 的前面，则先进行一次移动，再进行更新。"}]}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"The Diffing Algorithm"}],"identifier":"heading-the-diffing-algorithm"},{"type":"paragraph","children":[{"type":"text","value":"在对比两棵树时，React 首先比较它们的根节点。针对根节点元素的各种比较结果，应用不同的比较策略。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"元素类型不同"}],"identifier":"heading-元素类型不同"},{"type":"paragraph","children":[{"type":"text","value":"当两个根节点为不同类型的元素时，React 会卸载原树，并从头建立一棵新树。比如一个元素从 "},{"type":"inlineCode","value":"<a>"},{"type":"text","value":" 变成 "},{"type":"inlineCode","value":"<img>"},{"type":"text","value":"，从 "},{"type":"inlineCode","value":"<Article>"},{"type":"text","value":" 变成 "},{"type":"inlineCode","value":"<Comment>"},{"type":"text","value":" 或是从 "},{"type":"inlineCode","value":"<Button>"},{"type":"text","value":" 变成\n"},{"type":"inlineCode","value":"<div>"},{"type":"text","value":"，都会触发完整的重建流程："}]},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"卸载一棵树时，所有旧 DOM 节点都会被销毁；旧组件实例的生命周期函数\n"},{"type":"inlineCode","value":"componentWillUnmount()"},{"type":"text","value":" 会得到调用"}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"建立一棵新树时，所有新的 DOM 节点会被插入到 DOM 中；旧组件实例的生命周期函数\n"},{"type":"inlineCode","value":"UNSAFE_componentWillMount()"},{"type":"text","value":" 会得到调用，紧接着，其 "},{"type":"inlineCode","value":"componentDidMount()"},{"type":"text","value":" 函数也将得到触发。所有与之前的树相关联的 state 都会被销毁。"}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"根节点下的所有组件都会按照上述方式被卸载、重建，它们的状态也都会被销毁。比如，当对比下列变更时："}]},{"type":"code","lang":"jsx","meta":"linenos","value":"<div>\n  <Counter />\n</div>\n\n<span>\n  <Counter />\n</span>\n"},{"type":"paragraph","children":[{"type":"inlineCode","value":"Counter"},{"type":"text","value":" 组件将被销毁并被重建。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"类型相同的 DOM 元素"}],"identifier":"heading-类型相同的-dom-元素"},{"type":"paragraph","children":[{"type":"text","value":"当对比两个相同类型的 React DOM 元素时，React 会保留底层的（underlying） DOM 节点，而仅对比它们的属性（DOM attributes）差异，并仅更新属性的差异部分。如："}]},{"type":"code","lang":"jsx","meta":"linenos","value":"<div className=\"before\" title=\"stuff\" />\n\n<div className=\"after\" title=\"stuff\" />\n"},{"type":"paragraph","children":[{"type":"text","value":"在对比上面两个元素时，React 知道仅需修改底层的 DOM 节点的 "},{"type":"inlineCode","value":"className"},{"type":"text","value":" 属性。"}]},{"type":"paragraph","children":[{"type":"text","value":"在更新 "},{"type":"inlineCode","value":"style"},{"type":"text","value":" 属性时，React 知道仅需更新 style 的差异部分。如："}]},{"type":"code","lang":"jsx","meta":"linenos","value":"<div style={{color: 'red', fontWeight: 'bold'}} />\n\n<div style={{color: 'green', fontWeight: 'bold'}} />\n"},{"type":"paragraph","children":[{"type":"text","value":"在转换上述两个节点时，React 知道仅需修改 "},{"type":"inlineCode","value":"color"},{"type":"text","value":" 属性，而无需修改 "},{"type":"inlineCode","value":"fontWeight"},{"type":"text","value":"\n属性。"}]},{"type":"paragraph","children":[{"type":"text","value":"在处理完当前的 DOM 节点时，React 继续对其子节点进行递归处理。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"类型相同的组件元素"}],"identifier":"heading-类型相同的组件元素"},{"type":"paragraph","children":[{"type":"text","value":"当一个组件更新时，其实例会保持不变，因此在不同的渲染过程中其 state 也将保持不变。\nReact 将更新组件实例的 props 以保证与新的元素一致，并依次调用组件的\n"},{"type":"inlineCode","value":"UNSAFE_componentWillReceiveProps()"},{"type":"text","value":"、"},{"type":"inlineCode","value":"UNSAFE_componentWillUpdate()"},{"type":"text","value":"、\n"},{"type":"inlineCode","value":"componentDidUpdate()"},{"type":"text","value":" 方法。"}]},{"type":"paragraph","children":[{"type":"text","value":"紧接着，调用组件的 "},{"type":"inlineCode","value":"render()"},{"type":"text","value":" 方法，并对其返回的结果与之前的结果递归应用\nDiffing 算法。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"处理子元素"}],"identifier":"heading-处理子元素"},{"type":"paragraph","children":[{"type":"text","value":"默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素列表，当存在差异时，生成一个 mutation。"}]},{"type":"paragraph","children":[{"type":"text","value":"因为是按照顺序遍历的，因此在末尾插入元素时，更新开销更小，因为前面的元素可以在遍历中尽可能复用；而若是在首部插入元素，更新开销最大，因为前面的所有元素都将失配。如下面的列子中，在首部插入了 "},{"type":"inlineCode","value":"<li>Connecticut</li>"},{"type":"text","value":"："}]},{"type":"code","lang":"jsx","meta":"linenos","value":"<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n"},{"type":"paragraph","children":[{"type":"text","value":"React 并不能意识到 "},{"type":"inlineCode","value":"<li>Duke</li>"},{"type":"text","value":" 和 "},{"type":"inlineCode","value":"<li>Villanova</li>"},{"type":"text","value":" 应该被复用，而是将重建它们。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"Keys"}],"identifier":"heading-keys"},{"type":"paragraph","children":[{"type":"text","value":"为了解决上述问题，React 引入了 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 属性。如下面的例子中，React 可以知道需要新插入一个 "},{"type":"inlineCode","value":"key=\"2014\""},{"type":"text","value":" 的节点，而其它两个节点都可以复用。"}]},{"type":"code","lang":"jsx","meta":"linenos","value":"<ul>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n\n<ul>\n  <li key=\"2014\">Connecticut</li>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"在 "},{"type":"linkReference","identifier":"doc-introduction","label":"doc-introduction","referenceType":"full","children":[{"type":"text","value":"Introduction"}]},{"type":"text","value":" 中提到，React 需要通过 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 进行同层级节点比较，因此 "},{"type":"inlineCode","value":"key"},{"type":"text","value":" 需要指定为一个稳定的、可预测的值。使用 "},{"type":"inlineCode","value":"Math.random()"},{"type":"text","value":" 是一个糟糕的主意。"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"linkReference","identifier":"react-terms","label":"react-terms","referenceType":"full","children":[{"type":"text","value":"Glossary of React Terms"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"react-virtual-dom","label":"react-virtual-dom","referenceType":"full","children":[{"type":"text","value":"Virtual DOM and Internals"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"react-reconciliation","label":"react-reconciliation","referenceType":"full","children":[{"type":"text","value":"Reconciliation | React Doc"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"react-scheduling","label":"react-scheduling","referenceType":"full","children":[{"type":"text","value":"Scheduling | React Doc"}]}]},{"type":"listItem","children":[{"type":"link","url":"https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e","children":[{"type":"text","value":"Inside Fiber: in-depth overview of the new reconciliation algorithm in React"}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-预备知识","contents":[{"type":"text","value":"预备知识"}],"children":[{"depth":3,"identifier":"heading-reconciliation","contents":[{"type":"text","value":"Reconciliation"}],"children":[]},{"depth":3,"identifier":"heading-scheduling","contents":[{"type":"text","value":"Scheduling"}],"children":[]}]},{"depth":2,"identifier":"heading-计算两棵树之间的差异","contents":[{"type":"text","value":"计算两棵树之间的差异"}],"children":[]},{"depth":2,"identifier":"heading-the-diffing-algorithm","contents":[{"type":"text","value":"The Diffing Algorithm"}],"children":[{"depth":3,"identifier":"heading-元素类型不同","contents":[{"type":"text","value":"元素类型不同"}],"children":[]},{"depth":3,"identifier":"heading-类型相同的-dom-元素","contents":[{"type":"text","value":"类型相同的 DOM 元素"}],"children":[]},{"depth":3,"identifier":"heading-类型相同的组件元素","contents":[{"type":"text","value":"类型相同的组件元素"}],"children":[]},{"depth":3,"identifier":"heading-处理子元素","contents":[{"type":"text","value":"处理子元素"}],"children":[]},{"depth":3,"identifier":"heading-keys","contents":[{"type":"text","value":"Keys"}],"children":[]}]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"doc-introduction":{"type":"definition","identifier":"doc-introduction","label":"doc-introduction","url":"#heading-introduction"},"react-reconciliation":{"type":"definition","identifier":"react-reconciliation","label":"react-reconciliation","url":"https://facebook.github.io/react/docs/reconciliation.html"},"react-the-diffing-algorithm":{"type":"definition","identifier":"react-the-diffing-algorithm","label":"react-the-diffing-algorithm","url":"https://reactjs.org/docs/reconciliation.html?#the-diffing-algorithm"},"react-scheduling":{"type":"definition","identifier":"react-scheduling","label":"react-scheduling","url":"https://reactjs.org/docs/design-principles.html#scheduling"},"react-terms":{"type":"definition","identifier":"react-terms","label":"react-terms","url":"https://reactjs.org/docs/glossary.html"},"react-virtual-dom":{"type":"definition","identifier":"react-virtual-dom","label":"react-virtual-dom","url":"https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom"},"a survey on tree edit distance and related problems":{"type":"definition","identifier":"a survey on tree edit distance and related problems","label":"A Survey on Tree Edit Distance and Related Problems","url":"http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf"}},"footnoteDefinitionMap":{"footnote-1":{"type":"footnoteDefinition","identifier":"footnote-1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"网络响应晚一点到没什么影响，但是动画被延时执行可能会导致掉帧"}]}]},"footnote-2":{"type":"footnoteDefinition","identifier":"footnote-2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"相对地，\n"},{"type":"inlineCode","value":"push"},{"type":"text","value":" 模型的框架在数据发生改变时会立即触发订阅者的更新操作。参见"},{"type":"linkReference","identifier":"react-scheduling","label":"react-scheduling","referenceType":"collapsed","children":[{"type":"text","value":"react-scheduling"}]}]}]},"footnote-3":{"type":"footnoteDefinition","identifier":"footnote-3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"在使用\nFiber Reconciliation 的 React@16 中，React 实现了自己的任务栈，并定义了任务的优先级，真正具有了调度任务的能力"}]}]}},"images":[],"paginationUrl":"/posts/2","prev":{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop"},"next":{"title":"背包九讲","slug":"/post/algorithm/knapsack"},"aplayerOptions":null}}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"React Reconciliation | guanghechen"}],["$","meta","3",{"name":"description","content":"React Reconciliation"}],["$","meta","4",{"name":"application-name","content":"guanghechen"}],["$","link","5",{"rel":"author","href":"https://github.com/guanghechen"}],["$","meta","6",{"name":"author","content":"光和尘"}],["$","link","7",{"rel":"icon","href":"/favicon.png"}],["$","meta","8",{"name":"next-size-adjust"}]]
1:null
