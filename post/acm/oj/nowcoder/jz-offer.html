<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta name="application-name" content="guanghechen"/><meta name="apple-mobile-web-app-title" content="光和尘"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="default"/><meta name="description" content="Guanghechen&#x27;s personal site"/><meta name="format-detection" content="telephone=no"/><meta name="mobile-web-app-capable" content="yes"/><meta name="msapplication-config" content="/icons/browserconfig.xml"/><meta name="msapplication-TileColor" content="#2B5797"/><meta name="msapplication-tap-highlight" content="no"/><meta name="theme-color" content="#a2466c"/><link rel="manifest" href="/manifest.json"/><link rel="shortcut icon" href="/favicon.png"/><meta property="og:type" content="website"/><meta property="og:title" content="光和尘"/><meta property="og:description" content="光和尘的个人站点"/><meta property="og:site_name" content="guanghechen"/><meta property="og:url" content="https://preview.me.guanghechen.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css2?family=Roboto+Mono&amp;display=swap"/><link rel="preload" href="/_next/static/css/f6e2a3135d0744b2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f6e2a3135d0744b2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2159a4b672631e08.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2159a4b672631e08.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-991a0570552e5511.js" defer=""></script><script src="/_next/static/chunks/framework-18c7e6fcf99e5daa.js" defer=""></script><script src="/_next/static/chunks/main-881697fc9a01f7ab.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f19a52ce728086a3.js" defer=""></script><script src="/_next/static/chunks/554-0ae36613042b30fd.js" defer=""></script><script src="/_next/static/chunks/724-59b1a7f2cbe70306.js" defer=""></script><script src="/_next/static/chunks/997-b0975c06e066394a.js" defer=""></script><script src="/_next/static/chunks/865-6ac09b2c0ad0941c.js" defer=""></script><script src="/_next/static/chunks/157-d32c38b647fb3754.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5B...slug%5D-dd6bebed7db195be.js" defer=""></script><script src="/_next/static/ibuFGMOdHg4Yu7IeAV1Yh/_buildManifest.js" defer=""></script><script src="/_next/static/ibuFGMOdHg4Yu7IeAV1Yh/_ssgManifest.js" defer=""></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap"/></head><body><div id="__next"><div class="css-pwdx5x"><style data-emotion="css z01bqi animation-61bdi0">.css-z01bqi{display:inline-block;color:#1976d2;-webkit-animation:animation-61bdi0 1.4s linear infinite;animation:animation-61bdi0 1.4s linear infinite;}@-webkit-keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-61bdi0{0%{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style><span class="MuiCircularProgress-root MuiCircularProgress-indeterminate MuiCircularProgress-colorPrimary css-z01bqi" style="width:40px;height:40px" role="progressbar"><style data-emotion="css 13o7eu2">.css-13o7eu2{display:block;}</style><svg class="MuiCircularProgress-svg css-13o7eu2" viewBox="22 22 44 44"><style data-emotion="css 14891ef animation-1p2h4ri">.css-14891ef{stroke:currentColor;stroke-dasharray:80px,200px;stroke-dashoffset:0;-webkit-animation:animation-1p2h4ri 1.4s ease-in-out infinite;animation:animation-1p2h4ri 1.4s ease-in-out infinite;}@-webkit-keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}@keyframes animation-1p2h4ri{0%{stroke-dasharray:1px,200px;stroke-dashoffset:0;}50%{stroke-dasharray:100px,200px;stroke-dashoffset:-15px;}100%{stroke-dasharray:100px,200px;stroke-dashoffset:-125px;}}</style><circle class="MuiCircularProgress-circle MuiCircularProgress-circleIndeterminate css-14891ef" cx="44" cy="44" r="20.2" fill="none" stroke-width="3.6"></circle></svg></span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"剑指offer 解题报告","description":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","createdAt":"Jul 15, 2021","updatedAt":"Oct 06, 2022","timeToRead":"21min 10s","tags":["专题训练","解题报告"],"categories":[],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"前言"}],"identifier":"heading-前言"},{"type":"paragraph","children":[{"type":"text","value":"这两天奶奶做手术，我在医院里陪护，奶奶不会说普通话所以只好一直陪在旁边。实在有些闲得慌，正好在刷知乎的时候看到了《剑指offer》的推荐，搜了下发现有 OJ 收录了原书中的题目，于是开始尝试手机写代码23333（没有带电脑）。 强迫症晚期，一上手就非要做完不可，还好题目量少。使用低效率的方式做一件并不紧要的事情实在是太浪费生命了。（不过也有人说，生命就是用来浪费的2333"}]},{"type":"paragraph","children":[{"type":"text","value":"为了"},{"type":"delete","children":[{"type":"emphasis","children":[{"type":"text","value":"偷懒"}]}]},{"type":"text","value":"节约篇幅，将过于基础的题放在了 "},{"type":"linkReference","identifier":"heading-附录","label":"heading-附录","referenceType":"full","children":[{"type":"text","value":"附录"}]},{"type":"text","value":" 中。"}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"01 二维数组的查找"}],"identifier":"heading-01-二维数组的查找"},{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-01","label":"problem-01","referenceType":"full","children":[{"type":"text","value":"题目链接"}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题意简述"}],"identifier":"heading-题意简述"},{"type":"paragraph","children":[{"type":"text","value":"有一个 "},{"type":"inlineMath","value":"R \\times C"},{"type":"text","value":" 的矩阵，每行从左至右数值递增，每列从上至下数值递增，求矩阵中是否包含给定的数值。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目简析"}],"identifier":"heading-题目简析"},{"type":"paragraph","children":[{"type":"text","value":"注意到矩阵中任意一个子矩阵仍然满足此特性，则可以二分子矩阵，直到子矩阵的大小为\n"},{"type":"inlineMath","value":"1 \\times 1"},{"type":"text","value":". 具体地，若当前所检查的子矩阵为 "},{"type":"inlineMath","value":"(l_1, r_1, l_2, r_2)"},{"type":"text","value":"，取位置\n"},{"type":"inlineMath","value":"\\displaystyle \\left(x = \\left\\lfloor\\frac{l_1+l_2}{2}\\right\\rfloor, y = \\left\\lfloor\\frac{r_1+r_2}{2}\\right\\rfloor\\right)"},{"type":"text","value":"，则："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"若目标值恰好等于此位置上的值，则直接返回 "},{"type":"inlineCode","value":"true"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"text","value":"否则，若目标值小于此位置上的值，则其只可能存在于子矩阵 "},{"type":"inlineMath","value":"(l_1, x, l_2, y)"},{"type":"text","value":" 中；"}]},{"type":"listItem","children":[{"type":"text","value":"否则，其只可能存在于子矩阵 "},{"type":"inlineMath","value":"(x + 1, r_1, l_2, r_2)"},{"type":"text","value":" 或子矩阵 "},{"type":"inlineMath","value":"(l_1, r_1, y + 1, r_2)"},{"type":"text","value":" 中"}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"时间复杂度： "},{"type":"inlineMath","value":"O(\\log R \\times \\log C)"}]},{"type":"listItem","children":[{"type":"text","value":"额外空间复杂度： "},{"type":"inlineMath","value":"O(\\log R \\times \\log C)"}]}]},{"type":"code","lang":"typescript","meta":"title=\"01.ts\" sourcefile=\"./01.ts\" maxlines=20 collapsed linenos","value":"export function Find(target: number, array: number[][]): boolean {\n  if (array.length \u003c= 0) return false\n  if (array[0].length \u003c= 0) return false\n\n  const R = array.length\n  const C = array[0].length\n  return search(0, R, 0, C)\n\n  function search(lft1: number, rht1: number, lft2: number, rht2: number): boolean {\n    if (lft1 \u003e= R || lft2 \u003e= C) return false\n    if (lft1 \u003e rht1 || lft2 \u003e rht2) return false\n    if (lft1 === rht1 \u0026\u0026 lft2 === rht2) return false\n\n    const x = (lft1 + rht1) \u003e\u003e 1\n    const y = (lft2 + rht2) \u003e\u003e 1\n    const z = array[x][y]\n\n    if (target === z) return true\n    if (target \u003c z) return search(lft1, x, lft2, y)\n    return search(x + 1, rht1, lft2, rht2) || search(lft1, rht1, y + 1, rht2)\n  }\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"04 重建二叉树"}],"identifier":"heading-04-重建二叉树"},{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-04","label":"problem-04","referenceType":"full","children":[{"type":"text","value":"题目链接"}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目简述"}],"identifier":"heading-题目简述"},{"type":"paragraph","children":[{"type":"text","value":"给定一棵 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 个节点的二叉树的先序遍历和中序遍历结果，重建二叉树。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目简析"}],"identifier":"heading-题目简析-2"},{"type":"paragraph","children":[{"type":"text","value":"先序遍历的第一个节点为根节点，不妨记为 "},{"type":"inlineMath","value":"x"},{"type":"text","value":"，找到中序遍历中 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 的位置，不妨记为\n"},{"type":"inlineMath","value":"p"},{"type":"text","value":"，则中序遍历序列中："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineMath","value":"p"},{"type":"text","value":" 之前所有的节点都为 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 的左子树中的节点；"}]},{"type":"listItem","children":[{"type":"text","value":"而 "},{"type":"inlineMath","value":"p"},{"type":"text","value":" 之后的所有节点都为 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 的右子树的节点；"}]}]},{"type":"paragraph","children":[{"type":"text","value":"又因为无论先序遍历还是后序遍历都是先访问完左子树再访问右子树的，所以先序遍历序列中前 "},{"type":"inlineMath","value":"p"},{"type":"text","value":" 个元素同样是 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 的左子树中的节点，之后递归处理即可。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现-2"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"时间复杂度： "},{"type":"inlineMath","value":"O(N)"}]},{"type":"listItem","children":[{"type":"text","value":"额外空间复杂度： "},{"type":"inlineMath","value":"O(N)"}]}]},{"type":"code","lang":"typescript","meta":"title=\"04.ts\" sourcefile=\"./04.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function reConstructBinaryTree(pre: number[], vin: number[]): TreeNode {\n  if (pre.length === 0 || pre.length !== vin.length) return null\n  const tree = build(0, pre.length - 1, 0, vin.length - 1)\n  return tree\n\n  function build(lft1: number, rht1: number, lft2: number, rht2: number): TreeNode {\n    const x = pre[lft1]\n\n    // 找到\n    let p = lft2\n    for (; p \u003c= rht2; ++p) if (vin[p] === x) break\n\n    const o: TreeNode = {\n      val: x,\n      left: lft2 \u003c p ? build(lft1 + 1, lft1 + p - lft2, lft2, p - 1) : null,\n      right: rht2 \u003e p ? build(lft1 + p - lft2 + 1, rht1, p + 1, rht2) : null,\n    }\n    return o\n  }\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"06 旋转数组的最小数字"}],"identifier":"heading-06-旋转数组的最小数字"},{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-06","label":"problem-06","referenceType":"full","children":[{"type":"text","value":"题目链接"}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目简述"}],"identifier":"heading-题目简述-2"},{"type":"paragraph","children":[{"type":"text","value":"有一个长度为 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 的非严格递增序列 "},{"type":"inlineMath","value":"A=\\lbrace a_1,a_2,\\cdots,a_N \\rbrace"},{"type":"text","value":"，将其前面 "},{"type":"inlineMath","value":"K"},{"type":"text","value":" 个（"},{"type":"inlineMath","value":"0 \\leqslant K \u003c N"},{"type":"text","value":"）个元素取出并按顺序放在原序列的末尾，得到新序列"}]},{"type":"math","value":"B=\\lbrace b_1, b_2, \\cdots, b_N\\rbrace = \\lbrace a_{K+1},a_{K+2},\\cdots,a_N, a_1, a_2, \\cdots, a_K \\rbrace\n"},{"type":"paragraph","children":[{"type":"text","value":"求 "},{"type":"inlineMath","value":"B"},{"type":"text","value":" 中的最小值。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目简析"}],"identifier":"heading-题目简析-3"},{"type":"paragraph","children":[{"type":"text","value":"先考虑简化版问题。若原数列严格递增，则存在两种情况："}]},{"type":"list","ordered":true,"orderType":"1","start":1,"marker":46,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineMath","value":"b_1 \u003c b_N"},{"type":"text","value":"，即 "},{"type":"inlineMath","value":"B"},{"type":"text","value":" 单调递增，此时 "},{"type":"inlineMath","value":"b_1"},{"type":"text","value":" 即为所求答案"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"b_1 \u003e b_N"},{"type":"text","value":"，即 "},{"type":"inlineMath","value":"B"},{"type":"text","value":" 先上升后突降再上升，取 "},{"type":"inlineMath","value":"x = \\left\\lfloor\\frac{1 + N}{2}\\right\\rfloor"},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"若 "},{"type":"inlineMath","value":"b_x \u003c b_N"},{"type":"text","value":"，则答案落在 "},{"type":"inlineMath","value":"\\lbrace b_1, b_2, \\cdots b_x\\rbrace"},{"type":"text","value":" 中"}]},{"type":"listItem","children":[{"type":"text","value":"否则，即 "},{"type":"inlineMath","value":"b_x \u003e b_N"},{"type":"text","value":"，则答案落在 "},{"type":"inlineMath","value":"\\lbrace b_{x+1}, b_{x+2}, \\cdots, c_N\\rbrace"},{"type":"text","value":" 中"}]}]}]}]},{"type":"paragraph","children":[{"type":"text","value":"原问题在简化版问题基础上的第二种情况种多了一种可能： "},{"type":"inlineMath","value":"b_1 = b_N"},{"type":"text","value":"。此时取 "},{"type":"inlineMath","value":"x=N-1"},{"type":"text","value":" 即可。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现-3"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"时间复杂度： "},{"type":"inlineMath","value":"O(\\log N)"},{"type":"text","value":" （极端情况下可退化为 "},{"type":"inlineMath","value":"O(N)"},{"type":"text","value":"）"}]},{"type":"listItem","children":[{"type":"text","value":"额外空间复杂度： "},{"type":"inlineMath","value":"O(1)"}]}]},{"type":"code","lang":"typescript","meta":"title=\"06.ts\" sourcefile=\"./06.ts\" maxlines=20 collapsed linenos","value":"export function minNumberInRotateArray(rotateArray: number[]): number {\n  const A: number[] = rotateArray\n  if (A.length \u003c= 0) return 0\n\n  let lft = 0\n  let rht = A.length\n  while (lft \u003c rht) {\n    const last: number = A[rht - 1]\n    if (lft + 1 === rht || last \u003e A[lft]) return A[lft]\n\n    const mid: number = (lft + rht) \u003e\u003e 1\n    const x: number = A[mid]\n    if (mid + 1 === rht || x \u003c last) {\n      // 因为前面已经判断过区间首元素和尾元素，所以此时\n      // mid 不可能和 lft 相等\n      if (x \u003c A[mid - 1]) return x\n\n      rht = mid\n    } else if (x === last) rht -= 1\n    // 复杂度退化的情况\n    else lft = mid + 1\n  }\n  return A[rht - 1]\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"23 二叉搜索树的后序遍历序列"}],"identifier":"heading-23-二叉搜索树的后序遍历序列"},{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-23","label":"problem-23","referenceType":"full","children":[{"type":"text","value":"题目链接"}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目描述"}],"identifier":"heading-题目描述"},{"type":"paragraph","children":[{"type":"text","value":"判断给定的数组 "},{"type":"inlineMath","value":"A=\\lbrace a_1, a_2, \\cdots, a_N \\rbrace"},{"type":"text","value":" 是否为一棵二叉搜索树的后序遍历结果。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"题目简析"}],"identifier":"heading-题目简析-4"},{"type":"paragraph","children":[{"type":"text","value":"后续遍历中，最后一个元素为根节点，这启发我们逆序遍历 "},{"type":"inlineMath","value":"A"},{"type":"text","value":" 进行判断。又因为原数组是一棵二叉搜索的遍历结果，即右子树的最小值总比左子树及根节点值都要大，事实上我们仅检验这一点就可以判断给定数组是否为某棵二叉搜索树的后序遍历结果了。"}]},{"type":"paragraph","children":[{"type":"text","value":"算法的核心思想是沿着树中最右侧的链遍历（访问过的节点可标记为删除）的方式去遍历整棵树，则每次要进入一个左子树时，里面元素的值不得超过当前遍最右侧链的最大值，否则其不为一个有效的二叉搜索树后序遍历结果。树上的最右侧链可以使用一个栈进行维护，不难发现其是一个严格递增的单调栈。每当树上某个节点的右子树访问完后，将其在栈中对应的元素从栈中移除，不难发现，移除操作总是弹出栈顶元素。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现-4"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"时间复杂度： "},{"type":"inlineMath","value":"O(N)"}]},{"type":"listItem","children":[{"type":"text","value":"额外空间复杂度： "},{"type":"inlineMath","value":"O(N)"}]}]},{"type":"code","lang":"typescript","meta":"title=\"23.ts\" sourcefile=\"./23.ts\" maxlines=20 collapsed linenos","value":"export function VerifySquenceOfBST(sequence: number[]): boolean {\n  if (sequence.length \u003c= 0) return false\n\n  const stack: number[] = []\n  let maxOfTree: number = Number.MAX_SAFE_INTEGER\n  for (let i = sequence.length - 1; i \u003e -1; --i) {\n    const x = sequence[i]\n    if (x \u003e= maxOfTree) return false\n\n    // 栈顶元素为树中最大的节点，当遇到一个比栈顶元素小的节点时，\n    // 说明此后不应该再遇到比栈顶元素大的元素(因为是后续遍历的逆序，\n    // 所以我们会先访问完右子树再访问左子树)，同时可以将栈中所以大于\n    // 它的元素一并删除(所以这还是个单调栈)。\n    while (stack.length \u003e 0 \u0026\u0026 x \u003c stack[stack.length - 1]) {\n      maxOfTree = stack.pop()\n    }\n\n    stack.push(x)\n  }\n  return true\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"附录"}],"identifier":"heading-附录"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-02","label":"problem-02","referenceType":"full","children":[{"type":"text","value":"#02 替换空格"}]},{"type":"text","value":"： 字符串替换"}]},{"type":"code","lang":"typescript","meta":"title=\"02.ts\" sourcefile=\"./02.ts\" maxlines=20 collapsed linenos","value":"export function replaceSpace(text: string): string {\n  return text.replace(/[ ]/, '%20')\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-03","label":"problem-03","referenceType":"full","children":[{"type":"text","value":"#03 从尾到头打印链表"}]},{"type":"text","value":"： 栈的应用"}]},{"type":"code","lang":"typescript","meta":"title=\"03.ts\" sourcefile=\"./03.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nconst stack: number[] = []\n\nexport function printListFromTailToHead(head: ListNode): number[] {\n  let tot = 0\n  for (let o: ListNode = head; o; o = o.next) stack[tot++] = o.val\n\n  const result: number[] = new Array(tot)\n  for (let i = 0; tot--; ++i) result[i] = stack[tot]\n  return result\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-05","label":"problem-05","referenceType":"full","children":[{"type":"text","value":"#05 用两个栈实现队列"}]},{"type":"text","value":"： 栈和队列的应用"}]},{"type":"code","lang":"typescript","meta":"title=\"05.ts\" sourcefile=\"./05.ts\" maxlines=20 collapsed linenos","value":"const s1: number[] = []\nconst s2: number[] = []\n\nexport function push(node: number) {\n  s1.push(node)\n}\n\nexport function pop(): number | undefined {\n  // 如果 s2 为空，则将栈 s1 中的内容弹出并压入栈 s2 中\n  if (s2.length \u003c= 0) {\n    while (s1.length \u003e 0) s2.push(s1.pop())\n  }\n\n  // 从 s2 中弹栈的值遵循原序列的先入先出规则\n  return s2.pop()\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-07","label":"problem-07","referenceType":"full","children":[{"type":"text","value":"#07 斐波那契数列"}]},{"type":"text","value":"： 递推"}]},{"type":"math","value":"  f(n) = \\left\\lbrace\\begin{aligned}\n    \u00260, \u0026n \\leqslant 0\\\\\n    \u00261, \u0026n = 1\\\\\n    \u00261, \u0026n = 2\\\\\n    \u0026f(n-1) + f(n-2), \u0026n \\geqslant 3\\\\\n  \\end{aligned}\\right.\n"},{"type":"code","lang":"typescript","meta":"title=\"07.ts\" sourcefile=\"./07.ts\" maxlines=20 collapsed linenos","value":"export function Fibonacci(n: number): number {\n  if (n \u003c= 1) return n\n\n  let a = 0\n  let b = 1\n  let c = 1\n  for (let i = 3; i \u003c= n; ++i) {\n    a = b\n    b = c\n    c = a + b\n  }\n  return c\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-08","label":"problem-08","referenceType":"full","children":[{"type":"text","value":"#08 跳台阶"}]},{"type":"text","value":"： 递推"}]},{"type":"math","value":"  f(n) = \\left\\lbrace\\begin{aligned}\n    \u00260, \u0026n \\leqslant 0\\\\\n    \u00261, \u0026n = 1\\\\\n    \u00262, \u0026n = 2\\\\\n    \u0026f(n-1) + f(n-2), \u0026n \\geqslant 3\\\\\n  \\end{aligned}\\right.\n"},{"type":"code","lang":"typescript","meta":"title=\"08.ts\" sourcefile=\"./08.ts\" maxlines=20 collapsed linenos","value":"export function jumpFloor(n: number): number {\n  if (n \u003c= 0) return 0\n  if (n \u003c= 2) return n\n\n  let a = 1\n  let b = 2\n  let c = 3\n  for (let i = 3; i \u003c n; ++i) {\n    a = b\n    b = c\n    c = a + b\n  }\n  return c\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-09","label":"problem-09","referenceType":"full","children":[{"type":"text","value":"#09 跳台阶扩展问题"}]},{"type":"text","value":"： 递推"}]},{"type":"math","value":"  f(n) = \\left\\lbrace\\begin{aligned}\n    \u00260, \u0026n \\leqslant 0\\\\\n    \u00262^{n-1}, \u0026n \u003e 0\\\\\n  \\end{aligned}\\right.\n"},{"type":"code","lang":"typescript","meta":"title=\"09.ts\" sourcefile=\"./09.ts\" maxlines=20 collapsed linenos","value":"export function jumpFloorII(n: number): number {\n  if (n \u003c= 0) return 0\n  return 1 \u003c\u003c (n - 1)\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-10","label":"problem-10","referenceType":"full","children":[{"type":"text","value":"#10 跳台阶扩展问题"}]},{"type":"text","value":"： 递推"}]},{"type":"math","value":"  f(n) = \\left\\lbrace\\begin{aligned}\n    \u00260, \u0026n \\leqslant 0\\\\\n    \u00261, \u0026n = 1\\\\\n    \u00262, \u0026n = 2\\\\\n    \u0026f(n-1) + f(n-2), \u0026n \\geqslant 3\\\\\n  \\end{aligned}\\right.\n"},{"type":"code","lang":"typescript","meta":"title=\"10.ts\" sourcefile=\"./10.ts\" maxlines=20 collapsed linenos","value":"export function rectCover(n: number): number {\n  if (n \u003c= 0) return 0\n  if (n \u003c= 2) return n\n\n  let a = 1\n  let b = 2\n  let c = 3\n  for (let i = 3; i \u003c n; ++i) {\n    a = b\n    b = c\n    c = a + b\n  }\n  return c\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-11","label":"problem-11","referenceType":"full","children":[{"type":"text","value":"#11 二进制中 1 的个数"}]},{"type":"text","value":"： 数学，二进制"}]},{"type":"code","lang":"typescript","meta":"title=\"11.ts\" sourcefile=\"./11.ts\" maxlines=20 collapsed linenos","value":"// 循环判断\nexport function NumberOf1(n: number): number {\n  let result = 0\n  for (n; n; n \u003e\u003e\u003e= 1) {\n    if (n \u0026 1) result += 1\n  }\n  return result\n}\n\n// 使用 lowbit\nexport function NumberOf1_2(n: number): number {\n  let result = 0\n  for (n; n; n ^= n \u0026 -n) result += 1\n  return result\n}\n\n// 使用偏移累加\nexport function NumberOf1_3(n: number): number {\n  let x = (n \u0026 0x55555555) + ((n \u003e\u003e 1) \u0026 0x55555555)\n  x = (x \u0026 0x33333333) + ((x \u003e\u003e 2) \u0026 0x33333333)\n  x = (x \u0026 0x0f0f0f0f) + ((x \u003e\u003e 4) \u0026 0x0f0f0f0f)\n  x = (x \u0026 0x00ff00ff) + ((x \u003e\u003e 8) \u0026 0x00ff00ff)\n  x = (x \u0026 0x0000ffff) + ((x \u003e\u003e 16) \u0026 0x0000ffff)\n  return x\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-12","label":"problem-12","referenceType":"full","children":[{"type":"text","value":"#12 数值的整数次方"}]},{"type":"text","value":"： 数学，快速幂"}]},{"type":"code","lang":"typescript","meta":"title=\"12.ts\" sourcefile=\"./12.ts\" maxlines=20 collapsed linenos","value":"export function Power(base: number, exponent: number): number {\n  if (base === 0) return 0\n\n  let n = Math.abs(exponent)\n  let result = 1\n  for (let x = base; n \u003e 0; n \u003e\u003e= 1, x = x * x) {\n    if (n \u0026 1) result *= x\n  }\n  return exponent \u003c 0 ? 1 / result : result\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-13","label":"problem-13","referenceType":"full","children":[{"type":"text","value":"#13 调整数组顺序使奇数位于偶数前面"}]},{"type":"text","value":"： 数学，二进制"}]},{"type":"code","lang":"typescript","meta":"title=\"13.ts\" sourcefile=\"./13.ts\" maxlines=20 collapsed linenos","value":"export function reOrderArray(nums: number[]): number[] {\n  const A: number[] = []\n  const B: number[] = []\n  for (const x of nums) {\n    if (x \u0026 1) A.push(x)\n    else B.push(x)\n  }\n  return A.concat(B)\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-14","label":"problem-14","referenceType":"full","children":[{"type":"text","value":"#14 链表中倒数最后K个节点"}]},{"type":"text","value":"： 链表，双指针"}]},{"type":"code","lang":"typescript","meta":"title=\"14.ts\" sourcefile=\"./14.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nexport function FindKthToTail(pHead: ListNode, k: number) {\n  let faster = pHead\n  let slower = pHead\n\n  // 快指针先走 k 步\n  for (let step = 0; step \u003c k; ++step) {\n    if (faster == null) return null\n    faster = faster.next\n  }\n\n  // 两个指针一起走\n  while (faster != null) {\n    faster = faster.next\n    slower = slower.next\n  }\n  return slower\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-15","label":"problem-15","referenceType":"full","children":[{"type":"text","value":"#15 反转链表"}]},{"type":"text","value":"： 链表"}]},{"type":"code","lang":"typescript","meta":"title=\"15.ts\" sourcefile=\"./15.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nexport function ReverseList(pHead: ListNode): ListNode {\n  if (pHead == null) return null\n\n  let x: ListNode | null = pHead\n  let y: ListNode | null = pHead.next\n  while (y != null) {\n    const z = y.next\n    y.next = x\n    x = y\n    y = z\n  }\n  pHead.next = null\n  return x\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-16","label":"problem-16","referenceType":"full","children":[{"type":"text","value":"#16 合并两个排序的链表"}]},{"type":"text","value":"： 归并排序"}]},{"type":"code","lang":"typescript","meta":"title=\"16.ts\" sourcefile=\"./16.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nexport function Merge(pHead1: ListNode, pHead2: ListNode): ListNode {\n  const fakeRoot: ListNode = {\n    val: -1,\n    next: null,\n  }\n\n  let x: ListNode = pHead1\n  let y: ListNode = pHead2\n  let z: ListNode = fakeRoot\n  for (; x != null \u0026\u0026 y != null; z = z.next) {\n    if (x.val \u003c y.val) {\n      z.next = x\n      x = x.next\n    } else {\n      z.next = y\n      y = y.next\n    }\n  }\n\n  if (x != null) z.next = x\n  if (y != null) z.next = y\n  return fakeRoot.next\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-17","label":"problem-17","referenceType":"full","children":[{"type":"text","value":"#17 树的子结构"}]},{"type":"text","value":"： 二叉树，递归"}]},{"type":"code","lang":"typescript","meta":"title=\"17.ts\" sourcefile=\"./17.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function HasSubtree(pRoot1: TreeNode, pRoot2: TreeNode): boolean {\n  if (pRoot1 == null || pRoot2 == null) return false\n  if (isSubTree(pRoot1, pRoot2)) return true\n  if (pRoot1.left != null \u0026\u0026 HasSubtree(pRoot1.left, pRoot2)) return true\n  if (pRoot1.right != null \u0026\u0026 HasSubtree(pRoot1.right, pRoot2)) return true\n  return false\n}\n\n// 检查 v 是否为 u 的子树，且它们根节点相同\nfunction isSubTree(u: TreeNode, v: TreeNode): boolean {\n  if (u.val !== v.val) return false\n  if (v.left != null) {\n    if (u.left == null || !isSubTree(u.left, v.left)) return false\n  }\n  if (v.right != null) {\n    if (u.right == null || !isSubTree(u.right, v.right)) return false\n  }\n  return true\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-18","label":"problem-18","referenceType":"full","children":[{"type":"text","value":"#18 二叉树的镜像"}]},{"type":"text","value":"： 二叉树，递归"}]},{"type":"code","lang":"typescript","meta":"title=\"18.ts\" sourcefile=\"./18.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function Mirror(pRoot: TreeNode): TreeNode {\n  if (pRoot == null) return null\n  const x = pRoot.left\n  pRoot.left = pRoot.right\n  pRoot.right = x\n  Mirror(pRoot.left)\n  Mirror(pRoot.right)\n  return pRoot\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-19","label":"problem-19","referenceType":"full","children":[{"type":"text","value":"#19 顺时针打印矩阵"}]},{"type":"text","value":"： 模拟"}]},{"type":"code","lang":"typescript","meta":"title=\"19.ts\" sourcefile=\"./19.ts\" maxlines=20 collapsed linenos","value":"export function printMatrix(matrix: number[][]): number[] {\n  if (matrix.length \u003c= 0) return []\n  if (matrix[0].length \u003c= 0) return []\n\n  const R = matrix.length\n  const C = matrix[0].length\n\n  const result: number[] = []\n  const totalRound = Math.min(R, C) \u003e\u003e 1\n  for (let round = 0; round \u003c totalRound; ++round) {\n    right(round, round, C - round)\n    down(C - round - 1, round + 1, R - round)\n    left(R - round - 1, C - round - 2, round - 1)\n    up(round, R - round - 2, round)\n  }\n\n  if (Math.min(R, C) \u0026 1) {\n    if (C \u003e R) {\n      right(totalRound, totalRound, C - totalRound)\n    } else {\n      down(totalRound, totalRound, R - totalRound)\n    }\n  }\n  return result\n\n  function right(row: number, x: number, y: number): void {\n    for (let i = x; i \u003c y; ++i) {\n      result.push(matrix[row][i])\n    }\n  }\n\n  function down(col: number, x: number, y: number): void {\n    for (let i = x; i \u003c y; ++i) {\n      result.push(matrix[i][col])\n    }\n  }\n\n  function left(row: number, x: number, y: number): void {\n    for (let i = x; i \u003e y; --i) {\n      result.push(matrix[row][i])\n    }\n  }\n\n  function up(col: number, x: number, y: number): void {\n    for (let i = x; i \u003e y; --i) {\n      result.push(matrix[i][col])\n    }\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-20","label":"problem-20","referenceType":"full","children":[{"type":"text","value":"#20 包含min函数的栈"}]},{"type":"text","value":"： 单调栈"}]},{"type":"code","lang":"typescript","meta":"title=\"20.ts\" sourcefile=\"./20.ts\" maxlines=20 collapsed linenos","value":"const nums: number[] = [] // 普通栈\nconst stack: number[] = [] // 单调栈\n\nexport function push(node: number): void {\n  nums.push(node)\n\n  // 允许放入和栈顶元素相等的元素是为了避免在弹出元素时做特判\n  if (stack.length \u003c= 0 || stack[stack.length - 1] \u003e= node) {\n    stack.push(node)\n  }\n}\n\nexport function pop(): void {\n  const x = nums.pop()\n\n  // 单调栈中栈顶元素最小，如果 nums 弹出的元素和单调栈中的栈顶元素相同，\n  // 则单调栈中也同时弹出元素\n  if (x != null \u0026\u0026 x === min()) stack.pop()\n}\n\nexport function top(): number | undefined {\n  return nums.length \u003e 0 ? nums[nums.length - 1] : undefined\n}\n\nexport function min(): number {\n  return stack[stack.length - 1]\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-21","label":"problem-21","referenceType":"full","children":[{"type":"text","value":"#21 栈的压入、弹出序列"}]},{"type":"text","value":"： 栈，模拟"}]},{"type":"paragraph","children":[{"type":"text","value":"根据 "},{"type":"inlineCode","value":"push"},{"type":"text","value":" 序列按顺序进行压栈，每次压完栈后根据 "},{"type":"inlineCode","value":"pop"},{"type":"text","value":" 序列检查是否要弹栈"}]},{"type":"code","lang":"typescript","meta":"title=\"21.ts\" sourcefile=\"./21.ts\" maxlines=20 collapsed linenos","value":"export function IsPopOrder(pushV: number[], popV: number[]): boolean {\n  const stack: number[] = []\n  let i = 0\n  let j = 0\n  for (const x of pushV) {\n    const y = popV[j]\n    if (x === y) j += 1\n    else stack[i++] = x\n\n    while (i \u003e 0) {\n      if (stack[i - 1] !== popV[j]) break\n      i -= 1\n      j += 1\n    }\n  }\n  return i === 0\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-22","label":"problem-22","referenceType":"full","children":[{"type":"text","value":"#22 从上往下打印二叉树"}]},{"type":"text","value":"： 二叉树，BFS"}]},{"type":"code","lang":"typescript","meta":"title=\"22.ts\" sourcefile=\"./22.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function PrintFromTopToBottom(root: TreeNode): number[] {\n  if (root == null) return []\n  const Q: TreeNode[] = []\n  const result: number[] = []\n  Q.push(root)\n  while (Q.length \u003e 0) {\n    const x = Q.shift()\n    result.push(x.val)\n    if (x.left) Q.push(x.left)\n    if (x.right) Q.push(x.right)\n  }\n  return result\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-24","label":"problem-24","referenceType":"full","children":[{"type":"text","value":"#24 二叉树中和为某一值的路径"}]},{"type":"text","value":"： 二叉树，DFS"}]},{"type":"code","lang":"typescript","meta":"title=\"24.ts\" sourcefile=\"./24.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function FindPath(root: TreeNode, target: number): number[][] {\n  if (root == null) return []\n  const results: number[][] = []\n  const tmp: number[] = []\n  let total = 0\n  f(root, 0)\n  return results\n\n  function f(o: TreeNode, cur: number): void {\n    tmp[cur] = o.val\n    total += o.val\n    if (o.left == null \u0026\u0026 o.right == null) {\n      if (total === target) {\n        results.push(tmp.slice(0, cur + 1))\n      }\n    } else {\n      if (o.left != null) f(o.left, cur + 1)\n      if (o.right != null) f(o.right, cur + 1)\n    }\n    total -= o.val\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-25","label":"problem-25","referenceType":"full","children":[{"type":"text","value":"#25 复杂链表的复制"}]},{"type":"text","value":"： 链表，哈希表、Map"}]},{"type":"code","lang":"typescript","meta":"title=\"25.ts\" sourcefile=\"./25.ts\" maxlines=20 collapsed linenos","value":"interface RandomListNode {\n  label: number\n  next: RandomListNode | null\n  random: RandomListNode | null\n}\n\nexport function Clone(o: RandomListNode): RandomListNode {\n  if (o == null) return null\n  const map = new Map()\n  const root = { ...o }\n  for (let u = root, v = o; v != null; u = u.next, v = v.next) {\n    map.set(v, u)\n    if (v.next != null) {\n      let w = map.get(v.next)\n      if (w != null) {\n        u.next = w\n        break\n      }\n      u.next = { ...v.next }\n    }\n  }\n  for (let u = root; u != null; u = u.next) {\n    const r = map.get(u.random)\n    u.random = r === undefined ? null : r\n  }\n  return root\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-26","label":"problem-26","referenceType":"full","children":[{"type":"text","value":"#26 二叉搜索树与双向链表"}]},{"type":"text","value":"： 二叉树，中序遍历"}]},{"type":"code","lang":"typescript","meta":"title=\"26.ts\" sourcefile=\"./26.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function Convert(pRootOfTree: TreeNode): TreeNode {\n  if (pRootOfTree == null) return null\n\n  f(null, pRootOfTree)\n  let root = pRootOfTree\n  while (root.left != null) root = root.left\n  return root\n}\n\nfunction f(p: TreeNode, o: TreeNode): TreeNode {\n  if (o.left) p = f(p, o.left)\n\n  if (p != null) p.right = o\n  o.left = p\n  p = o\n\n  if (o.right) p = f(p, o.right)\n  return p\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-27","label":"problem-27","referenceType":"full","children":[{"type":"text","value":"#27 字符串的排列"}]},{"type":"text","value":"： 全排列"}]},{"type":"code","lang":"typescript","meta":"title=\"27.ts\" sourcefile=\"./27.ts\" maxlines=20 collapsed linenos","value":"export function Permutation(str: string): string[] {\n  if (str == null || str.length \u003c= 0) return []\n  const letters: string[] = str.split('').sort()\n  const answers: string[] = []\n  const _end = letters.length - 1\n\n  while (true) {\n    answers.push(letters.join(''))\n\n    // 从右往左扫描找到第一个相邻且逆序的元素对 (i - 1, i)\n    // 将第 i-1 个元素和最后一个元素交换，然后将 [i, N] 中的元素反转顺序\n\n    let i = _end\n    for (; i \u003e 0; --i) {\n      if (letters[i] \u003e letters[i - 1]) break\n    }\n\n    // 若不存在这样的 i，则结束循环\n    if (i \u003c= 0) break\n\n    let x = letters[i - 1]\n    let k = _end\n    for (; k \u003e= i; --k) if (letters[k] \u003e x) break\n    letters[i - 1] = letters[k]\n    letters[k] = x\n    const L = i + _end\n    const mid = L \u003e\u003e 1\n    for (let j = i; j \u003c= mid; ++j) {\n      x = letters[j]\n      letters[j] = letters[L - j]\n      letters[L - j] = x\n    }\n  }\n  return answers\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-28","label":"problem-28","referenceType":"full","children":[{"type":"text","value":"#28 数组中出现次数超过一半的数字"}]},{"type":"text","value":"： 中位数，随机测试，找第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 大数"}]},{"type":"list","ordered":false,"marker":45,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"排序"}]},{"type":"code","lang":"typescript","meta":"title=\"28.ts\" sourcefile=\"./28.ts\" maxlines=20 collapsed linenos","value":"/**\n * 排序并返回中位数\n *\n * 时间复杂度： O(N \\log N)\n * 额外空间复杂度： O(N)\n */\nexport function MoreThanHalfNum_Solution(nums: number[]): number {\n  nums.sort((x, y) =\u003e x - y)\n  return nums[nums.length \u003e\u003e 1]\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"随机测试"}]},{"type":"code","lang":"typescript","meta":"title=\"28_2.ts\" sourcefile=\"./28_2.ts\" maxlines=20 collapsed linenos","value":"/**\n * 随机测试\n *\n * 时间复杂度： O(N \\log N)\n * 额外空间复杂度： O(1)\n */\nexport function MoreThanHalfNum_Solution_2(nums: number[]): number {\n  let last: number = Number.NaN\n\n  while (true) {\n    const current = nums[Math.floor(Math.random() * nums.length)]\n\n    if (last === current) continue\n    last = current\n\n    let cnt = 0\n    for (let x of nums) if (x === current) cnt += 1\n    if (cnt * 2 \u003e= nums.length) return current\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"找第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 大的数"}]},{"type":"code","lang":"typescript","meta":"title=\"28_3.ts\" sourcefile=\"./28_3.ts\" maxlines=20 collapsed linenos","value":"/**\n * 快排思想找数组中第 k 大元素\n *\n * 时间复杂度： O(N)\n * 额外空间复杂度： O(log N)\n */\nexport function MoreThanHalfNum_Solution_3(nums: number[]): number {\n  return kth(0, nums.length - 1, (nums.length + 1) \u003e\u003e 1)\n\n  function kth(lft: number, rht: number, k: number): number {\n    if (lft === rht) return nums[lft]\n\n    // 选取一个随机值防止极端数据下的复杂度退化\n    const x = lft + 7 \u003c= rht ? lft + Math.floor((rht - lft) * Math.random()) : (lft + rht) \u003e\u003e 1\n    const pivot = nums[x]\n    nums[x] = nums[lft]\n\n    let i = lft\n    let j = rht + 1\n    while (i \u003c j) {\n      for (j -= 1; i \u003c j \u0026\u0026 nums[j] \u003e= pivot; ) --j\n      if (i === j) break\n      nums[i] = nums[j]\n\n      for (i += 1; i \u003c j \u0026\u0026 nums[i] \u003c= pivot; ) ++i\n      if (i === j) break\n      nums[j] = nums[i]\n    }\n    nums[i] = pivot\n\n    // 优化，中间元素的边界尽可能延申，否则复杂度可能退化为 O(N^2)\n    for (i -= 1; i \u003e= lft; --i) if (nums[i] !== pivot) break\n    for (j += 1; j \u003c= rht; ++j) if (nums[j] !== pivot) break\n\n    // 先检查左边的元素个数是否大于或等于 k 个\n    let k2 = k - (i + 1 - lft)\n    if (k2 \u003c= 0) return kth(lft, i, k)\n\n    // 再判断左边的元素个数+中间元素个数是否大于等于 k 个\n    k2 -= j - i - 1\n    if (k2 \u003c= 0) return pivot\n\n    // 否则，目标值再右边的元素列表中\n    return kth(j, rht, k2)\n  }\n}\n"}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-29","label":"problem-29","referenceType":"full","children":[{"type":"text","value":"#29 最小的K个数"}]},{"type":"text","value":"： 排序，小根堆，找第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的数"}]},{"type":"list","ordered":false,"marker":45,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"小根堆"}]},{"type":"code","lang":"typescript","meta":"title=\"29.ts\" sourcefile=\"./29.ts\" maxlines=20 collapsed linenos","value":"/**\n * 大根堆\n *\n * 时间复杂度： O(N \\log N)\n * 额外空间复杂度： O(N)\n */\nexport function GetLeastNumbers_Solution(nums: number[], _k: number): number[] {\n  if (_k \u003c= 0) return []\n  if (_k \u003e= nums.length) return nums\n\n  const Q: PriorityQueue\u003cnumber\u003e = createPriorityQueue\u003cnumber\u003e((x, y) =\u003e y - x)\n  for (let i = 0; i \u003c _k; ++i) Q.enqueue(nums[i])\n  for (let i = _k; i \u003c nums.length; ++i) {\n    const x = nums[i]\n    if (Q.top() \u003c= x) continue\n    Q.dequeue()\n    Q.enqueue(x)\n  }\n\n  return Q.collect()\n}\n\ninterface PriorityQueue\u003cT\u003e {\n  enqueue: (val: T) =\u003e void\n  dequeue: () =\u003e T | undefined\n  collect: () =\u003e T[]\n  top: () =\u003e T | undefined\n  size: () =\u003e number\n  isEmpty: () =\u003e boolean\n}\n\n// 优先队列\nfunction createPriorityQueue\u003cT\u003e(cmp: (x: T, y: T) =\u003e -1 | 0 | 1 | number): PriorityQueue\u003cT\u003e {\n  const _tree: T[] = [null]\n  let _size: number = 0\n\n  function enqueue(val: T): void {\n    _tree[++_size] = val\n    _up(_size)\n  }\n\n  function dequeue(): T | undefined {\n    if (_size \u003c 1) return undefined\n\n    const target = _tree[1]\n    _tree[1] = _tree[_size--]\n    _down(1)\n\n    return target\n  }\n\n  function top(): T | undefined {\n    return _size \u003e 0 ? _tree[1] : undefined\n  }\n\n  function collect(): T[] {\n    return _tree.slice(1)\n  }\n\n  function _down(index: number): void {\n    for (let i = index; i \u003c= _size; ) {\n      const lft = i \u003c\u003c 1\n      const rht = lft | 1\n      if (lft \u003e _size) break\n\n      let q = lft\n      if (rht \u003c= _size \u0026\u0026 cmp(_tree[rht], _tree[q]) \u003c 0) q += 1\n\n      const x = _tree[q]\n      if (cmp(_tree[i], x) \u003c= 0) break\n\n      _tree[q] = _tree[i]\n      _tree[i] = x\n      i = q\n    }\n  }\n\n  function _up(index: number): void {\n    for (let i = index; i \u003e 1; ) {\n      const q = i \u003e\u003e 1\n      const x = _tree[q]\n      if (cmp(x, _tree[i]) \u003c= 0) break\n\n      _tree[q] = _tree[i]\n      _tree[i] = x\n      i = q\n    }\n  }\n\n  return {\n    enqueue,\n    dequeue,\n    top,\n    collect,\n    size: () =\u003e _size,\n    isEmpty: () =\u003e _size \u003c 1,\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"找第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 大的数"}]},{"type":"code","lang":"typescript","meta":"title=\"29_1.ts\" sourcefile=\"./29_1.ts\" maxlines=20 collapsed linenos","value":"/**\n * 快排思想找数组中第 k 大元素\n *\n * 时间复杂度： O(N)\n * 额外空间复杂度： O(log N)\n */\nexport function GetLeastNumbers_Solution(nums: number[], _k: number): number[] {\n  if (_k \u003c= 0) return []\n  if (_k \u003e= nums.length) return nums\n\n  kth(0, nums.length - 1, _k)\n  return nums.slice(0, _k)\n\n  function kth(lft: number, rht: number, k: number): number {\n    if (lft === rht) return nums[lft]\n\n    // 选取一个随机值防止极端数据下的复杂度退化\n    const x = lft + 7 \u003c= rht ? lft + Math.floor((rht - lft) * Math.random()) : (lft + rht) \u003e\u003e 1\n    const pivot = nums[x]\n    nums[x] = nums[lft]\n\n    let i = lft\n    let j = rht + 1\n    while (i \u003c j) {\n      for (j -= 1; i \u003c j \u0026\u0026 nums[j] \u003e= pivot; ) --j\n      if (i === j) break\n      nums[i] = nums[j]\n\n      for (i += 1; i \u003c j \u0026\u0026 nums[i] \u003c= pivot; ) ++i\n      if (i === j) break\n      nums[j] = nums[i]\n    }\n    nums[i] = pivot\n\n    // 优化，中间元素的边界尽可能延申，否则复杂度可能退化为 O(N^2)\n    for (i -= 1; i \u003e= lft; --i) if (nums[i] !== pivot) break\n    for (j += 1; j \u003c= rht; ++j) if (nums[j] !== pivot) break\n\n    // 先检查左边的元素个数是否大于或等于 k 个\n    let k2 = k - (i + 1 - lft)\n    if (k2 \u003c= 0) return kth(lft, i, k)\n\n    // 再判断左边的元素个数+中间元素个数是否大于等于 k 个\n    k2 -= j - i - 1\n    if (k2 \u003c= 0) return pivot\n\n    // 否则，目标值再右边的元素列表中\n    return kth(j, rht, k2)\n  }\n}\n"}]}]}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-30","label":"problem-30","referenceType":"full","children":[{"type":"text","value":"#30 连续子数组的最大和"}]},{"type":"text","value":"： 前缀和"}]},{"type":"code","lang":"typescript","meta":"title=\"30.ts\" sourcefile=\"./30.ts\" maxlines=20 collapsed linenos","value":"export function FindGreatestSumOfSubArray(nums: number[]): number {\n  if (nums.length \u003c= 0) return 0\n\n  let answer = nums[0]\n  let x = 0\n  let y = nums[0]\n  for (let i = 1; i \u003c nums.length; ++i) {\n    x = Math.min(x, y)\n    y += nums[i]\n    if (y - x \u003e answer) answer = y - x\n  }\n  return answer\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-31","label":"problem-31","referenceType":"full","children":[{"type":"text","value":"#31 整数中 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 出现的次数（从 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 到 "},{"type":"inlineMath","value":"n"},{"type":"text","value":" 整数中1出现的次数）"}]},{"type":"text","value":"： 数学，排列组合"}]},{"type":"paragraph","children":[{"type":"text","value":"因为十进制数位中每个位置上 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 的贡献度是彼此独立的，所以依次枚举每个位置，计算该位置为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 所有可能情况数，累计求和即可。"}]},{"type":"code","lang":"typescript","meta":"title=\"31.ts\" sourcefile=\"./31.ts\" maxlines=20 collapsed linenos","value":"const tenth: number[] = []\nfor (let i = 0, t = 1; i \u003c 18; ++i, t *= 10) {\n  tenth.push(t)\n}\n\nexport function NumberOf1Between1AndN_Solution(n: number): number {\n  const nums: number[] = String(n)\n    .split('')\n    .map(x =\u003e Number(x))\n\n  let result = 0\n  for (let i = 0; i \u003c nums.length; ++i) {\n    result += toNum(0, i) * tenth[nums.length - i - 1]\n    const x = nums[i]\n    if (x \u003c 1) continue\n    else if (x \u003e 1) result += tenth[nums.length - i - 1]\n    else if (x === 1) result += toNum(i + 1, nums.length) + 1\n  }\n  return result\n\n  function toNum(lft: number, rht: number): number {\n    let result = 0\n    for (let i = lft; i \u003c rht; ++i) {\n      result = result * 10 + nums[i]\n    }\n    return result\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-32","label":"problem-32","referenceType":"full","children":[{"type":"text","value":"#32 把数组排成最小的数"}]},{"type":"text","value":"： 排序，贪心"}]},{"type":"paragraph","children":[{"type":"text","value":"方便起见，将原数组中所有的数字转为字符串。考虑每个顺序下两个相邻的数字 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 和\n"},{"type":"inlineMath","value":"y"},{"type":"text","value":"，若组成的字符串 "},{"type":"inlineMath","value":"xy"},{"type":"text","value":" 字典序大于字符串 "},{"type":"inlineMath","value":"yx"},{"type":"text","value":"，则交换它们的位置可以得到一个更优的结果，且不会影响完整字符串中其它部分的大小。"}]},{"type":"code","lang":"typescript","meta":"title=\"32.ts\" sourcefile=\"./32.ts\" maxlines=20 collapsed linenos","value":"export function PrintMinNumber(A: number[]): string {\n  const result = A.map(x =\u003e String(x))\n    .sort((x, y) =\u003e {\n      if (x === y) return 0\n      return x + y \u003c y + x ? -1 : 1\n    })\n    .join('')\n  return result\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-33","label":"problem-33","referenceType":"full","children":[{"type":"text","value":"#33 丑数"}]},{"type":"text","value":"： 素因子，小根堆"}]},{"type":"paragraph","children":[{"type":"text","value":"每次取出小根堆中的根元素，然后放入其 "},{"type":"inlineMath","value":"\\times 2, \\times 3, \\times 5"},{"type":"text","value":" 的数值，直到取出了 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 个数为止。"}]},{"type":"code","lang":"typescript","meta":"title=\"33.ts\" sourcefile=\"./33.ts\" maxlines=20 collapsed linenos","value":"export function GetUglyNumber_Solution(N: number): number {\n  for (let i = answers.length; i \u003c= N; ++i) {\n    const c = answers[i - 1]\n    while (!Q.isEmpty()) {\n      const x = Q.dequeue()\n      if (x \u003c= c) continue\n      answers.push(x)\n      Q.enqueue(x * 2)\n      Q.enqueue(x * 3)\n      Q.enqueue(x * 5)\n      break\n    }\n  }\n  return answers[N]\n}\n\nconst answers: number[] = [0]\nconst Q: PriorityQueue\u003cnumber\u003e = createPriorityQueue\u003cnumber\u003e((x, y) =\u003e x - y)\nQ.enqueue(1)\n\ninterface PriorityQueue\u003cT\u003e {\n  enqueue: (val: T) =\u003e void\n  dequeue: () =\u003e T | undefined\n  collect: () =\u003e T[]\n  top: () =\u003e T | undefined\n  size: () =\u003e number\n  isEmpty: () =\u003e boolean\n}\n\n// 优先队列\nfunction createPriorityQueue\u003cT\u003e(cmp: (x: T, y: T) =\u003e -1 | 0 | 1 | number): PriorityQueue\u003cT\u003e {\n  const _tree: T[] = [null]\n  let _size: number = 0\n\n  function enqueue(val: T): void {\n    _tree[++_size] = val\n    _up(_size)\n  }\n\n  function dequeue(): T | undefined {\n    if (_size \u003c 1) return undefined\n\n    const target = _tree[1]\n    _tree[1] = _tree[_size--]\n    _down(1)\n\n    return target\n  }\n\n  function top(): T | undefined {\n    return _size \u003e 0 ? _tree[1] : undefined\n  }\n\n  function collect(): T[] {\n    return _tree.slice(1)\n  }\n\n  function _down(index: number): void {\n    for (let i = index; i \u003c= _size; ) {\n      const lft = i \u003c\u003c 1\n      const rht = lft | 1\n      if (lft \u003e _size) break\n\n      let q = lft\n      if (rht \u003c= _size \u0026\u0026 cmp(_tree[rht], _tree[q]) \u003c 0) q += 1\n\n      const x = _tree[q]\n      if (cmp(_tree[i], x) \u003c= 0) break\n\n      _tree[q] = _tree[i]\n      _tree[i] = x\n      i = q\n    }\n  }\n\n  function _up(index: number): void {\n    for (let i = index; i \u003e 1; ) {\n      const q = i \u003e\u003e 1\n      const x = _tree[q]\n      if (cmp(x, _tree[i]) \u003c= 0) break\n\n      _tree[q] = _tree[i]\n      _tree[i] = x\n      i = q\n    }\n  }\n\n  return {\n    enqueue,\n    dequeue,\n    top,\n    collect,\n    size: () =\u003e _size,\n    isEmpty: () =\u003e _size \u003c 1,\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-34","label":"problem-34","referenceType":"full","children":[{"type":"text","value":"#34 第一个只出现一次的字符"}]},{"type":"text","value":"： 哈希表，Map"}]},{"type":"code","lang":"typescript","meta":"title=\"34.ts\" sourcefile=\"./34.ts\" maxlines=20 collapsed linenos","value":"export function FirstNotRepeatingChar(str: string): number {\n  const duplicated: Record\u003cstring, boolean\u003e = {}\n  for (let i = 0; i \u003c str.length; ++i) {\n    const c = str[i]\n    duplicated[c] = duplicated[c] === undefined ? false : true\n  }\n\n  for (let i = 0; i \u003c str.length; ++i) {\n    if (duplicated[str[i]]) continue\n    return i\n  }\n  return -1\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-35","label":"problem-35","referenceType":"full","children":[{"type":"text","value":"#35 数组中的逆序对"}]},{"type":"text","value":"： 逆序对，树状数组，映射"}]},{"type":"code","lang":"typescript","meta":"title=\"35.ts\" sourcefile=\"./35.ts\" maxlines=20 collapsed linenos","value":"export function InversePairs(data: number[]): number {\n  const _size = data.length\n\n  const idx: number[] = new Array(_size)\n  for (let i = 0; i \u003c _size; ++i) idx[i] = i\n  idx.sort((i, j) =\u003e data[i] - data[j])\n\n  // 映射\n  const rnk: number[] = []\n  for (let i = 0; i \u003c _size; ++i) rnk[idx[i]] = i + 1\n\n  let result = 0\n  const bit = createBIT(_size)\n  for (const x of rnk) {\n    result += bit.sum(_size) - bit.sum(x)\n    bit.add(x, 1)\n  }\n  return result % (1e9 + 7)\n}\n\nfunction createBIT(n: number) {\n  const lowbit = (x: number): number =\u003e x \u0026 -x\n\n  const sumv: number[] = new Array(n + 1).fill(0)\n\n  const add = (x: number, v: number): void =\u003e {\n    for (let i = x; i \u003c= n; i += lowbit(i)) sumv[i] += v\n  }\n\n  const sum = (x: number): number =\u003e {\n    let answer = 0\n    for (let i = x; i \u003e 0; i -= lowbit(i)) answer += sumv[i]\n    return answer\n  }\n\n  return { add, sum }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-36","label":"problem-36","referenceType":"full","children":[{"type":"text","value":"#36 两个链表的第一个公共节点"}]},{"type":"text","value":"： 双指针"}]},{"type":"paragraph","children":[{"type":"text","value":"先分别从两个链表的表达走到末尾，得到所需步数分别为 "},{"type":"inlineMath","value":"k_1"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"k_2"},{"type":"text","value":"，不妨设\n"},{"type":"inlineMath","value":"k_1 \u003e k_2"},{"type":"text","value":"，即第一个链表比第二个长，先让快指针从第一个链表出发先走 "},{"type":"inlineMath","value":"k_1 - k_2"},{"type":"text","value":"\n步，再让慢指针从第二个链表出发和快指针一起前进，当慢指针和快指针相等时即到达第一个公共节点"}]},{"type":"code","lang":"typescript","meta":"title=\"36.ts\" sourcefile=\"./36.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nexport function FindFirstCommonNode(pHead1: ListNode, pHead2: ListNode): ListNode {\n  let k1 = 0\n  let k2 = 0\n\n  for (let o = pHead1; o != null; o = o.next) k1 += 1\n  for (let o = pHead2; o != null; o = o.next) k2 += 1\n\n  const delta: number = Math.abs(k1 - k2)\n  let faster: ListNode | null = k1 \u003e k2 ? pHead1 : pHead2\n  let slower: ListNode | null = k1 \u003c k2 ? pHead1 : pHead2\n\n  for (let i = 0; i \u003c delta; ++i) faster = faster.next\n  while (faster !== slower) {\n    faster = faster.next\n    slower = slower.next\n  }\n  return faster\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-37","label":"problem-37","referenceType":"full","children":[{"type":"text","value":"#37 数字在升序数组中出现的次数"}]},{"type":"text","value":"： 二分"}]},{"type":"code","lang":"typescript","meta":"title=\"37.ts\" sourcefile=\"./37.ts\" maxlines=20 collapsed linenos","value":"export function GetNumberOfK(nums: number[], k: number): number {\n  return lowerBound(k + 1) - lowerBound(k)\n\n  function lowerBound(x: number): number {\n    let lft = 0\n    let rht = nums.length\n    while (lft \u003c rht) {\n      const mid = (lft + rht) \u003e\u003e 1\n      if (nums[mid] \u003c x) lft = mid + 1\n      else rht = mid\n    }\n    return lft\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-38","label":"problem-38","referenceType":"full","children":[{"type":"text","value":"#38 二叉树的深度"}]},{"type":"text","value":"： 二叉树，DFS"}]},{"type":"code","lang":"typescript","meta":"title=\"38.ts\" sourcefile=\"./38.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function TreeDepth(o: TreeNode | null): number {\n  if (o == null) return 0\n  return Math.max(TreeDepth(o.left), TreeDepth(o.right)) + 1\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-39","label":"problem-39","referenceType":"full","children":[{"type":"text","value":"#39 平衡二叉树"}]},{"type":"text","value":"： 二叉树，DFS"}]},{"type":"code","lang":"typescript","meta":"title=\"39.ts\" sourcefile=\"./39.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function IsBalanced_Solution(pRoot: TreeNode): boolean {\n  return dfs(pRoot) !== -1\n\n  function dfs(o: TreeNode): 0 | -1 | number {\n    if (o == null) return 0\n\n    const h1 = dfs(o.left)\n    if (h1 === -1) return -1\n\n    const h2 = dfs(o.right)\n    if (h2 === -1) return -1\n\n    const delta = Math.abs(h1 - h2)\n    return delta \u003c= 1 ? Math.max(h1, h2) + 1 : -1\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-40","label":"problem-40","referenceType":"full","children":[{"type":"text","value":"#40 数组中只出现一次的两个数字"}]},{"type":"text","value":"： 异或，分类"}]},{"type":"paragraph","children":[{"type":"text","value":"不妨记只出现一次的两个数字分别为 "},{"type":"inlineMath","value":"x_1"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"x_2"},{"type":"text","value":"。先求出所有数字的异或结果 "},{"type":"inlineMath","value":"s"},{"type":"text","value":"，不难发现 "},{"type":"inlineMath","value":"s = x_1 \\oplus x_2"},{"type":"text","value":"。又因为 "},{"type":"inlineMath","value":"x_1 \\neq x_2"},{"type":"text","value":"，所以 "},{"type":"inlineMath","value":"s \\neq 0"},{"type":"text","value":"。取出\n"},{"type":"inlineMath","value":"s"},{"type":"text","value":" 二进制位中任意一位不为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":" 的位 "},{"type":"inlineMath","value":"b"},{"type":"text","value":"，即 "},{"type":"inlineMath","value":"s \\oplus 2^{b-1} = s - 2^{b-1}"},{"type":"text","value":"，将原数组中所有的数字划分为第 "},{"type":"inlineMath","value":"b"},{"type":"text","value":" 为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":" 和第 "},{"type":"inlineMath","value":"b"},{"type":"text","value":" 位为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 两大类，不难发现，"}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"相同的数字会被分配到同一类中"}]},{"type":"listItem","children":[{"type":"inlineMath","value":"x_1"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"x_2"},{"type":"text","value":" 会被分配到不同的类别中"}]}]},{"type":"paragraph","children":[{"type":"text","value":"则问题转换为【一个数组中，除一个元素只出现一次外其它元素均恰好出现两次，求这个只出现一次的元素】，这个问题直接异或就可以了。"}]},{"type":"code","lang":"typescript","meta":"title=\"40.ts\" sourcefile=\"./40.ts\" maxlines=20 collapsed linenos","value":"export function FindNumsAppearOnce(nums: number[]): [number, number] {\n  let s = 0\n  for (const x of nums) s ^= x\n  const b = s \u0026 -s\n\n  let x1 = 0\n  let x2 = 0\n  for (const x of nums) {\n    if (x \u0026 b) x1 ^= x\n    else x2 ^= x\n  }\n\n  return [Math.min(x1, x2), Math.max(x1, x2)]\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-41","label":"problem-41","referenceType":"full","children":[{"type":"text","value":"#41 和为 "},{"type":"inlineMath","value":"S"},{"type":"text","value":" 的连续正数序列"}]},{"type":"text","value":"： 前缀和"}]},{"type":"code","lang":"typescript","meta":"title=\"41.ts\" sourcefile=\"./41.ts\" maxlines=20 collapsed linenos","value":"export function FindContinuousSequence(sum: number): number[][] {\n  if (sum \u003c= 0) return []\n\n  const results: number[][] = []\n  let lft = 1\n  let total = 1\n  for (let i = 2, _end = ((sum + 1) \u003e\u003e 1) + 1; i \u003c _end; ++i) {\n    total += i\n    for (; total \u003e sum; ++lft) total -= lft\n    if (total === sum) {\n      const answer: number[] = []\n      for (let x = lft; x \u003c= i; ++x) answer.push(x)\n      results.push(answer)\n    }\n  }\n  return results\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-42","label":"problem-42","referenceType":"full","children":[{"type":"text","value":"#42 和为 "},{"type":"inlineMath","value":"S"},{"type":"text","value":" 的两个数字"}]},{"type":"text","value":"： 二分"}]},{"type":"code","lang":"typescript","meta":"title=\"42.ts\" sourcefile=\"./42.ts\" maxlines=20 collapsed linenos","value":"export function FindNumbersWithSum(nums: number[], sum: number): number[] {\n  const _size = nums.length\n  if (_size \u003c= 1) return []\n\n  let i = lowerBound(1, _size, sum - nums[0])\n  if (i === _size) return []\n\n  for (; i \u003e 0; --i) {\n    const x = nums[i]\n    const y = sum - x\n    const j = lowerBound(0, i, y)\n    if (j \u003c i \u0026\u0026 nums[j] === y) return [y, x]\n  }\n  return []\n\n  function lowerBound(lft: number, rht: number, x: number): number {\n    while (lft \u003c rht) {\n      const mid = (lft + rht) \u003e\u003e 1\n      if (nums[mid] \u003c x) lft = mid + 1\n      else rht = mid\n    }\n    return lft\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-43","label":"problem-43","referenceType":"full","children":[{"type":"text","value":"#43 左旋转字符串"}]},{"type":"text","value":"： 数组切片"}]},{"type":"code","lang":"typescript","meta":"title=\"43.ts\" sourcefile=\"./43.ts\" maxlines=20 collapsed linenos","value":"export function LeftRotateString(str: string, n: number): string {\n  if (str == null || str.length \u003c= 0) return ''\n  const _size = str.length\n  const k = ((n % _size) + _size) % _size\n  if (k === 0) return str\n  return str.slice(k) + str.slice(0, k)\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-44","label":"problem-44","referenceType":"full","children":[{"type":"text","value":"#44 翻转单词序列"}]},{"type":"text","value":"： 字符串"}]},{"type":"code","lang":"typescript","meta":"title=\"44.ts\" sourcefile=\"./44.ts\" maxlines=20 collapsed linenos","value":"export function ReverseSentence(s: string): string {\n  return s.split(/\\s+/g).reverse().join(' ')\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-45","label":"problem-45","referenceType":"full","children":[{"type":"text","value":"#45 扑克牌顺子"}]},{"type":"text","value":"： 模拟，枚举"}]},{"type":"code","lang":"typescript","meta":"title=\"45.ts\" sourcefile=\"./45.ts\" maxlines=20 collapsed linenos","value":"export function IsContinuous(numbers: number[]): boolean {\n  const nums = numbers.slice().sort((x, y) =\u003e x - y)\n  let i = 0\n  for (; i \u003c nums.length; ++i) if (nums[i]) break\n  if (i + 1 \u003e= nums.length) return true\n\n  let x = nums[i]\n  for (let j = i + 1; j \u003c nums.length; ++j) {\n    const y = nums[j]\n    if (x === y) return false\n    i -= y - x - 1\n    if (i \u003c 0) return false\n    x = y\n  }\n  return true\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-46","label":"problem-46","referenceType":"full","children":[{"type":"text","value":"#46 孩子们的游戏(圆圈中最后剩下的数)"}]},{"type":"text","value":"： 数学，"},{"type":"linkReference","identifier":"quiz-josephus-ring","label":"quiz-josephus-ring","referenceType":"full","children":[{"type":"text","value":"约瑟夫环"}]}]},{"type":"code","lang":"typescript","meta":"title=\"46.ts\" sourcefile=\"./46.ts\" maxlines=20 collapsed linenos","value":"export function LastRemaining_Solution(n: number, m: number): number {\n  if (n === 0) return -1\n  if (n === 1) return 0\n  const x = LastRemaining_Solution(n - 1, m)\n\n  // 以上一个位置为零号位置重新编号\n  return (m + x) % n\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-47","label":"problem-47","referenceType":"full","children":[{"type":"text","value":"#47 求 "},{"type":"inlineMath","value":"1 + 2 + \\cdots + n"}]},{"type":"text","value":"： 逻辑运算符，递归"}]},{"type":"code","lang":"typescript","meta":"title=\"47.ts\" sourcefile=\"./47.ts\" maxlines=20 collapsed linenos","value":"export function Sum_Solution(n: number): number {\n  return n \u003e 0 \u0026\u0026 Sum_Solution(n - 1) + n\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-48","label":"problem-48","referenceType":"full","children":[{"type":"text","value":"#48 不用加减乘除做加法"}]},{"type":"text","value":"： 位运算，模拟"}]},{"type":"code","lang":"typescript","meta":"title=\"48.ts\" sourcefile=\"./48.ts\" maxlines=20 collapsed linenos","value":"export function Add(num1: number, num2: number): number {\n  let result = 0\n  for (; num1 \u003e 0 \u0026\u0026 num2 \u003e 0; ) {\n    let a = num1 \u0026 -num1\n    let b = num2 \u0026 -num2\n    if (a \u003c= b) {\n      num1 ^= a\n      for (; a \u0026 result; a \u003c\u003c= 1) result ^= a\n      result ^= a\n    } else {\n      num2 ^= b\n      for (; b \u0026 result; b \u003c\u003c= 1) result ^= b\n      result ^= b\n    }\n  }\n\n  if (num2 \u003e 0) num1 = num2\n  for (; num1 \u003e 0; ) {\n    let a = num1 \u0026 -num1\n    num1 ^= a\n    for (; a \u0026 result; a \u003c\u003c= 1) result ^= a\n    result ^= a\n  }\n  return result\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-49","label":"problem-49","referenceType":"full","children":[{"type":"text","value":"#49 把字符串转换成整数"}]},{"type":"text","value":"： 十进制，模拟"}]},{"type":"code","lang":"typescript","meta":"title=\"49.ts\" sourcefile=\"./49.ts\" maxlines=20 collapsed linenos","value":"export function StrToInt(str: string): number {\n  if (str == null || str.length \u003c= 0) return 0\n\n  let flag: boolean = false\n  let result = 0\n  let i = 0\n\n  if (str[0] === '+') i += 1\n  else if (str[0] === '-') {\n    flag = true\n    i += 1\n  }\n\n  if (i \u003e= str.length) return 0\n  const zero = '0'.codePointAt(0)\n  for (; i \u003c str.length; ++i) {\n    const x = str.codePointAt(i) - zero\n    if (x \u003c 0 || x \u003e 9) return 0\n    result = result * 10 + x\n  }\n  return flag \u0026\u0026 result ? -result : result\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-50","label":"problem-50","referenceType":"full","children":[{"type":"text","value":"#50 数组中重复的数字"}]},{"type":"text","value":"： 判重"}]},{"type":"code","lang":"typescript","meta":"title=\"50.ts\" sourcefile=\"./50.ts\" maxlines=20 collapsed linenos","value":"export function duplicate(nums: number[]): number {\n  const _size: number = nums.length\n  const set: Set\u003cnumber\u003e = new Set()\n\n  // 校验输入数据\n  for (const x of nums) {\n    if (x \u003c 0 || x \u003e= _size) return -1\n  }\n\n  for (const x of nums) {\n    if (set.has(x)) return x\n    set.add(x)\n  }\n  return -1\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-51","label":"problem-51","referenceType":"full","children":[{"type":"text","value":"#51 构建乘积数组"}]},{"type":"text","value":"： 前缀积、后缀积"}]},{"type":"code","lang":"typescript","meta":"title=\"51.ts\" sourcefile=\"./51.ts\" maxlines=20 collapsed linenos","value":"export function multiply(A: number[]): number[] {\n  const _size = A.length\n  const s1: number[] = [A[0]]\n  const s2: number[] = []\n  s2[_size - 1] = A[_size - 1]\n\n  for (let i = 1; i \u003c _size; ++i) s1[i] = s1[i - 1] * A[i]\n  for (let i = _size - 2; i \u003e= 0; --i) s2[i] = s2[i + 1] * A[i]\n\n  const B: number[] = [s2[1]]\n  for (let i = 1; i + 1 \u003c _size; ++i) B[i] = s1[i - 1] * s2[i + 1]\n  B[_size - 1] = s1[_size - 2]\n  return B\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-52","label":"problem-52","referenceType":"full","children":[{"type":"text","value":"#52 正则表达式匹配"}]},{"type":"text","value":"： 字符串，匹配，递归"}]},{"type":"code","lang":"typescript","meta":"title=\"52.ts\" sourcefile=\"./52.ts\" maxlines=20 collapsed linenos","value":"export function match(str: string, pattern: string): boolean {\n  return f(0, 0)\n\n  function f(i: number, j: number): boolean {\n    if (i === str.length) {\n      if ((pattern.length - j) \u0026 1) return false\n      for (j += 1; j \u003c pattern.length; j += 2) {\n        if (pattern[j] !== '*') return false\n      }\n      return true\n    }\n    if (j === pattern.length) return false\n\n    const x = pattern[j]\n    switch (x) {\n      case '*': {\n        return f(i, j + 1)\n      }\n      case '.': {\n        if (j + 1 \u003c pattern.length \u0026\u0026 pattern[j + 1] === '*') {\n          for (; i \u003c= str.length; ++i) {\n            if (f(i, j + 2)) return true\n          }\n          return false\n        }\n        return f(i + 1, j + 1)\n      }\n      default: {\n        if (j + 1 \u003c pattern.length \u0026\u0026 pattern[j + 1] === '*') {\n          if (f(i, j + 2)) return true\n          for (; i \u003c str.length \u0026\u0026 str[i] === x; ++i) if (f(i + 1, j + 2)) return true\n          return false\n        }\n        return str[i] === x \u0026\u0026 f(i + 1, j + 1)\n      }\n    }\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-53","label":"problem-53","referenceType":"full","children":[{"type":"text","value":"#53 表示数值的字符串"}]},{"type":"text","value":"： 字符串，匹配，正则表达式"}]},{"type":"code","lang":"typescript","meta":"title=\"53.ts\" sourcefile=\"./53.ts\" maxlines=20 collapsed linenos","value":"export function isNumeric(str) {\n  return /^[+-]?(\\.\\d+|\\d+(\\.\\d+)?)([eE][+-]?\\d+)?$/.test(str)\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-54","label":"problem-54","referenceType":"full","children":[{"type":"text","value":"#54 字符流中第一个不重复的字符"}]},{"type":"text","value":"： Set"}]},{"type":"code","lang":"typescript","meta":"title=\"54.ts\" sourcefile=\"./54.ts\" maxlines=20 collapsed linenos","value":"const queue: string[] = []\nconst set1: Set\u003cstring\u003e = new Set\u003cstring\u003e()\nconst set2: Set\u003cstring\u003e = new Set\u003cstring\u003e()\n\nexport function Init(): void {\n  queue.length = 0\n  set1.clear()\n  set2.clear()\n}\n\nexport function Insert(ch: string): void {\n  if (set1.has(ch)) return void set2.add(ch)\n  set1.add(ch)\n  queue.push(ch)\n}\n\nexport function FirstAppearingOnce(): string {\n  while (queue.length \u003e 0) {\n    const x = queue[0]\n    if (set2.has(x)) queue.shift()\n    else return x\n  }\n  return '#'\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-55","label":"problem-55","referenceType":"full","children":[{"type":"text","value":"#55 链表中环的入口结点"}]},{"type":"text","value":"： 链表，双指针"}]},{"type":"paragraph","children":[{"type":"text","value":"参见 "},{"type":"link","url":"/post/quiz/partition/find-duplicate-number/#heading-%E8%BF%BD%E5%87%BB%E6%B3%95","children":[{"type":"text","value":"不修改数组找出重复的数字#追击法"}]}]},{"type":"code","lang":"typescript","meta":"title=\"55.ts\" sourcefile=\"./55.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nexport function EntryNodeOfLoop(pHead: ListNode): ListNode | null {\n  if (pHead == null) return null\n\n  let slower: ListNode | null = pHead\n  let faster: ListNode | null = pHead\n  do {\n    faster = faster.next\n    if (faster == null) return null\n\n    faster = faster.next\n    if (faster == null) return null\n\n    slower = slower.next\n  } while (slower !== faster)\n\n  slower = pHead\n  while (slower !== faster) {\n    faster = faster.next\n    slower = slower.next\n  }\n  return slower\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-56","label":"problem-56","referenceType":"full","children":[{"type":"text","value":"#56 删除链表中重复的节点"}]},{"type":"text","value":"： 链表，递归"}]},{"type":"code","lang":"typescript","meta":"title=\"56.ts\" sourcefile=\"./56.ts\" maxlines=20 collapsed linenos","value":"interface ListNode {\n  val: number\n  next: ListNode | null\n}\n\nexport function deleteDuplication(o: ListNode | null): ListNode | null {\n  if (o == null) return null\n\n  let v = o.next\n  if (v == null) return o\n\n  o.next = null\n  if (o.val === v.val) {\n    for (v = v.next; v != null; v = v.next) if (o.val != v.val) break\n    return deleteDuplication(v)\n  }\n  o.next = deleteDuplication(v)\n  return o\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-57","label":"problem-57","referenceType":"full","children":[{"type":"text","value":"#57 二叉树的下一个结点"}]},{"type":"text","value":"： 二叉树，中序遍历"}]},{"type":"paragraph","children":[{"type":"text","value":"中序遍历的下一个节点要么是第一个还没有遍历右子节点的祖先节点，要么是右子树中的最左叶子节点。"}]},{"type":"code","lang":"typescript","meta":"title=\"57.ts\" sourcefile=\"./57.ts\" maxlines=20 collapsed linenos","value":"interface TreeLinkNode {\n  val: number\n  left: TreeLinkNode | null\n  right: TreeLinkNode | null\n  next: TreeLinkNode | null\n}\n\nexport function GetNext(o: TreeLinkNode): TreeLinkNode | null {\n  if (o.right) {\n    let v = o.right\n    while (v.left) v = v.left\n    return v\n  }\n\n  let v = o.next\n  while (v \u0026\u0026 v.right === o) {\n    o = v\n    v = v.next\n  }\n  return v\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-58","label":"problem-58","referenceType":"full","children":[{"type":"text","value":"#58 对称的二叉树"}]},{"type":"text","value":"： 二叉树，BFS"}]},{"type":"code","lang":"typescript","meta":"title=\"58.ts\" sourcefile=\"./58.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\ninterface Item {\n  node: TreeNode\n  step: number\n}\n\nexport function isSymmetrical(pRoot: TreeNode): boolean {\n  if (pRoot == null) return true\n  const Q: Item[] = []\n  const nums: number[] = []\n  let tot = 0\n\n  let currentStep = 0\n  Q.push({ node: pRoot, step: 0 })\n  while (Q.length \u003e 0) {\n    const { node, step } = Q.shift()\n\n    if (currentStep \u003c step) {\n      currentStep = step\n      for (let i = 0, j = tot - 1; i \u003c j; ++i, --j) {\n        if (nums[i] !== nums[j]) return false\n      }\n      tot = 0\n    }\n\n    if (node == null) nums[tot++] = -Number.MAX_SAFE_INTEGER\n    else {\n      nums[tot++] = node.val\n      Q.push({ node: node.left, step: step + 1 })\n      Q.push({ node: node.right, step: step + 1 })\n    }\n  }\n\n  for (let i = 0, j = tot - 1; i \u003c j; ++i, --j) {\n    if (nums[i] !== nums[j]) return false\n  }\n  return true\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-59","label":"problem-59","referenceType":"full","children":[{"type":"text","value":"#59 按之字形顺序打印二叉树"}]},{"type":"text","value":"： 二叉树，BFS"}]},{"type":"code","lang":"typescript","meta":"title=\"59.ts\" sourcefile=\"./59.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\ninterface Item {\n  node: TreeNode\n  step: number\n}\n\nexport function Print(o: TreeNode): number[][] {\n  if (o == null) return []\n  const Q: Item[] = []\n  const results: number[][] = []\n  const tmp: number[] = []\n  let currentStep = 1\n  let tot = 0\n  Q.push({ node: o, step: 1 })\n\n  while (Q.length \u003e 0) {\n    const { node, step } = Q.shift()\n    if (currentStep \u003c step) {\n      const result: number[] = tmp.slice(0, tot)\n      if (step \u0026 1) result.reverse()\n      results.push(result)\n      tot = 0\n      currentStep = step\n    }\n    tmp[tot++] = node.val\n    if (node.left) Q.push({ node: node.left, step: step + 1 })\n    if (node.right) Q.push({ node: node.right, step: step + 1 })\n  }\n  const result: number[] = tmp.slice(0, tot)\n  if ((currentStep + 1) \u0026 1) result.reverse()\n  results.push(result)\n  return results\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-60","label":"problem-60","referenceType":"full","children":[{"type":"text","value":"#60 把二叉树打印成多行"}]},{"type":"text","value":"： 二叉树，BFS"}]},{"type":"code","lang":"typescript","meta":"title=\"60.ts\" sourcefile=\"./60.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\ninterface Item {\n  node: TreeNode\n  step: number\n}\n\nexport function Print(o: TreeNode): number[][] {\n  if (o == null) return []\n\n  const Q: Item[] = []\n  const results: number[][] = []\n  const tmp: number[] = []\n\n  let currentStep = 1\n  let tot = 0\n  Q.push({ node: o, step: 1 })\n\n  while (Q.length \u003e 0) {\n    const { node, step } = Q.shift()\n    if (currentStep \u003c step) {\n      const result = tmp.slice(0, tot)\n      results.push(result)\n      tot = 0\n      currentStep = step\n    }\n    tmp[tot++] = node.val\n    if (node.left) Q.push({ node: node.left, step: step + 1 })\n    if (node.right) Q.push({ node: node.right, step: step + 1 })\n  }\n  const result = tmp.slice(0, tot)\n  results.push(result)\n  return results\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-61","label":"problem-61","referenceType":"full","children":[{"type":"text","value":"#61 序列化二叉树"}]},{"type":"text","value":"： 二叉树，重建二叉树"}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"序列化：求出先序遍历和后序遍历，并将其转为字符串"}]},{"type":"listItem","children":[{"type":"text","value":"反序列化：通过先序遍历和后序遍历结果重建树"}]}]},{"type":"code","lang":"typescript","meta":"title=\"61.ts\" sourcefile=\"./61.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function Serialize(pRoot: TreeNode): string {\n  const pre: number[] = []\n  const vin: number[] = []\n\n  if (pRoot != null) {\n    preTraverse(pRoot)\n    vinTraverse(pRoot)\n  }\n\n  return pre.join(',') + '#' + vin.join(',')\n\n  function preTraverse(o) {\n    if (o == null) return\n    pre.push(o.val)\n    preTraverse(o.left)\n    preTraverse(o.right)\n  }\n\n  function vinTraverse(o) {\n    if (o == null) return\n    vinTraverse(o.left)\n    vin.push(o.val)\n    vinTraverse(o.right)\n  }\n}\n\nexport function Deserialize(s: string): TreeNode {\n  if (s === '#') return null\n  const [x, y] = s.split('#')\n  const pre: number[] = x.split(',').map(n =\u003e Number(n))\n  const vin: number[] = y.split(',').map(n =\u003e Number(n))\n\n  if (pre.length \u003c= 0 || pre.length !== vin.length) return null\n  const tree = f(0, pre.length - 1, 0, vin.length - 1)\n  return tree\n\n  function f(lft1: number, rht1: number, lft2: number, rht2: number): TreeNode {\n    const t = pre[lft1]\n    let x = lft2\n    for (; x \u003c= rht2; ++x) if (vin[x] === t) break\n\n    const o = {\n      val: t,\n      left: lft2 \u003c x ? f(lft1 + 1, lft1 + x - lft2, lft2, x - 1) : null,\n      right: rht2 \u003e x ? f(lft1 + x - lft2 + 1, rht1, x + 1, rht2) : null,\n    }\n    return o\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-62","label":"problem-62","referenceType":"full","children":[{"type":"text","value":"#62 二叉搜索树的第k个结点"}]},{"type":"text","value":"： 二叉树，二叉搜索树，中序遍历"}]},{"type":"code","lang":"typescript","meta":"title=\"62.ts\" sourcefile=\"./62.ts\" maxlines=20 collapsed linenos","value":"interface TreeNode {\n  val: number\n  left: TreeNode | null\n  right: TreeNode | null\n}\n\nexport function KthNode(pRoot: TreeNode, k: number): TreeNode | null {\n  let result = null\n  if (k \u003c= 0) return result\n\n  f(pRoot)\n  return result\n\n  function f(o: TreeNode): void {\n    if (o == null) return\n\n    f(o.left)\n    if (result != null) return\n\n    k -= 1\n    if (k \u003c= 0) {\n      result = o\n      return\n    }\n\n    f(o.right)\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-63","label":"problem-63","referenceType":"full","children":[{"type":"text","value":"#63 数据流中的中位数"}]},{"type":"text","value":"： 堆，中位数"}]},{"type":"paragraph","children":[{"type":"text","value":"维护一个大根堆和小根堆："}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"大根堆中存放当前数列中前 "},{"type":"inlineMath","value":"\\left\\lceil\\frac{N}{2}\\right\\rceil"},{"type":"text","value":" 小的元素；"}]},{"type":"listItem","children":[{"type":"text","value":"小根堆中存放当前数列中后 "},{"type":"inlineMath","value":"\\left\\lfloor\\frac{N}{2}\\right\\rfloor"},{"type":"text","value":" 大的元素；"}]}]},{"type":"paragraph","children":[{"type":"text","value":"则每次查询时，若元素个数为奇数，直接返回大根堆的根顶元素；否则，即元素个数为偶数，返回小根堆和大根堆的堆顶元素的平均值。"}]},{"type":"code","lang":"typescript","meta":"title=\"63.ts\" sourcefile=\"./63.ts\" maxlines=20 collapsed linenos","value":"import { PriorityQueue } from '@algorithm.ts/queue'\n\nconst lowerQ = new PriorityQueue\u003cnumber\u003e({ compare: (x, y) =\u003e y - x })\nconst upperQ = new PriorityQueue\u003cnumber\u003e({ compare: (x, y) =\u003e x - y })\n\nexport function Insert(num: number): void {\n  if (lowerQ.size === upperQ.size) {\n    upperQ.enqueue(num)\n    lowerQ.enqueue(upperQ.dequeue()!)\n  } else {\n    lowerQ.enqueue(num)\n    upperQ.enqueue(lowerQ.dequeue()!)\n  }\n}\n\nexport function GetMedian(): number {\n  return lowerQ.size === upperQ.size ? (lowerQ.front()! + upperQ.front()!) / 2 : lowerQ.front()!\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-64","label":"problem-64","referenceType":"full","children":[{"type":"text","value":"#64 滑动窗口的最大值"}]},{"type":"text","value":"： 滑动窗口，单调栈"}]},{"type":"code","lang":"typescript","meta":"title=\"64.ts\" sourcefile=\"./64.ts\" maxlines=20 collapsed linenos","value":"export function maxInWindows(nums: number[], size: number): number[] {\n  if (nums.length \u003c size || size \u003c= 0) return []\n  const stack: number[] = []\n  for (let i = 0, _end = size - 1; i \u003c _end; ++i) {\n    const x = nums[i]\n    while (stack.length \u003e 0 \u0026\u0026 x \u003e= nums[stack[stack.length - 1]]) stack.pop()\n    stack.push(i)\n  }\n\n  const results: number[] = []\n  for (let i = size - 1; i \u003c nums.length; ++i) {\n    const x = nums[i]\n    if (stack.length \u003e 0 \u0026\u0026 stack[0] + size === i) stack.shift()\n    while (stack.length \u003e 0 \u0026\u0026 x \u003e= nums[stack[stack.length - 1]]) stack.pop()\n    stack.push(i)\n    results.push(nums[stack[0]])\n  }\n  return results\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-65","label":"problem-65","referenceType":"full","children":[{"type":"text","value":"#65 矩阵中的路径"}]},{"type":"text","value":"： 模拟，矩阵"}]},{"type":"code","lang":"typescript","meta":"title=\"65.ts\" sourcefile=\"./65.ts\" maxlines=20 collapsed linenos","value":"export function hasPath(matrix: string[][], word: string): boolean {\n  if (word == null || word.length \u003c= 0) return true\n\n  const R = matrix.length\n  if (R \u003c= 0) return false\n\n  const C = matrix[0].length\n  if (C \u003c= 0) return false\n\n  const vis: boolean[][] = []\n  for (let x = 0; x \u003c R; ++x) vis[x] = new Array(C).fill(false)\n\n  for (let x = 0; x \u003c R; ++x) {\n    for (let y = 0; y \u003c C; ++y) {\n      if (f(x, y, 0)) return true\n    }\n  }\n  return false\n\n  function f(x: number, y: number, cur: number): boolean {\n    if (x \u003c 0 || x \u003e= R || y \u003c 0 || y \u003e= C) return false\n    if (vis[x][y] || matrix[x][y] !== word[cur]) return false\n\n    cur += 1\n    if (cur === word.length) return true\n\n    vis[x][y] = true\n    const flag = f(x - 1, y, cur) || f(x + 1, y, cur) || f(x, y - 1, cur) || f(x, y + 1, cur)\n    vis[x][y] = false\n    return flag\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-66","label":"problem-66","referenceType":"full","children":[{"type":"text","value":"#66 机器人的运动范围"}]},{"type":"text","value":"： BFS"}]},{"type":"code","lang":"typescript","meta":"title=\"66.ts\" sourcefile=\"./66.ts\" maxlines=20 collapsed linenos","value":"export function movingCount(threshold: number, rows: number, cols: number): number {\n  const vis: boolean[][] = []\n  for (let i = 0; i \u003c rows; ++i) {\n    vis[i] = new Array(cols).fill(false)\n  }\n\n  let result = 0\n  f(0, 0)\n  return result\n\n  function f(x: number, y: number): void {\n    if (x \u003c 0 || x \u003e= rows || y \u003c 0 || y \u003e= cols) return\n    if (vis[x][y]) return\n    vis[x][y] = true\n    const total = weight(x) + weight(y)\n    if (total \u003e threshold) return\n\n    result += 1\n    f(x - 1, y)\n    f(x + 1, y)\n    f(x, y - 1)\n    f(x, y + 1)\n  }\n\n  function weight(x: number): number {\n    let result = 0\n    for (let i = x; i \u003e 0; i = Math.round((i - (i % 10)) / 10)) result += i % 10\n    return result\n  }\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"linkReference","identifier":"problem-67","label":"problem-67","referenceType":"full","children":[{"type":"text","value":"#67 剪绳子"}]},{"type":"text","value":"： 数学"}]},{"type":"paragraph","children":[{"type":"text","value":"考虑剪下来的某段长为 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 的绳子，继续减它不会对其它段造成影响。"}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"若 "},{"type":"inlineMath","value":"x \u003e 4"},{"type":"text","value":"，则必然有 "},{"type":"inlineMath","value":"(x - 3) \\times 3 \u003e x"},{"type":"text","value":"；"}]},{"type":"listItem","children":[{"type":"text","value":"当 "},{"type":"inlineMath","value":"x \\leqslant 4"},{"type":"text","value":" 时，有 "},{"type":"inlineMath","value":"x \u003e (x-1) \\times 1 \\geqslant (x-2) \\times 2"}]}]},{"type":"paragraph","children":[{"type":"text","value":"这启发我们尽可能将绳子剪成长度为 "},{"type":"inlineMath","value":"3"},{"type":"text","value":" 的段，而当某一段长度为 "},{"type":"inlineMath","value":"4"},{"type":"text","value":" 时，则不再剪它。"}]},{"type":"code","lang":"typescript","meta":"title=\"67.ts\" sourcefile=\"./67.ts\" maxlines=20 collapsed linenos","value":"export function cutRope(n: number): number {\n  if (n \u003c= 0) return 0\n  if (n \u003c= 4) return n\n\n  let result = 1\n  if (n % 3 === 1) {\n    result = 4\n    n -= 4\n  } else if (n % 3 === 2) {\n    result = 2\n    n -= 2\n  }\n  for (; n \u003e 0; n -= 3) {\n    result *= 3\n  }\n  return result\n}\n"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"link","url":"https://github.com/guanghechen/algorithm.ts/tree/main/packages/queue","children":[{"type":"text","value":"@algorithm.ts/queue"}]}]}]}]},"toc":{"children":[{"depth":2,"identifier":"heading-前言","contents":[{"type":"text","value":"前言"}],"children":[]},{"depth":2,"identifier":"heading-01-二维数组的查找","contents":[{"type":"text","value":"01 二维数组的查找"}],"children":[{"depth":3,"identifier":"heading-题意简述","contents":[{"type":"text","value":"题意简述"}],"children":[]},{"depth":3,"identifier":"heading-题目简析","contents":[{"type":"text","value":"题目简析"}],"children":[]},{"depth":3,"identifier":"heading-程序实现","contents":[{"type":"text","value":"程序实现"}],"children":[]}]},{"depth":2,"identifier":"heading-04-重建二叉树","contents":[{"type":"text","value":"04 重建二叉树"}],"children":[{"depth":3,"identifier":"heading-题目简述","contents":[{"type":"text","value":"题目简述"}],"children":[]},{"depth":3,"identifier":"heading-题目简析-2","contents":[{"type":"text","value":"题目简析"}],"children":[]},{"depth":3,"identifier":"heading-程序实现-2","contents":[{"type":"text","value":"程序实现"}],"children":[]}]},{"depth":2,"identifier":"heading-06-旋转数组的最小数字","contents":[{"type":"text","value":"06 旋转数组的最小数字"}],"children":[{"depth":3,"identifier":"heading-题目简述-2","contents":[{"type":"text","value":"题目简述"}],"children":[]},{"depth":3,"identifier":"heading-题目简析-3","contents":[{"type":"text","value":"题目简析"}],"children":[]},{"depth":3,"identifier":"heading-程序实现-3","contents":[{"type":"text","value":"程序实现"}],"children":[]}]},{"depth":2,"identifier":"heading-23-二叉搜索树的后序遍历序列","contents":[{"type":"text","value":"23 二叉搜索树的后序遍历序列"}],"children":[{"depth":3,"identifier":"heading-题目描述","contents":[{"type":"text","value":"题目描述"}],"children":[]},{"depth":3,"identifier":"heading-题目简析-4","contents":[{"type":"text","value":"题目简析"}],"children":[]},{"depth":3,"identifier":"heading-程序实现-4","contents":[{"type":"text","value":"程序实现"}],"children":[]}]},{"depth":2,"identifier":"heading-附录","contents":[{"type":"text","value":"附录"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"ecmaImports":[],"definitionMap":{"heading-附录":{"type":"definition","identifier":"heading-附录","label":"heading-附录","url":"#heading-%E9%99%84%E5%BD%95"},"quiz-josephus-ring":{"type":"definition","identifier":"quiz-josephus-ring","label":"quiz-josephus-ring","url":"/post/quiz/classical/Josephus-ring/"},"problem-01":{"type":"definition","identifier":"problem-01","label":"problem-01","url":"https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e"},"problem-02":{"type":"definition","identifier":"problem-02","label":"problem-02","url":"https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68"},"problem-03":{"type":"definition","identifier":"problem-03","label":"problem-03","url":"https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035"},"problem-04":{"type":"definition","identifier":"problem-04","label":"problem-04","url":"https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6"},"problem-05":{"type":"definition","identifier":"problem-05","label":"problem-05","url":"https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6"},"problem-06":{"type":"definition","identifier":"problem-06","label":"problem-06","url":"https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba"},"problem-07":{"type":"definition","identifier":"problem-07","label":"problem-07","url":"https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3"},"problem-08":{"type":"definition","identifier":"problem-08","label":"problem-08","url":"https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4"},"problem-09":{"type":"definition","identifier":"problem-09","label":"problem-09","url":"https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387"},"problem-10":{"type":"definition","identifier":"problem-10","label":"problem-10","url":"https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6"},"problem-11":{"type":"definition","identifier":"problem-11","label":"problem-11","url":"https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8"},"problem-12":{"type":"definition","identifier":"problem-12","label":"problem-12","url":"https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00"},"problem-13":{"type":"definition","identifier":"problem-13","label":"problem-13","url":"https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b"},"problem-14":{"type":"definition","identifier":"problem-14","label":"problem-14","url":"https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9"},"problem-15":{"type":"definition","identifier":"problem-15","label":"problem-15","url":"https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca"},"problem-16":{"type":"definition","identifier":"problem-16","label":"problem-16","url":"https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337"},"problem-17":{"type":"definition","identifier":"problem-17","label":"problem-17","url":"https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88"},"problem-18":{"type":"definition","identifier":"problem-18","label":"problem-18","url":"https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7"},"problem-19":{"type":"definition","identifier":"problem-19","label":"problem-19","url":"https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a"},"problem-20":{"type":"definition","identifier":"problem-20","label":"problem-20","url":"https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49"},"problem-21":{"type":"definition","identifier":"problem-21","label":"problem-21","url":"https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106"},"problem-22":{"type":"definition","identifier":"problem-22","label":"problem-22","url":"https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701"},"problem-23":{"type":"definition","identifier":"problem-23","label":"problem-23","url":"https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd"},"problem-24":{"type":"definition","identifier":"problem-24","label":"problem-24","url":"https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca"},"problem-25":{"type":"definition","identifier":"problem-25","label":"problem-25","url":"https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba"},"problem-26":{"type":"definition","identifier":"problem-26","label":"problem-26","url":"https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5"},"problem-27":{"type":"definition","identifier":"problem-27","label":"problem-27","url":"https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7"},"problem-28":{"type":"definition","identifier":"problem-28","label":"problem-28","url":"https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163"},"problem-29":{"type":"definition","identifier":"problem-29","label":"problem-29","url":"https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf"},"problem-30":{"type":"definition","identifier":"problem-30","label":"problem-30","url":"https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484"},"problem-31":{"type":"definition","identifier":"problem-31","label":"problem-31","url":"https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6"},"problem-32":{"type":"definition","identifier":"problem-32","label":"problem-32","url":"https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993"},"problem-33":{"type":"definition","identifier":"problem-33","label":"problem-33","url":"https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b"},"problem-34":{"type":"definition","identifier":"problem-34","label":"problem-34","url":"https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c"},"problem-35":{"type":"definition","identifier":"problem-35","label":"problem-35","url":"https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5"},"problem-36":{"type":"definition","identifier":"problem-36","label":"problem-36","url":"https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46"},"problem-37":{"type":"definition","identifier":"problem-37","label":"problem-37","url":"https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2"},"problem-38":{"type":"definition","identifier":"problem-38","label":"problem-38","url":"https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b"},"problem-39":{"type":"definition","identifier":"problem-39","label":"problem-39","url":"https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222"},"problem-40":{"type":"definition","identifier":"problem-40","label":"problem-40","url":"https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8"},"problem-41":{"type":"definition","identifier":"problem-41","label":"problem-41","url":"https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe"},"problem-42":{"type":"definition","identifier":"problem-42","label":"problem-42","url":"https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b"},"problem-43":{"type":"definition","identifier":"problem-43","label":"problem-43","url":"https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec"},"problem-44":{"type":"definition","identifier":"problem-44","label":"problem-44","url":"https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3"},"problem-45":{"type":"definition","identifier":"problem-45","label":"problem-45","url":"https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4"},"problem-46":{"type":"definition","identifier":"problem-46","label":"problem-46","url":"https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6"},"problem-47":{"type":"definition","identifier":"problem-47","label":"problem-47","url":"https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1"},"problem-48":{"type":"definition","identifier":"problem-48","label":"problem-48","url":"https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215"},"problem-49":{"type":"definition","identifier":"problem-49","label":"problem-49","url":"https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e"},"problem-50":{"type":"definition","identifier":"problem-50","label":"problem-50","url":"https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524"},"problem-51":{"type":"definition","identifier":"problem-51","label":"problem-51","url":"https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46"},"problem-52":{"type":"definition","identifier":"problem-52","label":"problem-52","url":"https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4"},"problem-53":{"type":"definition","identifier":"problem-53","label":"problem-53","url":"https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8"},"problem-54":{"type":"definition","identifier":"problem-54","label":"problem-54","url":"https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720"},"problem-55":{"type":"definition","identifier":"problem-55","label":"problem-55","url":"https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4"},"problem-56":{"type":"definition","identifier":"problem-56","label":"problem-56","url":"https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef"},"problem-57":{"type":"definition","identifier":"problem-57","label":"problem-57","url":"https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e"},"problem-58":{"type":"definition","identifier":"problem-58","label":"problem-58","url":"https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb"},"problem-59":{"type":"definition","identifier":"problem-59","label":"problem-59","url":"https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0"},"problem-60":{"type":"definition","identifier":"problem-60","label":"problem-60","url":"https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288"},"problem-61":{"type":"definition","identifier":"problem-61","label":"problem-61","url":"https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84"},"problem-62":{"type":"definition","identifier":"problem-62","label":"problem-62","url":"https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a"},"problem-63":{"type":"definition","identifier":"problem-63","label":"problem-63","url":"https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1"},"problem-64":{"type":"definition","identifier":"problem-64","label":"problem-64","url":"https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788"},"problem-65":{"type":"definition","identifier":"problem-65","label":"problem-65","url":"https://www.nowcoder.com/practice/2a49359695a544b8939c77358d29b7e6"},"problem-66":{"type":"definition","identifier":"problem-66","label":"problem-66","url":"https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8"},"problem-67":{"type":"definition","identifier":"problem-67","label":"problem-67","url":"https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8"}},"footnoteDefinitionMap":{},"paginationUrl":"/posts/2","prev":{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number"},"next":{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring"},"aplayerOptions":null,"postItems":[{"title":"Javascript 踩坑记——继承和原型链","slug":"/post/web/javascript/inherit","tags":["studynote","javascript","ecmascript"],"createdAt":"Sep 05, 2021"},{"title":"防抖和节流","slug":"/post/algorithm/debounce-and-throttle","tags":["coding","debounce","throttle"],"createdAt":"Sep 03, 2021"},{"title":"XSS 与 CSRF 的攻防","slug":"/post/web/security/xss-csrf","tags":["web","web security","csrf"],"createdAt":"Aug 19, 2021"},{"title":"自然对数底数e","slug":"/post/math/calculus/自然对数底数e","tags":["math","函数","极限","自然对数"],"createdAt":"Aug 07, 2021"},{"title":"当你想来一把数独","slug":"/post/game/sudoku","tags":["game","sudoku"],"createdAt":"Aug 01, 2021"},{"title":"精确覆盖问题和 DLX 算法","slug":"/post/algorithm/dlx","tags":["算法","精确覆盖","DLX 算法"],"createdAt":"Jul 24, 2021"},{"title":"洗牌问题和 knuth-shuffle 算法","slug":"/post/algorithm/shuffle","tags":["shuffle","knuth-shuffle","约瑟夫环"],"createdAt":"Jul 22, 2021"},{"title":"统计区间内的线段","slug":"/post/quiz/scanning-line/segments","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"createdAt":"Jul 21, 2021"},{"title":"约瑟夫环问题","slug":"/post/quiz/classical/Josephus-ring","tags":["quiz","经典问题","约瑟夫环"],"createdAt":"Jul 16, 2021"},{"title":"剑指offer 解题报告","slug":"/post/acm/oj/nowcoder/jz-offer","tags":["专题训练","解题报告"],"createdAt":"Jul 15, 2021"},{"title":"不修改数组找出重复的数字","slug":"/post/quiz/partition/find-duplicate-number","tags":["quiz","分治","追击"],"createdAt":"Jun 29, 2021"},{"title":"背包九讲","slug":"/post/algorithm/knapsack","tags":["acm","算法","动态规划","背包问题"],"createdAt":"Jun 27, 2021"},{"title":"React Reconciliation","slug":"/post/web/react/reconciliation","tags":["react","react reconciliation"],"createdAt":"Jun 26, 2021"},{"title":"扔鸡蛋问题","slug":"/post/quiz/dp/egg-drop","tags":["quiz","动态规划"],"createdAt":"Jun 20, 2021"},{"title":"端口管理","slug":"/post/network/端口管理","tags":["network","port","ssh","netstat"],"createdAt":"Jun 20, 2021"},{"title":"最长公共子序列（LCS）","slug":"/post/algorithm/lcs","tags":["最长公共子序列","LCS"],"createdAt":"Jun 02, 2021"},{"title":"最长上升子序列（LIS）","slug":"/post/algorithm/lis","tags":["最长上升子序列","LIS"],"createdAt":"Jun 02, 2021"},{"title":"Dijkstra 算法","slug":"/post/algorithm/graph/shortest-path/dijkstra","tags":["算法","最短路","单源最短路","dijkstra"],"createdAt":"May 29, 2021"},{"title":"函数的极限","slug":"/post/math/calculus/函数的极限","tags":["math","函数","极限"],"createdAt":"May 09, 2021"},{"title":"ECMA 2020 新特性","slug":"/post/web/javascript/2020","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"ECMA 2021 新特性","slug":"/post/web/javascript/2021","tags":["javascript","ecmascript"],"createdAt":"Apr 05, 2021"},{"title":"在 excel 中启用正则表达式","slug":"/post/tool/excel/regex","tags":["excel","tools"],"createdAt":"Mar 29, 2021"},{"title":"CSS 选择器","slug":"/post/web/css/selector","tags":["web","frontend","css"],"createdAt":"Nov 02, 2020"},{"title":"Custom React Hooks","slug":"/post/web/react/hooks/custom","tags":["react","react hooks"],"createdAt":"Oct 29, 2020"},{"title":"组合游戏基础之 SG 函数和 SG 定理","slug":"/post/math/combinatorial/SG","tags":["组合数学","组合游戏","SG 定理"],"createdAt":"Sep 04, 2016"},{"title":"网络流 24 题","slug":"/post/algorithm/graph/network-flow/24-problems","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"createdAt":"Jul 30, 2016"},{"title":"网络流基础之最大权闭合图","slug":"/post/algorithm/graph/network-flow/最大权闭合图","tags":["算法","图论","网络流","最大权闭合图"],"createdAt":"Jul 24, 2016"},{"title":"2016 多校第 2 场","slug":"/post/acm/contest/multi-university-training/2016/2","tags":["acm","训练赛","数据结构","解题报告"],"createdAt":"Jul 22, 2016"},{"title":"二分图","slug":"/post/algorithm/graph/bipartite-graph","tags":["算法","图论","二分图","学习笔记"],"createdAt":"Jul 17, 2016"},{"title":"伸展树专题","slug":"/post/data-structure/bbst/splay","tags":["acm","Splay","解题报告","专题训练"],"createdAt":"Jul 03, 2016"},{"title":"CCF 2015-09 最佳文章 解题报告","slug":"/post/acm/oj/ccf/2015/09/E","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"createdAt":"Jun 26, 2016"},{"title":"编译原理-语法制导翻译实现计算器","slug":"/post/fundamentals-of-compiling/exercise","tags":["编译原理","语法制导翻译","计算机"],"createdAt":"Jun 23, 2016"},{"title":"编译原理-语法分析","slug":"/post/fundamentals-of-compiling/grammar","tags":["编译原理","语法分析","计算机"],"createdAt":"Jun 18, 2016"},{"title":"百度之星 2016 解题报告","slug":"/post/acm/contest/baiduzhixing/2016","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"createdAt":"Jun 03, 2016"},{"title":"数论基础之原根","slug":"/post/math/number-theory/原根","tags":["math","数论","原根"],"createdAt":"May 16, 2016"},{"title":"数论基础之欧拉函数","slug":"/post/math/number-theory/欧拉函数","tags":["math","数论","既约剩余系","欧拉函数"],"createdAt":"May 10, 2016"},{"title":"数论基础之筛法","slug":"/post/math/number-theory/sieve","tags":["math","数论","素数","欧拉函数","线性筛"],"createdAt":"May 06, 2016"},{"title":"数论基础之模方程初步","slug":"/post/math/number-theory/模方程/basic","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"createdAt":"May 04, 2016"},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","slug":"/post/acm/oj/hdu/5576","tags":["acm","动态规划","解题报告"],"createdAt":"Apr 24, 2016"},{"title":"树链剖分","slug":"/post/algorithm/tree/tcs","tags":["acm","算法","树链剖分"],"createdAt":"Apr 23, 2016"},{"title":"51nod-1462 数据结构 -- 解题报告","slug":"/post/acm/oj/51nod/1462","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 23, 2016"},{"title":"小球放盒模型","slug":"/post/math/combinatorial/小球放盒模型","tags":["math","组合数学"],"createdAt":"Apr 22, 2016"},{"title":"最长回文子串 Manacher 算法","slug":"/post/algorithm/string/manacher","tags":["算法","字符串","回文串","manacher"],"createdAt":"Apr 18, 2016"},{"title":"POJ-1324 Holedox Moving 解题报告","slug":"/post/acm/oj/poj/1324","tags":["acm","bfs","图论","状态压缩","解题报告"],"createdAt":"Apr 13, 2016"},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","slug":"/post/acm/oj/hdu/5574","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"createdAt":"Apr 12, 2016"},{"title":"快速傅里叶变换和雷德算法","slug":"/post/math/number-theory/fft","tags":["acm","大数乘法","fft","快速傅里叶变换"],"createdAt":"Apr 10, 2016"},{"title":"HDU-5306 Gorgeous Sequence 解题报告","slug":"/post/acm/oj/hdu/5306","tags":["acm","数据结构","线段树","解题报告"],"createdAt":"Apr 09, 2016"}]},"__N_SSG":true},"page":"/post/[...slug]","query":{"slug":["acm","oj","nowcoder","jz-offer"]},"buildId":"ibuFGMOdHg4Yu7IeAV1Yh","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>