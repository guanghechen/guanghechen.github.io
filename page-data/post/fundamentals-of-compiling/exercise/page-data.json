{"componentChunkName":"component---src-layout-post-post-tsx","path":"/post/fundamentals-of-compiling/exercise/","result":{"data":{"content":{"title":"编译原理-语法制导翻译实现计算器","description":"编译原理-语法制导翻译实现计算器","createdAt":"June 23, 2016","updatedAt":null,"timeToRead":"5min 42s","frontmatter2":{"aplayer":null,"wechatThumbnail":null},"toc":{"children":[{"depth":2,"identifier":"heading-前言","contents":[{"type":"text","value":"前言"}],"children":[]},{"depth":2,"identifier":"heading-文法","contents":[{"type":"text","value":"文法"}],"children":[{"depth":3,"identifier":"heading-ll-1-预测分析表","contents":[{"type":"text","value":"LL(1) 预测分析表："}],"children":[]},{"depth":3,"identifier":"heading-sdd","contents":[{"type":"text","value":"SDD"}],"children":[]}]},{"depth":2,"identifier":"heading-程序实现","contents":[{"type":"text","value":"程序实现"}],"children":[]},{"depth":2,"identifier":"heading-related","contents":[{"type":"text","value":"Related"}],"children":[]}]},"categories":[],"tags":["编译原理","语法制导翻译","计算机"],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"前言"}],"identifier":"heading-前言"},{"type":"paragraph","children":[{"type":"text","value":"设计一个文法，匹配合法的计算式，并返回正确计算式的结果。"}]},{"type":"paragraph","children":[{"type":"text","value":"一些定义："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"语法制导定义（Syntax-directed definitions, "},{"type":"strong","children":[{"type":"text","value":"SDD"}]},{"type":"text","value":"）"}]},{"type":"listItem","children":[{"type":"text","value":"语法制导翻译方案（Syntax-directed Translation Schema, "},{"type":"strong","children":[{"type":"text","value":"SDT"}]},{"type":"text","value":"）"}]}]},{"type":"paragraph","children":[{"type":"text","value":"其它一些编译原理相关的前置知识可以参考： "},{"type":"linkReference","identifier":"compiling-grammar","label":"compiling-grammar","referenceType":"full","children":[{"type":"text","value":"编译原理-语法分析 | 光和尘"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"文法"}],"identifier":"heading-文法"},{"type":"paragraph","children":[{"type":"text","value":"对于一个只支持加减乘除、括号、正负数的计算表达式，不难得到其产生式："}]},{"type":"math","value":"  \\begin{aligned}\n    &A \\rightarrow BD \\mid +BD \\mid -BD \\\\\n    &B \\rightarrow CE \\\\\n    &C \\rightarrow digit \\mid (A) \\\\\n    &D \\rightarrow +BD \\mid -BD \\mid \\varepsilon \\\\\n    &E \\rightarrow \\times CE \\mid \\div CE \\mid \\varepsilon \\\\\n  \\end{aligned}\n"},{"type":"paragraph","children":[{"type":"text","value":"可求得它的 "},{"type":"inlineMath","value":"\\mathsf{FIRST}"},{"type":"text","value":" 和 "},{"type":"inlineMath","value":"\\mathsf{FOLLOW}"},{"type":"text","value":" 集为："}]},{"type":"math","value":"  \\begin{aligned}\n    \\mathsf{FIRST}(A)   &= \\Big\\lbrace digit,(,+,- \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(A)  &= \\Big\\lbrace \\$,) \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(B)   &= \\Big\\lbrace digit,( \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(B)  &= \\Big\\lbrace \\$,),+,- \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(C)   &= \\Big\\lbrace digit,( \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(C)  &= \\Big\\lbrace \\$,),*,\\div,+,- \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(D)   &= \\Big\\lbrace +,-,\\varepsilon \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(D)  &= \\Big\\lbrace \\$,) \\Big\\rbrace\\\\\n    \\mathsf{FIRST}(E)   &= \\Big\\lbrace \\times,\\div,\\varepsilon \\Big\\rbrace &\\quad\n    \\mathsf{FOLLOW}(E)  &= \\Big\\lbrace \\$,),+,- \\Big\\rbrace\\\\\n  \\end{aligned}\n"},{"type":"heading","depth":3,"children":[{"type":"text","value":"LL(1) 预测分析表："}],"identifier":"heading-ll-1-预测分析表"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Token"}]},{"type":"tableCell","children":[{"type":"text","value":"digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"("}]},{"type":"tableCell","children":[{"type":"inlineMath","value":")"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"+"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"-"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"*"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\div"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\$"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"A"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow -BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"B"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"C"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow (A)"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"D"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow -BD"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"inlineMath","value":"E"}]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\times CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\div CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]}]}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"SDD"}],"identifier":"heading-sdd"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"#"}]},{"type":"tableCell","children":[{"type":"text","value":"产生式"}]},{"type":"tableCell","children":[{"type":"text","value":"语义规则"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"0"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow +BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"2"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"A \\rightarrow -BD"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.inh    &= -B.syn\\\\ A.syn &= D.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"3"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"B \\rightarrow CE"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E.inh    &= C.syn\\\\ B.syn &= E.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"4"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow digit"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} C.syn    &= digit.lexval \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"5"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"C \\rightarrow (A)"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} C.syn    &= A.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"6"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow +BD_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D_1.inh  &= D.inh + B.syn\\\\ D.syn  &= D_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"7"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow -BD_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D_1.inh  &= D.inh - B.syn\\\\ D.syn  &= D_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"8"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"D \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} D.syn    &= D.inh \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"9"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\times CE_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E_1.inh  &= E.inh \\times C.syn\\\\ E.syn &= E_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"10"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\div CE_1"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E_1.inh  &= E.inh \\div C.syn\\\\ E.syn &= E_1.syn \\end{align}"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"11"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"E \\rightarrow \\varepsilon"}]},{"type":"tableCell","children":[{"type":"inlineMath","value":"\\begin{align} E.syn    &= E.inh \\end{align}"}]}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"程序实现"}],"identifier":"heading-程序实现"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"C++"}]},{"type":"code","lang":"cpp","meta":"title=\"calculator.cpp\" sourcefile=\"./calculator.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <exception>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct node {\n  int id, syn, inh;\n  node(int id = 0, int syn = 0, int inh = 0) : id(id), syn(syn), inh(inh) {\n  }\n};\nchar ll1Idx[128];\nint ll1Table[10][10];\nvector<int> ssdTable[10];\n\ninline int idx(char c) {\n  return ll1Idx[c];\n}\n\ninline void initLL1Table() {\n  memset(ll1Idx, 0, sizeof ll1Idx);\n  memset(ll1Table, -1, sizeof ll1Table);\n\n  for (int k = '0'; k <= '9'; ++k) ll1Idx[k] = 1;\n  ll1Idx['('] = 2;\n  ll1Idx[')'] = 3;\n  ll1Idx['+'] = 4;\n  ll1Idx['-'] = 5;\n  ll1Idx['*'] = 6;\n  ll1Idx['/'] = 7;\n  ll1Idx['$'] = 8;\n\n  ll1Idx['A'] = -1;\n  ll1Idx['B'] = -2;\n  ll1Idx['C'] = -3;\n  ll1Idx['D'] = -4;\n  ll1Idx['E'] = -5;\n\n  // 0: A -> BD\n  ll1Table[1][1] = 0;\n  ll1Table[1][2] = 0;\n\n  // 1: A -> +BD\n  ll1Table[1][4] = 1;\n\n  // 2: A -> -BD\n  ll1Table[1][5] = 2;\n\n  // 3: B --> CE\n  ll1Table[2][1] = 3;\n  ll1Table[2][2] = 3;\n\n  // 4: C --> digit\n  ll1Table[3][1] = 4;\n\n  // 5: C --> (A)\n  ll1Table[3][2] = 5;\n\n  // 6: D --> +BD\n  ll1Table[4][4] = 6;\n\n  // 7: D --> -BD\n  ll1Table[4][5] = 7;\n\n  // 8: D --> \\varepsilon\n  ll1Table[4][3] = 8;\n  ll1Table[4][8] = 8;\n\n  // 9: E --> *CE\n  ll1Table[5][6] = 9;\n\n  // 10: E --> /CE\n  ll1Table[5][7] = 10;\n\n  // 11: E --> \\varepsilon\n  ll1Table[5][3] = 11;\n  ll1Table[5][4] = 11;\n  ll1Table[5][5] = 11;\n  ll1Table[5][8] = 11;\n}\n\n\ninline void initSSDTable() {\n#define pb push_back\n  for (int i = 0; i < 10; ++i) ssdTable[i].clear();\n\n  // 0: A --> BD\n  ssdTable[0].pb(idx('B'));\n  ssdTable[0].pb(idx('D'));\n\n  // 1: A --> +BD\n  ssdTable[1].pb(idx('+'));\n  ssdTable[1].pb(idx('B'));\n  ssdTable[1].pb(idx('D'));\n\n  // 2: A --> -BD\n  ssdTable[2].pb(idx('-'));\n  ssdTable[2].pb(idx('B'));\n  ssdTable[2].pb(idx('D'));\n\n  // 3: B --> CE\n  ssdTable[3].pb(idx('C'));\n  ssdTable[3].pb(idx('E'));\n\n  // 4: C --> digit\n  ssdTable[4].pb(idx('0'));\n\n  // 5: C -> (A)\n  ssdTable[5].pb(idx('('));\n  ssdTable[5].pb(idx('A'));\n  ssdTable[5].pb(idx(')'));\n\n  // 6: D --> +BD\n  ssdTable[6].pb(idx('+'));\n  ssdTable[6].pb(idx('B'));\n  ssdTable[6].pb(idx('D'));\n\n  // 7: D --> -BD\n  ssdTable[7].pb(idx('-'));\n  ssdTable[7].pb(idx('B'));\n  ssdTable[7].pb(idx('D'));\n\n  // 8: D --> \\varepsilon\n\n  // 9: E --> *CE\n  ssdTable[9].pb(idx('*'));\n  ssdTable[9].pb(idx('C'));\n  ssdTable[9].pb(idx('E'));\n\n  // 10: E --> /CE\n  ssdTable[10].pb(idx('/'));\n  ssdTable[10].pb(idx('C'));\n  ssdTable[10].pb(idx('E'));\n\n  // 11: E --> \\varepsilon\n#undef pb\n}\n\nint getnum(const char*& s) {\n  int num = 0;\n  for (; isdigit(*s); ++s) num = num * 10 + *s - '0';\n  return num;\n}\n\nconst int endsym = idx('$');\nvoid calculate(const char*& s, node& sy, int cur) {\n  int id = idx(*s);\n  if (!id) throw \"Syntax Error\";\n\n  if (sy.id != endsym) {\n    if (sy.id == id) {\n      if (id == 1) {\n        sy.syn = getnum(s);\n      } else {\n        ++s;\n      }\n      return;\n    }\n    if (sy.id > 0) throw \"Syntax Error!\";\n\n    int Mid = ll1Table[-sy.id][id];\n    if (Mid < 0) throw \"Syntax Error!\";\n\n    node sym[4];\n\n    for (int i = 0; i < ssdTable[Mid].size(); ++i) sym[i].id = ssdTable[Mid][i];\n    if (ssdTable[Mid].size()) calculate(s, sym[0], cur + 1);\n\n    switch (Mid) {\n      // 0: A --> BD\n      case 0:\n        sym[1].inh = sym[0].syn;\n        calculate(s, sym[1], cur + 1);\n        sy.syn = sym[1].syn;\n        break;\n\n      // 1: A --> +BD\n      case 1:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 2: A --> -BD\n      case 2:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = -sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 3: B --> CE\n      case 3:\n        sym[1].inh = sym[0].syn;\n        calculate(s, sym[1], cur + 1);\n        sy.syn = sym[1].syn;\n        break;\n\n      // 4: C --> digit\n      case 4:\n        sy.syn = sym[0].syn;\n        break;\n\n      // 5: C --> (A)\n      case 5:\n        calculate(s, sym[1], cur + 1);\n        sy.syn = sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        break;\n\n      // 6: D --> +BD\n      case 6:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh + sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 7: D --> -BD\n      case 7:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh - sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 8: D --> \\varepsilon\n      case 8:\n        sy.syn = sy.inh;\n        break;\n\n      // 9: E --> *CE\n      case 9:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh * sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 10: E --> /CE\n      case 10:\n        calculate(s, sym[1], cur + 1);\n        sym[2].inh = sy.inh / sym[1].syn;\n        calculate(s, sym[2], cur + 1);\n        sy.syn = sym[2].syn;\n        break;\n\n      // 11: E --> \\varepsilon\n      case 11:\n        sy.syn = sy.inh;\n        break;\n    }\n  }\n}\n\nint main() {\n  string in;\n  string coin;\n  initLL1Table();\n  initSSDTable();\n  while (getline(cin, in)) {\n    in.push_back('$');\n    int len = in.length();\n    const char* s = in.c_str();\n\n    // 去除空格\n    coin.clear();\n    for (int i = 0; i < len; ++i)\n      if (s[i] != ' ' && s[i] != '\\t' && s[i] != '\\n') coin.push_back(s[i]);\n    coin.push_back('\\0');\n\n    try {\n      node sy = node(idx('A'));\n      s = coin.c_str();\n      calculate(s, sy, 0);\n      int ans = sy.syn;\n      for (int i = 0; i < len - 1; ++i) putchar(in[i]);\n      printf(\" = %d\\n\", ans);\n      printf(\"succuss!\\n\");\n    } catch (const char* str) {\n      puts(str);\n    }\n  }\n  return 0;\n}\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"Typescript (可以直接使用 "},{"type":"linkReference","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/calculate"}]},{"type":"text","value":")"}]},{"type":"code","lang":"typescript","meta":"title=\"calculator.ts\" sourcefile=\"./calculator.ts\" maxlines=\"20\" collapsed linenos","value":"export function calculate(rawExpression: string): number {\n  let cur = 0\n  const expression = rawExpression.replace(/[\\s]+/g, '')\n  const result: number = dfs(idx('A'), 0, 0)\n  return cur === expression.length ? result : Number.NaN\n\n  function dfs(id: number, syn: number, inh: number): number {\n    if (cur === expression.length) {\n      // Only D and E could be parsed as \\varepsilon\n      if (id === TokenSymbol.D || id === TokenSymbol.E) return inh\n      return Number.NaN\n    }\n\n    const id0 = idx(expression[cur])\n\n    // Unrecognized symbol.\n    if (id0 === undefined) return Number.NaN\n\n    // Matched an operator.\n    if (id === id0) {\n      // Matched digits.\n      if (id0 === TokenSymbol.DIGIT) {\n        const [nextCur, value] = getNum(expression, cur)\n\n        // No valid digit found.\n        if (cur === nextCur) return Number.NaN\n\n        cur = nextCur\n        return value\n      }\n\n      cur += 1\n      return syn\n    }\n\n    // Syntax error.\n    if (id > 0) return Number.NaN\n\n    const ssdId = ll1Table[-id][id0]\n    if (ssdId < 0) return Number.NaN\n\n    const tokens: ReadonlyArray<number> = sddTable[ssdId]\n    const syn0: number = tokens.length > 0 ? dfs(tokens[0], 0, 0) : 0\n\n    switch (ssdId) {\n      // 0: A --> BD\n      case 0:\n        return dfs(tokens[1], 0, syn0)\n\n      // 1: A --> +BD\n      case 1: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, val1)\n      }\n\n      // 2: A --> -BD\n      case 2: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, -val1)\n      }\n\n      // 3: B --> CE\n      case 3:\n        return dfs(tokens[1], 0, syn0)\n\n      // 4: C --> digit\n      case 4:\n        return syn0\n\n      // 5: C --> (A)\n      case 5: {\n        const result: number = dfs(tokens[1], 0, 0)\n        dfs(tokens[2], 0, 0)\n        return result\n      }\n\n      // 6: D --> +BD\n      case 6: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh + val1)\n      }\n\n      // 7: D --> -BD\n      case 7: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh - val1)\n      }\n\n      // 8: D --> \\varepsilon\n      case 8:\n        return inh\n\n      // 9: E --> *CE\n      case 9: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh * val1)\n      }\n\n      // 10: E --> /CE\n      case 10: {\n        const val1: number = dfs(tokens[1], 0, 0)\n        return dfs(tokens[2], 0, inh / val1)\n      }\n\n      // 11: E --> \\varepsilon\n      case 11:\n        return inh\n    }\n\n    return 0\n  }\n}\n\nexport enum TokenSymbol {\n  DIGIT = 1,\n  OPEN_PAREN = 2,\n  CLOSE_PAREN = 3,\n  PLUS = 4,\n  MINUS = 5,\n  MULTI = 6,\n  DIVIDE = 7,\n  END = 8,\n  A = -1,\n  B = -2,\n  C = -3,\n  D = -4,\n  E = -5,\n}\n\n/**\n * Priority map.\n */\nconst ll1IdxMap: Record<string, TokenSymbol> = Object.freeze({\n  '0': TokenSymbol.DIGIT,\n  '1': TokenSymbol.DIGIT,\n  '2': TokenSymbol.DIGIT,\n  '3': TokenSymbol.DIGIT,\n  '4': TokenSymbol.DIGIT,\n  '5': TokenSymbol.DIGIT,\n  '6': TokenSymbol.DIGIT,\n  '7': TokenSymbol.DIGIT,\n  '8': TokenSymbol.DIGIT,\n  '9': TokenSymbol.DIGIT,\n  '(': TokenSymbol.OPEN_PAREN,\n  ')': TokenSymbol.CLOSE_PAREN,\n  '+': TokenSymbol.PLUS,\n  '-': TokenSymbol.MINUS,\n  '*': TokenSymbol.MULTI,\n  '/': TokenSymbol.DIVIDE,\n  $: TokenSymbol.END,\n  A: TokenSymbol.A,\n  B: TokenSymbol.B,\n  C: TokenSymbol.C,\n  D: TokenSymbol.D,\n  E: TokenSymbol.E,\n})\n\nexport const idx = (c: string): number => ll1IdxMap[c]\n\nexport const sddTable: number[][] = [\n  'BD', //    0: A --> BD\n  '+BD', //   1: A --> +BD\n  '-BD', //   2: A --> -BD\n  'CE', //    3: B --> CE\n  '0', //     4: C --> digit\n  '(A)', //   5: C --> (A)\n  '+BD', //   6: D --> +BD\n  '-BD', //   7: D --> -BD\n  '', //      8: D --> \\varepsilon\n  '*CE', //   9: E --> *CE\n  '/CE', //  10: E --> /CE\n  '', //     11: E --> \\varepsilon\n].map(x => x.split('').map(idx))\n\n// tokens: A,B,C,D,E\nexport const MAX_TOKENS = 5\n\n// symbols: digit, (, ), +, -, *, /, $\nexport const MAX_SYMBOLS = 8\n\n// LL1 table.\nexport const ll1Table: Int8Array[] = new Array(MAX_TOKENS + 1)\n\n// Initialize LL1Table\n{\n  for (let i = 0; i <= MAX_TOKENS; ++i) {\n    ll1Table[i] = new Int8Array(MAX_SYMBOLS + 1).fill(-1)\n  }\n\n  // 0: A -> BD\n  ll1Table[1][1] = 0\n  ll1Table[1][2] = 0\n\n  // 1: A -> +BD\n  ll1Table[1][4] = 1\n\n  // 2: A -> -BD\n  ll1Table[1][5] = 2\n\n  // 3: B --> CE\n  ll1Table[2][1] = 3\n  ll1Table[2][2] = 3\n\n  // 4: C --> digit\n  ll1Table[3][1] = 4\n\n  // 5: C --> (A)\n  ll1Table[3][2] = 5\n\n  // 6: D --> +BD\n  ll1Table[4][4] = 6\n\n  // 7: D --> -BD\n  ll1Table[4][5] = 7\n\n  // 8: D --> \\varepsilon\n  ll1Table[4][3] = 8\n  ll1Table[4][8] = 8\n\n  // 9: E --> *CE\n  ll1Table[5][6] = 9\n\n  // 10: E --> /CE\n  ll1Table[5][7] = 10\n\n  // 11: E --> \\varepsilon\n  ll1Table[5][3] = 11\n  ll1Table[5][4] = 11\n  ll1Table[5][5] = 11\n  ll1Table[5][8] = 11\n}\n\nexport function getNum(s: string, start: number): [number, number] {\n  let result = 0\n  let i: number = start\n  for (; i < s.length; ++i) {\n    const c = s[i]\n    if (!/\\d/.test(c)) break\n    result = result * 10 + Number(c)\n  }\n  return [i, result]\n}\n"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Related"}],"identifier":"heading-related"},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"linkReference","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","referenceType":"collapsed","children":[{"type":"text","value":"@algorithm.ts/calculate"}]}]},{"type":"listItem","children":[{"type":"linkReference","identifier":"compiling-grammar","label":"compiling-grammar","referenceType":"full","children":[{"type":"text","value":"编译原理-语法分析 | 光和尘"}]}]}]}]},"ecmaImports":[],"definitionMap":{"@algorithm.ts/calculate":{"type":"definition","identifier":"@algorithm.ts/calculate","label":"@algorithm.ts/calculate","url":"https://github.com/guanghechen/algorithm.ts/tree/main/packages/calculate#readme"},"compiling-grammar":{"type":"definition","identifier":"compiling-grammar","label":"compiling-grammar","url":"https://me.guanghechen.com/post/fundamentals-of-compiling/grammar/"}},"footnoteDefinitionMap":{},"fields":{"slug":"/post/fundamentals-of-compiling/exercise/"}},"previous":{"title":"编译原理-语法分析","fields":{"slug":"/post/fundamentals-of-compiling/grammar/"}},"next":{"title":"CCF 2015-09 最佳文章 解题报告","fields":{"slug":"/post/acm/oj/ccf/2015/09/E/"}},"postItems":{"nodes":[{"title":"Custom React Hooks","createdAt":"2020-10-30","tags":["react","react hooks"],"fields":{"slug":"/post/web/react/hooks/custom/"}},{"title":"React Reconciliation","createdAt":"2021-06-27","tags":["react","react reconciliation"],"fields":{"slug":"/post/web/react/reconciliation/"}},{"title":"ECMA 2020 新特性","createdAt":"2021-04-05","tags":["javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/2020/"}},{"title":"XSS 与 CSRF 的攻防","createdAt":"2021-08-19","tags":["web","web security","csrf"],"fields":{"slug":"/post/web/security/xss-csrf/"}},{"title":"Javascript 踩坑记——继承和原型链","createdAt":"2021-09-05","tags":["studynote","javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/inherit/"}},{"title":"CSS 选择器","createdAt":"2020-11-02","tags":["web","frontend","css"],"fields":{"slug":"/post/web/css/selector/"}},{"title":"ECMA 2021 新特性","createdAt":"2021-04-05","tags":["javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/2021/"}},{"title":"在 excel 中启用正则表达式","createdAt":"2021-03-30","tags":["excel","tools"],"fields":{"slug":"/post/tool/excel/regex/"}},{"title":"统计区间内的线段","createdAt":"2021-07-21","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"fields":{"slug":"/post/quiz/scanning-line/segments/"}},{"title":"约瑟夫环问题","createdAt":"2021-07-17","tags":["quiz","经典问题","约瑟夫环"],"fields":{"slug":"/post/quiz/classical/Josephus-ring/"}},{"title":"端口管理","createdAt":"2021-06-20","tags":["network","port","ssh","netstat"],"fields":{"slug":"/post/network/端口管理/"}},{"title":"数论基础之欧拉函数","createdAt":"2016-05-10","tags":["math","数论","既约剩余系","欧拉函数"],"fields":{"slug":"/post/math/number-theory/欧拉函数/"}},{"title":"扔鸡蛋问题","createdAt":"2021-06-20","tags":["quiz","动态规划"],"fields":{"slug":"/post/quiz/dp/egg-drop/"}},{"title":"数论基础之模方程初步","createdAt":"2016-05-04","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"fields":{"slug":"/post/math/number-theory/模方程/basic/"}},{"title":"不修改数组找出重复的数字","createdAt":"2021-06-29","tags":["quiz","分治","追击"],"fields":{"slug":"/post/quiz/partition/find-duplicate-number/"}},{"title":"数论基础之原根","createdAt":"2016-05-16","tags":["math","数论","原根"],"fields":{"slug":"/post/math/number-theory/原根/"}},{"title":"快速傅里叶变换和雷德算法","createdAt":"2016-04-10","tags":["acm","大数乘法","fft","快速傅里叶变换"],"fields":{"slug":"/post/math/number-theory/fft/"}},{"title":"小球放盒模型","createdAt":"2016-04-22","tags":["math","组合数学"],"fields":{"slug":"/post/math/combinatorial/小球放盒模型/"}},{"title":"组合游戏基础之 SG 函数和 SG 定理","createdAt":"2016-09-04","tags":["组合数学","组合游戏","SG 定理"],"fields":{"slug":"/post/math/combinatorial/SG/"}},{"title":"数论基础之筛法","createdAt":"2016-05-06","tags":["math","数论","素数","欧拉函数","线性筛"],"fields":{"slug":"/post/math/number-theory/sieve/"}},{"title":"函数的极限","createdAt":"2021-05-09","tags":["math","函数","极限"],"fields":{"slug":"/post/math/calculus/函数的极限/"}},{"title":"当你想来一把数独","createdAt":"2021-08-01","tags":["game","sudoku"],"fields":{"slug":"/post/game/sudoku/"}},{"title":"编译原理-语法制导翻译实现计算器","createdAt":"2016-06-23","tags":["编译原理","语法制导翻译","计算机"],"fields":{"slug":"/post/fundamentals-of-compiling/exercise/"}},{"title":"编译原理-语法分析","createdAt":"2016-06-18","tags":["编译原理","语法分析","计算机"],"fields":{"slug":"/post/fundamentals-of-compiling/grammar/"}},{"title":"伸展树专题","createdAt":"2016-07-03","tags":["acm","Splay","解题报告","专题训练"],"fields":{"slug":"/post/data-structure/bbst/splay/"}},{"title":"洗牌问题和 knuth-shuffle 算法","createdAt":"2021-07-22","tags":["shuffle","knuth-shuffle","约瑟夫环"],"fields":{"slug":"/post/algorithm/shuffle/"}},{"title":"自然对数底数e","createdAt":"2021-08-07","tags":["math","函数","极限","自然对数"],"fields":{"slug":"/post/math/calculus/自然对数底数e/"}},{"title":"树链剖分","createdAt":"2016-04-23","tags":["acm","算法","树链剖分"],"fields":{"slug":"/post/algorithm/tree/tcs/"}},{"title":"最长上升子序列（LIS）","createdAt":"2021-06-02","tags":["最长上升子序列","LIS"],"fields":{"slug":"/post/algorithm/lis/"}},{"title":"最长回文子串 Manacher 算法","createdAt":"2016-04-18","tags":["算法","字符串","回文串","manacher"],"fields":{"slug":"/post/algorithm/string/manacher/"}},{"title":"最长公共子序列（LCS）","createdAt":"2021-06-02","tags":["最长公共子序列","LCS"],"fields":{"slug":"/post/algorithm/lcs/"}},{"title":"背包九讲","createdAt":"2021-06-27","tags":["acm","算法","动态规划","背包问题"],"fields":{"slug":"/post/algorithm/knapsack/"}},{"title":"Dijkstra 算法","createdAt":"2021-05-29","tags":["算法","最短路","单源最短路","dijkstra"],"fields":{"slug":"/post/algorithm/graph/shortest-path/dijkstra/"}},{"title":"二分图","createdAt":"2016-07-17","tags":["算法","图论","二分图","学习笔记"],"fields":{"slug":"/post/algorithm/graph/bipartite-graph/"}},{"title":"防抖和节流","createdAt":"2021-09-03","tags":["coding","debounce","throttle"],"fields":{"slug":"/post/algorithm/debounce-and-throttle/"}},{"title":"精确覆盖问题和 DLX 算法","createdAt":"2021-07-24","tags":["算法","精确覆盖","DLX 算法"],"fields":{"slug":"/post/algorithm/dlx/"}},{"title":"POJ-1324 Holedox Moving 解题报告","createdAt":"2016-04-13","tags":["acm","bfs","图论","状态压缩","解题报告"],"fields":{"slug":"/post/acm/oj/poj/1324/"}},{"title":"网络流 24 题","createdAt":"2016-07-30","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"fields":{"slug":"/post/algorithm/graph/network-flow/24-problems/"}},{"title":"网络流基础之最大权闭合图","createdAt":"2016-07-24","tags":["算法","图论","网络流","最大权闭合图"],"fields":{"slug":"/post/algorithm/graph/network-flow/最大权闭合图/"}},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","createdAt":"2016-04-24","tags":["acm","动态规划","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5576/"}},{"title":"剑指offer 解题报告","createdAt":"2021-07-15","tags":["专题训练","解题报告"],"fields":{"slug":"/post/acm/oj/nowcoder/jz-offer/"}},{"title":"2016 多校第 2 场","createdAt":"2016-07-22","tags":["acm","训练赛","数据结构","解题报告"],"fields":{"slug":"/post/acm/contest/multi-university-training/2016/2/"}},{"title":"HDU-5306 Gorgeous Sequence 解题报告","createdAt":"2016-04-09","tags":["acm","数据结构","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5306/"}},{"title":"51nod-1462 数据结构 -- 解题报告","createdAt":"2016-04-23","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/51nod/1462/"}},{"title":"百度之星 2016 解题报告","createdAt":"2016-06-03","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"fields":{"slug":"/post/acm/contest/baiduzhixing/2016/"}},{"title":"CCF 2015-09 最佳文章 解题报告","createdAt":"2016-06-26","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"fields":{"slug":"/post/acm/oj/ccf/2015/09/E/"}},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","createdAt":"2016-04-12","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5574/"}}]}},"pageContext":{"id":"3af67613-34da-57e7-8bd4-16a93b220bbe","contentType":"post","paginationUrl":"/posts","previousPostId":"c8391ec6-8cfb-513f-aa20-9edd0c4cf128","nextPostId":"28796702-d9e7-5ce3-8c3b-533e145b4bdb"}},"staticQueryHashes":[],"slicesMap":{}}