{"componentChunkName":"component---src-layout-post-post-tsx","path":"/post/data-structure/bbst/splay/","result":{"data":{"content":{"title":"伸展树专题","description":"伸展树专题","createdAt":"July 03, 2016","updatedAt":null,"timeToRead":"7min 5s","frontmatter2":{"aplayer":null,"wechatThumbnail":null},"toc":{"children":[{"depth":2,"identifier":"heading-题目","contents":[{"type":"text","value":"题目"}],"children":[{"depth":3,"identifier":"heading-hihocoder-1329","contents":[{"type":"text","value":"hihoCoder/1329"}],"children":[]},{"depth":3,"identifier":"heading-hihocoder-1333","contents":[{"type":"text","value":"hihoCoder/1333"}],"children":[]},{"depth":3,"identifier":"heading-hysbz-1269","contents":[{"type":"text","value":"HYSBZ/1269"}],"children":[]},{"depth":3,"identifier":"heading-hysbz-1500","contents":[{"type":"text","value":"HYSBZ/1500"}],"children":[]},{"depth":3,"identifier":"heading-hysbz-1503","contents":[{"type":"text","value":"HYSBZ/1503"}],"children":[]},{"depth":3,"identifier":"heading-la-3961","contents":[{"type":"text","value":"LA/3961"}],"children":[]},{"depth":3,"identifier":"heading-poj-2828","contents":[{"type":"text","value":"POJ/2828"}],"children":[]},{"depth":3,"identifier":"heading-uva-11922","contents":[{"type":"text","value":"UVA/11922"}],"children":[]},{"depth":3,"identifier":"heading-uva-11996","contents":[{"type":"text","value":"UVA/11996"}],"children":[]}]},{"depth":2,"identifier":"heading-summary","contents":[{"type":"text","value":"Summary"}],"children":[]}]},"categories":[],"tags":["acm","Splay","解题报告","专题训练"],"ast":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"题目"}],"identifier":"heading-题目"},{"type":"heading","depth":3,"children":[{"type":"text","value":"hihoCoder/1329"}],"identifier":"heading-hihocoder-1329"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hiho-coder-1329","label":"problem-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1329 平衡树 Splay"}]}]},{"type":"paragraph","children":[{"type":"text","value":"基础题。"}]},{"type":"code","lang":"cpp","meta":"title=\"hihocoder-1329.cpp\" sourcefile=\"./hihocoder-1329.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\n\ntypedef long long LL;\n\nstruct node {\n  int key;\n  int siz;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson->siz + 1;\n    if (x == cnt) return -1;\n    return x < cnt ? 0 : 1;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n  }\n};\n\ntypedef node* root;\ntypedef std::pair<node*, node*> droot;\nconst int MAX_NODES = 200000 + 10;\n\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->lson = null;\n  nodetop->rson = null;\n  return nodetop++;\n}\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = null;\n  o->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\ninline int rank(root o, int key) {\n  if (o == null) return 0;\n  if (key == o->key) return o->lson->siz;\n  if (key < o->key) return rank(o->lson, key);\n  return o->lson->siz + 1 + rank(o->rson, key);\n}\n\ninline void insert(root& o, int id) {\n  int k = rank(o, id);\n  root left, right;\n  root middle = newnode(id);\n  split(o, k, left, right);\n  o = merge(merge(left, middle), right);\n}\n\ninline void remove(root& o, int id1, int id2) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 >= k2) return;\n\n  root left, middle, right;\n  split(o, k1, left, right);\n  split(right, k2 - k1, middle, right);\n  o = merge(left, right);\n}\n\ninline int query(root& o, int key) {\n  if (o == null) return 0;\n  if (key < o->key) return query(o->lson, key);\n  return std::max(o->key, query(o->rson, key));\n}\n\nroot rt;\nvoid Init() {\n  null = new node();\n  null->key = 0;\n  null->siz = 0;\n  null->lson = NULL;\n  null->rson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(0);\n  rt->rson = newnode(1000000001);\n}\n\nint N, arg1, arg2, arg3;\nchar cmd[20];\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nint main() {\n  Init();\n  N = read();\n  for (int i = 1; i <= N; ++i) {\n    scanf(\"%s\", cmd);\n    arg1 = std::min(std::max(read(), 1), 1000000000);\n    if (cmd[0] == 'D') arg2 = std::min(std::max(read(), 1), 1000000000);\n\n    switch (cmd[0]) {\n    case 'I':\n      insert(rt, arg1);\n      break;\n    case 'Q':\n      printf(\"%lld\\n\", query(rt, arg1));\n      break;\n    case 'D':\n      remove(rt, arg1, arg2);\n      break;\n    }\n  }\n  return 0;\n}\n"},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"hihoCoder/1333"}],"identifier":"heading-hihocoder-1333"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hiho-coder-1333","label":"problem-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1333 平衡树 Splay2"}]}]},{"type":"paragraph","children":[{"type":"text","value":"节点中维护 "},{"type":"inlineCode","value":"add"},{"type":"text","value":"，"},{"type":"inlineCode","value":"sum"},{"type":"text","value":"，"},{"type":"inlineCode","value":"key"},{"type":"text","value":"，"},{"type":"inlineCode","value":"siz"},{"type":"text","value":"，"},{"type":"inlineCode","value":"val"},{"type":"text","value":"；其中"}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineCode","value":"key"},{"type":"text","value":" 为每个人的 "},{"type":"inlineCode","value":"id"}]},{"type":"listItem","children":[{"type":"inlineCode","value":"val"},{"type":"text","value":" 为每个人的兴趣值"}]}]},{"type":"paragraph","children":[{"type":"text","value":"在进行区间操作时，利用 "},{"type":"inlineCode","value":"key"},{"type":"text","value":"，计算出左右区间在 Splay 中的名次，然后使用该名次加上基础 Splay 操作就可以了。"}]},{"type":"code","lang":"cpp","meta":"title=\"hihocoder-1333.cpp\" sourcefile=\"./hihocoder-1333.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n\ntypedef long long LL;\n\nstruct node {\n  int key;\n  int siz;\n  int val;\n  int add;\n  LL sum;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson->siz + 1;\n    if (x == cnt) return -1;\n    return x < cnt ? 0 : 1;\n  }\n  void pushdown() {\n    if (!add) return;\n    lson->update(add);\n    rson->update(add);\n    add = 0;\n  }\n  void update(int add) {\n    if (this->lson == NULL) return;\n    this->add += add;\n    this->val += add;\n    this->sum += (LL)add * this->siz;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n    sum = lson->sum + val + rson->sum;\n  }\n};\n\ntypedef node* root;\ntypedef std::pair<node*, node*> droot;\nconst int MAX_NODES = 200000 + 10;\n\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0, int val = 0) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->val = val;\n  nodetop->add = 0;\n  nodetop->sum = val;\n  nodetop->lson = null;\n  nodetop->rson = null;\n  return nodetop++;\n}\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    p->pushdown();\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = null;\n  o->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\ninline int rank(root o, int key) {\n  if (o == null) return 0;\n  if (key == o->key) return o->lson->siz;\n  if (key < o->key) return rank(o->lson, key);\n  return o->lson->siz + 1 + rank(o->rson, key);\n}\n\ninline void insert(root& o, int id, int val) {\n  int k = rank(o, id);\n  root left, right;\n  root middle = newnode(id, val);\n  split(o, k, left, right);\n  o = merge(merge(left, middle), right);\n}\n\ninline void remove(root& o, int id1, int id2) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 >= k2) return;\n\n  root left, middle, right;\n  split(o, k1, left, right);\n  split(right, k2 - k1, middle, right);\n  o = merge(left, right);\n}\n\ninline void update(root& o, int id1, int id2, int add) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 >= k2) return;\n\n  splay(o, k1);\n  splay(o->rson, k2 - k1 + 1);\n  o->rson->lson->update(add);\n  o->rson->maintain();\n  o->maintain();\n}\n\ninline LL query(root& o, int id1, int id2) {\n  int k1 = rank(o, id1);\n  int k2 = rank(o, id2 + 1);\n  if (k1 >= k2) return 0;\n\n  splay(o, k1);\n  splay(o->rson, k2 - k1 + 1);\n  return o->rson->lson->sum;\n}\n\nroot rt;\nvoid Init() {\n  null = new node();\n  null->key = 0;\n  null->siz = 0;\n  null->val = 0;\n  null->add = 0;\n  null->sum = 0;\n  null->lson = NULL;\n  null->rson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(0, 0);\n  rt->rson = newnode(1000000001, 0);\n}\n\nint N, arg1, arg2, arg3;\nchar cmd[20];\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nint main() {\n  Init();\n  N = read();\n  for (int i = 1; i <= N; ++i) {\n    scanf(\"%s\", cmd);\n    arg1 = std::min(std::max(read(), 1), 100000000);\n    arg2 = std::min(std::max(read(), 1), 100000000);\n    if (cmd[0] == 'M') arg3 = read();\n\n    switch (cmd[0]) {\n    case 'I':\n      insert(rt, arg1, arg2);\n      break;\n    case 'Q':\n      printf(\"%lld\\n\", query(rt, arg1, arg2));\n      break;\n    case 'M':\n      update(rt, arg1, arg2, arg3);\n      break;\n    case 'D':\n      remove(rt, arg1, arg2);\n      break;\n    }\n  }\n  return 0;\n}\n"},{"type":"thematicBreak"},{"type":"paragraph","children":[{"type":"text","value":"法二：将原序列离散化到 "},{"type":"inlineMath","value":"1 \\sim N"},{"type":"text","value":"，并建成 Splay，多维护一个区间最小值，利用维护的 "},{"type":"inlineCode","value":"siz"},{"type":"text","value":"，就可以实现名次树的一些功能，就可以快速查找了。"}]},{"type":"code","lang":"cpp","meta":"title=\"LA-3961_2.cpp\" sourcefile=\"./LA-3961_2.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\n\nstruct node {\n  int key;\n  int siz;\n  int minv;\n  bool flip;\n  node* lson;\n  node* rson;\n\n  int cmp(int key) {\n    int cnt = lson->siz + 1;\n    if (key == cnt) return -1;\n    return key < cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson->reverse();\n    rson->reverse();\n    flip = false;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n    minv = std::min(key, std::min(lson->minv, rson->minv));\n  }\n};\n\ntypedef node* root;\nnode* null;\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    p->pushdown();\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d2 ^ 1);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = null;\n  o->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\ninline int kth(root rt) {\n  rt->pushdown();\n  if (rt->key == rt->minv) return rt->lson->siz + 1;\n  if (rt->lson->minv < rt->rson->minv) return kth(rt->lson);\n  return kth(rt->rson) + rt->lson->siz + 1;\n}\n\nconst int MAX_NODES = 100000 + 10;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->minv = key;\n  nodetop->flip = false;\n  nodetop->lson = null;\n  nodetop->rson = null;\n  return nodetop++;\n}\n\ninline void build(root& o, int lft, int rht, int* rank) {\n  int mid = (lft + rht) >> 1;\n  o = newnode(rank[mid]);\n  if (lft < mid) build(o->lson, lft, mid - 1, rank);\n  if (mid < rht) build(o->rson, mid + 1, rht, rank);\n  o->maintain();\n}\n\nconst int MAXN = 100000 + 10;\nconst int INF = 0x3f3f3f3f;\nint N, A[MAXN], id[MAXN], rank[MAXN];\nroot rt;\n\ninline bool cmp(int u, int v) {\n  return A[u] < A[v];\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void init() {\n  nodetop = nodepool;\n}\n\ninline int solve() {\n  int k = kth(rt);\n  splay(rt, k);\n  int ans = rt->lson->siz;\n  if (ans) {\n    rt->lson->reverse();\n    splay(rt->lson, rt->lson->siz);\n    rt = merge(rt->lson, rt->rson);\n  } else\n    rt = rt->rson, rt->pushdown();\n  return ans;\n}\n\nint main() {\n  null = new node();\n  null->key = 0;\n  null->siz = 0;\n  null->minv = INF;\n  null->flip = false;\n  null->lson = NULL;\n  null->rson = NULL;\n\n  while (scanf(\"%d\", &N) == 1 && N) {\n    init();\n    for (int i = 1; i <= N; ++i) A[i] = read();\n    for (int i = 1; i <= N; ++i) id[i] = i;\n    std::stable_sort(id + 1, id + N + 1, cmp);\n    for (int i = 1; i <= N; ++i) rank[id[i]] = i;\n    build(rt, 1, N, rank);\n    for (int i = 1; i < N; ++i) printf(\"%d \", solve() + i);\n    printf(\"%d\\n\", N);\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/06"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"HYSBZ/1269"}],"identifier":"heading-hysbz-1269"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hysbz-1269","label":"problem-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1269 文本编辑器 editor"}]}]},{"type":"paragraph","children":[{"type":"text","value":"都是一些 Splay 的经典操作，为了方便操作，在最最左边和最右边分别加了一个虚拟节点。"}]},{"type":"code","lang":"cpp","meta":"title=\"hysbz-1269.cpp\" sourcefile=\"./hysbz-1269.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\n\nstruct node {\n  char key;\n  int siz;\n  bool flip;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson->siz + 1;\n    if (x == cnt) return -1;\n    return x < cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson->reverse();\n    rson->reverse();\n    flip ^= 1;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n  }\n};\n\ntypedef node* root;\nconst int MAX_NODES = (1 << 22) + 10;\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(char key) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->flip = false;\n  nodetop->lson = null;\n  nodetop->rson = null;\n  return nodetop++;\n}\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    p->pushdown();\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = null;\n  o->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\ninline void build(root& o, int lft, int rht, char* s) {\n  int mid = (lft + rht) >> 1;\n  o = newnode(s[mid]);\n  if (lft < mid) build(o->lson, lft, mid - 1, s);\n  if (mid < rht) build(o->rson, mid + 1, rht, s);\n  o->maintain();\n}\n\nconst int MAXN = (1 << 22) + 10;\nchar s[MAXN];\n\ninline void Move(root& rt, int k) {\n  splay(rt, k);\n}\ninline void Insert(root& rt, int n) {\n  for (s[1] = getchar(); s[1] < 32 || s[1] > 126;) s[1] = getchar();\n  for (int i = 2; i <= n; ++i) s[i] = getchar();\n  root left = rt;\n  root middle;\n  build(middle, 1, n, s);\n  root right = rt->rson;\n  rt->rson = null;\n  rt->maintain();\n  rt = merge(left, merge(middle, right));\n}\ninline void Delete(root& rt, int n) {\n  splay(rt->rson, n);\n  rt->rson = rt->rson->rson;\n  rt->maintain();\n}\ninline void Rotate(root& rt, int n) {\n  splay(rt->rson, n + 1);\n  rt->rson->lson->reverse();\n}\ninline void Get(root& rt) {\n  root o = rt->rson;\n  for (; o->lson != null; o = o->lson) o->pushdown();\n  printf(\"%c\\n\", o->key);\n}\ninline void Prev(root& rt) {\n  splay(rt, rt->lson->siz);\n}\ninline void Next(root& rt) {\n  splay(rt, rt->lson->siz + 2);\n}\n\nroot rt;\ninline void Init() {\n  null = new node();\n  null->key = '\\0';\n  null->siz = 0;\n  null->flip = false;\n  null->lson = NULL;\n  null->rson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(31);\n  rt->rson = newnode(127);\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return s;\n}\n\nchar cmd[20];\n\nint main() {\n  Init();\n\n  int N = read();\n  for (int i = 1; i <= N; ++i) {\n    scanf(\"%s\", cmd);\n    switch (cmd[0]) {\n    case 'M':\n      Move(rt, read() + 1);\n      break;\n    case 'I':\n      Insert(rt, read());\n      break;\n    case 'D':\n      Delete(rt, read());\n      break;\n    case 'R':\n      Rotate(rt, read());\n      break;\n    case 'G':\n      Get(rt);\n      break;\n    case 'P':\n      Prev(rt);\n      break;\n    case 'N':\n      Next(rt);\n      break;\n    }\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/05"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"HYSBZ/1500"}],"identifier":"heading-hysbz-1500"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hysbz-1500","label":"problem-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1500 维修数列"}]}]},{"type":"paragraph","children":[{"type":"text","value":"前五个操作比较简单，第六个操作，需要维护："}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"子树左侧起最大连续和 "},{"type":"inlineMath","value":"mxlv"},{"type":"text","value":"（可以为空）"}]},{"type":"listItem","children":[{"type":"text","value":"子树右侧起最大连续和 "},{"type":"inlineMath","value":"mxrv"},{"type":"text","value":"（可以为空）"}]},{"type":"listItem","children":[{"type":"text","value":"子树中最大连续和 "},{"type":"inlineMath","value":"mxmv"},{"type":"text","value":"（非空）。"}]}]},{"type":"paragraph","children":[{"type":"text","value":"在序列的最左侧和最右侧增加两个虚拟节点就可以很方便了，注意为了不影响结果的正确性，虚拟节点的 sum 值需为 "},{"type":"inlineMath","value":"0"},{"type":"text","value":"，但是节点的 "},{"type":"inlineMath","value":"key,mxlv,mxmv,mxrv"},{"type":"text","value":" 均需设成负无穷。"}]},{"type":"code","lang":"cpp","meta":"title=\"hysbz-1500.cpp\" sourcefile=\"./hysbz-1500.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\n\nconst int INF = 0x3f3f3f3f;\n\nstruct node {\n  int key;\n  int siz;\n  int setv;   // 懒惰标记，表示是否标记为同一个值\n  int sumv;   // 该节点为根的子树的 $\\sum key$\n  int mxlv;   // 该节点为根的子树表示的序列左侧（可以为空）最大连续和\n  int mxmv;   // 该节点为根的子树最大连续和\n  int mxrv;   // 该节点为根的子树表示的序列右侧（可以为空）最大连续和\n  bool flip;   // 懒惰标记，表示是否翻转\n  node* lson;\n  node* rson;\n\n  static node* null;\n\n  int cmp(int x) {\n    int cnt = lson->siz + 1;\n    if (x == cnt) return -1;\n    return x < cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n    std::swap(mxlv, mxrv);\n  }\n  void update(int tag) {\n    setv = tag;\n    key = tag;\n    sumv = tag * siz;\n    mxlv = mxrv = tag > 0 ? sumv : 0;\n    mxmv = tag > 0 ? sumv : tag;\n  }\n  void pushdown() {\n    if (flip) {\n      lson->reverse();\n      rson->reverse();\n      flip = false;\n    }\n    if (setv != -INF) {\n      if (lson != null) lson->update(setv);\n      if (rson != null) rson->update(setv);\n      setv = -INF;\n    }\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n    sumv = lson->sumv + key + rson->sumv;\n    mxlv = std::max(lson->mxlv, lson->sumv + key + rson->mxlv);\n    mxrv = std::max(rson->mxrv, lson->mxrv + key + rson->sumv);\n    mxmv = std::max(lson->mxmv, rson->mxmv);\n    mxmv = std::max(mxmv, lson->mxrv + key + rson->mxlv);\n  }\n};\n\ntypedef node* root;\nnode* node::null = new node();\n\ninline void printtree(root o, int cur = 0) {\n  if (o == node::null) return;\n  o->pushdown();\n  o->maintain();\n  printtree(o->lson, cur + 1);\n  printf(\"cur %d: key=%d, siz=%d, sum=%d\\n\", cur, o->key, o->siz, o->sumv);\n  printtree(o->rson, cur + 1);\n  if (!cur) printf(\"-------------------------------------\\n\");\n}\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\n\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\n\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    p->pushdown();\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = node::null;\n  o->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\n/********************** 以上为 splay 基本操作 *******************/\n\nconst int MAX_NODES = 1000000 + 10;\nstd::queue<root> Qnodepool;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  root nodetop = Qnodepool.front();\n  Qnodepool.pop();\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->setv = -INF;\n  nodetop->sumv = key;\n  nodetop->mxlv = key > 0 ? key : 0;\n  nodetop->mxmv = key;\n  nodetop->mxrv = key > 0 ? key : 0;\n  nodetop->flip = false;\n  nodetop->lson = node::null;\n  nodetop->rson = node::null;\n  return nodetop;\n}\n\ninline void deletenode(root o) {\n  if (o == node::null) return;\n  deletenode(o->lson);\n  deletenode(o->rson);\n  Qnodepool.push(o);\n}\n\ninline void build(root& o, int lft, int rht, int* A) {\n  int mid = (lft + rht) >> 1;\n  o = newnode(A[mid]);\n  if (lft < mid) build(o->lson, lft, mid - 1, A);\n  if (mid < rht) build(o->rson, mid + 1, rht, A);\n  if (A[mid] == -INF) o->sumv = 0;\n  o->maintain();\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nconst int MAXN = 500000 + 10;\nint A[MAXN];\nroot rt;\n\ninline void INSERT(int pos, int tot) {\n  for (int i = 1; i <= tot; ++i) A[i] = read();\n  root left, middle, right;\n  build(middle, 1, tot, A);\n  split(rt, pos + 1, left, right);\n  rt = merge(merge(left, middle), right);\n}\n\ninline void DELETE(int pos, int tot) {\n  splay(rt, pos);\n  splay(rt->rson, tot + 1);\n\n  deletenode(rt->rson->lson);\n\n  rt->rson->lson = node::null;\n  rt->rson->maintain();\n  rt->maintain();\n}\n\ninline void MODIFY(int pos, int tot, int tag) {\n  splay(rt, pos);\n  splay(rt->rson, tot + 1);\n  rt->rson->lson->update(tag);\n  rt->rson->maintain();\n  rt->maintain();\n}\n\ninline void REVERSE(int pos, int tot) {\n  splay(rt, pos);\n  splay(rt->rson, tot + 1);\n  rt->rson->lson->reverse();\n  rt->rson->maintain();\n  rt->maintain();\n}\n\ninline int GETSUM(int pos, int tot) {\n  splay(rt, pos);\n  splay(rt->rson, tot + 1);\n  return rt->rson->lson->sumv;\n}\n\ninline int MAXSUM() {\n  return rt->mxmv;\n}\n\ninline void init() {\n  while (!Qnodepool.empty()) Qnodepool.pop();\n  for (int i = 0; i < MAX_NODES; ++i) Qnodepool.push(nodepool + i);\n  node::null->key = -INF;\n  node::null->siz = 0;\n  node::null->setv = -INF;\n  node::null->sumv = 0;\n  node::null->mxlv = 0;\n  node::null->mxmv = -INF;\n  node::null->mxrv = 0;\n  node::null->flip = false;\n  node::null->lson = NULL;\n  node::null->rson = NULL;\n}\n\nint main() {\n  init();\n\n  int N = read();\n  int Q = read();\n\n  for (int i = 1; i <= N; ++i) A[i] = read();\n  A[0] = A[N + 1] = -INF;\n  build(rt, 0, N + 1, A);\n  while (Q--) {\n    char cmd[20];\n    scanf(\"%s\", cmd);\n    if (cmd[0] == 'M' && cmd[2] == 'X') {\n      printf(\"%d\\n\", MAXSUM());\n      continue;\n    }\n\n    int arg1 = read();\n    int arg2 = read();\n\n    switch (cmd[0]) {\n    case 'I':\n      INSERT(arg1, arg2);\n      break;\n    case 'D':\n      DELETE(arg1, arg2);\n      break;\n    case 'M':\n      MODIFY(arg1, arg2, read());\n      break;\n    case 'R':\n      REVERSE(arg1, arg2);\n      break;\n    case 'G':\n      printf(\"%d\\n\", GETSUM(arg1, arg2));\n      break;\n    }\n  }\n\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"update time: 2016/07/07"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"HYSBZ/1503"}],"identifier":"heading-hysbz-1503"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-hysbz-1503","label":"problem-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1503 郁闷的出纳员"}]}]},{"type":"paragraph","children":[{"type":"text","value":"只需要用 Splay 实现名次树即可。注意由于存在懒惰标记，在查询第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 大，及确定有多少个值比 "},{"type":"inlineMath","value":"key"},{"type":"text","value":" 小，这两个操作的过程中都要一路 "},{"type":"inlineMath","value":"pushdown"},{"type":"text","value":"。"}]},{"type":"admonition","keyword":"tip","title":[{"type":"text","value":"HINT"}],"children":[{"type":"paragraph","children":[{"type":"text","value":"坑点：立即离开公司的人不算入答案。。。"}]}]},{"type":"code","lang":"cpp","meta":"title=\"hysbz-1503.cpp\" sourcefile=\"./hysbz-1503.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\n\nstruct node {\n  int key;\n  int siz;\n  int addv;\n  node* lson;\n  node* rson;\n\n  static node* null;\n\n  int cmp(int s) {\n    int cnt = lson->siz + 1;\n    if (s == cnt) return -1;\n    return s < cnt ? 0 : 1;\n  }\n  void update(int v) {\n    key += v;\n    addv += v;\n  }\n  void pushdown() {\n    if (!addv) return;\n    if (lson != null) lson->update(addv);\n    if (rson != null) rson->update(addv);\n    addv = 0;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n  }\n};\n\ntypedef node* root;\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\n\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\n\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void printtree(root o, int cur = 0) {\n  if (o == node::null) return;\n  printtree(o->lson, cur + 1);\n  printf(\"cur %d: key=%d, siz=%d\\n\", cur, o->key, o->siz);\n  printtree(o->rson, cur + 1);\n  if (!cur) printf(\"---------------------------------\\n\");\n}\n\ninline void splay(root& o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    p->pushdown();\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline int kth(root o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == -1) return o->key;\n  return d ? kth(o->rson, k - o->lson->siz - 1) : kth(o->lson, k);\n}\n\ninline int rank(root o, int k) {\n  if (o == node::null) return 0;\n  o->pushdown();\n  if (k <= o->key) return rank(o->lson, k);\n  return rank(o->rson, k) + o->lson->siz + 1;\n}\n\nconst int MAX_NODES = 100000 + 10;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->addv = 0;\n  nodetop->lson = node::null;\n  nodetop->rson = node::null;\n  return nodetop++;\n}\n\ninline void insert(root& rt, int key) {\n  int k = rank(rt, key);\n  splay(rt, k);\n  root left = rt;\n  root middle = newnode(key);\n  root right = rt->rson;\n  left->rson = middle;\n  middle->rson = right;\n  middle->maintain();\n  left->maintain();\n  rt = left;\n}\n\ninline void remove(root& rt, int M) {\n  int k = rank(rt, M);\n  if (k == 1) return;\n  splay(rt, 1);\n  splay(rt->rson, k);\n  rt->rson->lson = node::null;\n  rt->rson->maintain();\n  rt->maintain();\n}\n\ninline void update(root& rt, int addv) {\n  if (rt->siz == 2) return;\n  splay(rt, 1);\n  splay(rt->rson, rt->rson->siz);\n  rt->rson->lson->update(addv);\n  rt->rson->maintain();\n  rt->maintain();\n}\n\nconst int INF = 0x3f3f3f3f;\nroot rt;\n\nnode* node::null = new node();\ninline void init() {\n  node::null->key = 0;\n  node::null->siz = 0;\n  node::null->addv = 0;\n  node::null->lson = NULL;\n  node::null->rson = NULL;\n\n  nodetop = nodepool;\n  rt = newnode(-INF);\n  rt->rson = newnode(INF);\n  rt->maintain();\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\nint main() {\n  init();\n\n  int N = read();\n  int M = read();\n  int tot = 2;\n  for (int i = 1; i <= N; ++i) {\n    char cmd[20];\n    scanf(\"%s\", cmd);\n    int arg = read();\n\n    switch (cmd[0]) {\n    case 'I':\n      if (arg >= M) insert(rt, arg), ++tot;\n      break;\n    case 'A':\n      update(rt, arg);\n      break;\n    case 'S':\n      update(rt, -arg);\n      remove(rt, M);\n      break;\n    case 'F':\n      printf(\"%d\\n\", arg <= rt->siz - 2 ? kth(rt, rt->siz - arg) : -1);\n      break;\n    }\n  }\n  printf(\"%d\\n\", tot - rt->siz);\n\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/07"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"LA/3961"}],"identifier":"heading-la-3961"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-la-3961","label":"problem-la-3961","referenceType":"full","children":[{"type":"text","value":"LA/3961 Robotic Sort"}]}]},{"type":"paragraph","children":[{"type":"text","value":"初始时，建一棵 "},{"type":"inlineMath","value":"1 \\sim N"},{"type":"text","value":" 的 Splay，并对原序列进行排序（排序规则为：值小的优先，值相等时，在原序列靠左的优先）。对于第 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 次询问，将值为 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的节点伸展至根，然后就是些基础的操作了。问题的难点在于快速找到值为 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的节点。"}]},{"type":"paragraph","children":[{"type":"text","value":"法一：用一个父指针，直接从值为 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 的节点往上伸展就好了。之所以扯这么多，是因为此前一直都是用 刘汝佳 的递归写法（被惯坏了），不需要父指针。"}]},{"type":"code","lang":"cpp","meta":"title=\"LA-3961.cpp\" sourcefile=\"./LA-3961.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\n\nstruct node {\n  int key;\n  int siz;\n  bool flip;\n  node* prev;\n  node* lson;\n  node* rson;\n\n  void reverse() {\n    flip ^= 1;\n    std::swap(lson, rson);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson->reverse();\n    rson->reverse();\n    flip = false;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n  }\n};\n\ntypedef node* root;\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson->prev = o;\n  k->lson = o;\n  o->prev = k;\n  o = k;\n}\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson->prev = o;\n  k->rson = o;\n  o->prev = k;\n  o = k;\n}\n// 带父指针的 旋转 和 伸展操作 是此问题最大的难点（蒽，被刘汝佳的代码惯坏了。。\ninline void rotate(root o, int d) {\n  int d2 = -1;\n  root p = o->prev;\n  if (p != NULL) d2 = p->lson == o ? 0 : 1;\n  d ? zig(o) : zag(o);\n  if (d2 != -1) d2 ? p->rson = o : p->lson = o;\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->prev = p;\n  o->maintain();\n}\n\n// 注意，d 必须在 pushdown 之后计算，因为有交换子树的操作。\ninline void splay(root o, root f) {\n  // o 必须先 pushdown() 一次，因为可能 o 已经是 f 的子节点，\n  // 但为了保持 “splay 操作后的根节点标记全部下传” 的传统，需要这么做。\n  for (o->pushdown(); o->prev != f;) {\n    root p = o->prev;\n    if (p->prev == f) {\n      p->pushdown();\n      o->pushdown();\n      int d = p->lson == o ? 0 : 1;\n      rotate(p, d ^ 1);\n      break;\n    }\n\n    root g = p->prev;\n    g->pushdown();\n    p->pushdown();\n    o->pushdown();\n    int d = p->lson == o ? 0 : 1;\n    int d2 = g->lson == p ? 0 : 1;\n    if (d == d2)\n      rotate(g, d2 ^ 1), rotate(p, d ^ 1);\n    else\n      rotate(p, d ^ 1), rotate(g, d2 ^ 1);\n  }\n}\n\nconst int MAX_NODES = 100000 + 10;\nnode* null;\nnode nodepool[MAX_NODES];\n\ninline void build(root& o, int lft, int rht) {\n  int mid = (lft + rht) >> 1;\n  o = nodepool + mid;\n  o->key = mid;\n  o->siz = 1;\n  o->flip = false;\n  if (lft < mid)\n    build(o->lson, lft, mid - 1);\n  else\n    o->lson = null;\n  if (mid < rht)\n    build(o->rson, mid + 1, rht);\n  else\n    o->rson = null;\n  o->lson->prev = o;\n  o->rson->prev = o;\n  o->maintain();\n}\n\ninline int solve(root& rt, int key) {\n  root o = nodepool + key;\n  splay(o, rt->prev);\n  int ans = o->lson->siz;\n  if (ans) {\n    root k = o->lson;\n    k->reverse();\n    for (; k->rson != null; k = k->rson) k->pushdown();\n    splay(k, o);\n    k->rson = o->rson;\n    o->rson->prev = k;\n    o = k;\n  } else\n    o = o->rson;\n  rt = o;\n  rt->prev = NULL;\n  rt->maintain();\n  return ans;\n}\n\ntypedef std::pair<int, int> pii;\nconst int MAXN = 100000 + 10;\n\nroot rt;\npii A[MAXN];\nint N;\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = true;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void Init() {\n  for (int i = 1; i <= N; ++i) A[i] = pii(read(), i);\n  sort(A + 1, A + N + 1);\n  build(rt, 1, N);\n  rt->prev = NULL;\n}\n\nint main() {\n  null = new node();\n  null->key = 0;\n  null->siz = 0;\n  null->flip = false;\n  null->lson = NULL;\n  null->rson = NULL;\n\n  while (scanf(\"%d\", &N) == 1 && N) {\n    Init();\n    for (int i = 1; i < N; ++i) printf(\"%d \", solve(rt, A[i].second) + i);\n    printf(\"%d\\n\", N);\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/05"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"POJ/2828"}],"identifier":"heading-poj-2828"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-poj-2828","label":"problem-poj-2828","referenceType":"full","children":[{"type":"text","value":"POJ/2828 Buy Tickets"}]}]},{"type":"paragraph","children":[{"type":"text","value":"法一：在线做。直接 Splay 模拟，容易超时，可以检验自己 Splay 写法常数大不大（不加读入读出优化的前提下）。"}]},{"type":"admonition","keyword":"tip","title":[{"type":"text","value":"HINT"}],"children":[{"type":"paragraph","children":[{"type":"text","value":"POJ 加读入读出优化能快很多 = ="}]}]},{"type":"code","lang":"cpp","meta":"title=\"poj-2828.cpp\" sourcefile=\"./poj-2828.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nstruct node {\n  int key;\n  int siz;\n  node* lson;\n  node* rson;\n\n  static node* null;\n\n  int cmp(int x) {\n    int cnt = lson->siz + 1;\n    if (x == cnt) return -1;\n    return x < cnt ? 0 : 1;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n  }\n};\n\ntypedef node* root;\n\ninline void zag(root& o) {\n  root k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\n\ninline void zig(root& o) {\n  root k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\n\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = node::null;\n  o->maintain();\n}\n\nconst int MAX_NODES = 200000 + 10;\n\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop->key = key;\n  nodetop->siz = 0;\n  nodetop->lson = node::null;\n  nodetop->rson = node::null;\n  return nodetop++;\n}\n\ninline void insert(root& rt, int pos, int key) {\n  root left, right;\n  split(rt, pos + 1, left, right);\n  left->rson = newnode(key);\n  left->rson->rson = right;\n  left->rson->maintain();\n  left->maintain();\n  rt = left;\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void print(int s) {\n  if (s > 9) print(s / 10);\n  putchar(s % 10 + '0');\n}\n\nnode* node::null = new node();\nroot rt;\nint N;\n\ninline void init() {\n  node::null->key = 0;\n  node::null->siz = 0;\n  node::null->lson = NULL;\n  node::null->rson = NULL;\n}\n\ninline void printtree(root& o) {\n  if (o == node::null) return;\n  printtree(o->lson);\n  print(o->key);\n  putchar(' ');\n  printtree(o->rson);\n}\n\nint main() {\n  init();\n  while (scanf(\"%d\", &N) == 1) {\n    nodetop = nodepool;\n    rt = newnode(0);\n    for (int i = 1; i <= N; ++i) {\n      int arg1 = read();\n      int arg2 = read();\n      insert(rt, arg1, arg2);\n    }\n    splay(rt, 1);\n    printtree(rt->rson);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"text","value":"法二：离线做。类似约瑟夫问题的线段树写法。初始时，维护一个前缀和\n"},{"type":"inlineMath","value":"\\displaystyle sum(N)=\\sum_{i=1}^N i"},{"type":"text","value":"；最后一个人的最终位置显然是 "},{"type":"inlineMath","value":"pos+1"},{"type":"text","value":"，然后去掉这个人，那么倒数第二个人就成了最后一个人了。"}]},{"type":"code","lang":"cpp","meta":"title=\"poj-2828_2.cpp\" sourcefile=\"./poj-2828_2.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define lc (o << 1)\n#define rc (o << 1 | 1)\n#define lson lc, lft, mid\n#define rson rc, mid + 1, rht\n#define MID(lft, rht) (lft + rht >> 1)\n\nconst int MAXN = 200000 + 10;\n\nint sumv[MAXN << 2], ans[MAXN], pos[MAXN], val[MAXN], N;\nvoid build(int o, int lft, int rht) {\n  sumv[o] = rht - lft + 1;\n  if (lft == rht) return;\n  int mid = MID(lft, rht);\n  build(lson);\n  build(rson);\n}\n\nvoid query(int o, int lft, int rht, int pos, int val) {\n  --sumv[o];\n  if (lft == rht)\n    ans[lft] = val;\n  else {\n    int mid = MID(lft, rht);\n    if (pos <= sumv[lc])\n      query(lson, pos, val);\n    else\n      query(rson, pos - sumv[lc], val);\n  }\n}\n\ninline int read() {\n  bool positive = true;\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') positive = false;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return positive ? s : -s;\n}\n\ninline void print(int s) {\n  if (s > 9) print(s / 10);\n  putchar(s % 10 + '0');\n}\n\nint main() {\n  while (scanf(\"%d\", &N) == 1) {\n    build(1, 1, N);\n    for (int i = 1; i <= N; ++i) pos[i] = read() + 1, val[i] = read();\n    for (int i = N; i; --i) query(1, 1, N, pos[i], val[i]);\n    for (int i = 1; i <= N; ++i) print(ans[i]), putchar(' ');\n    putchar('\\n');\n  }\n  return 0;\n}\n"},{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Update time: 2016/07/07"}]}]},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"UVA/11922"}],"identifier":"heading-uva-11922"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-uva-11922","label":"problem-uva-11922","referenceType":"full","children":[{"type":"text","value":"UVA/11922 Permutation Transformer"}]}]},{"type":"paragraph","children":[{"type":"text","value":"基础题。"}]},{"type":"code","lang":"cpp","meta":"title=\"uva-11922.cpp\" sourcefile=\"./uva-11922.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node {\n  int key;\n  int siz;\n  bool flip;\n  node* lson;\n  node* rson;\n  node(int key = 0) : key(key), siz(0), flip(0), lson(NULL), rson(NULL) {\n  }\n  int cmp(int key) {\n    int cnt = lson->siz + 1;\n    if (key == cnt) return -1;\n    return key < cnt ? 0 : 1;\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson->flip ^= 1;\n    rson->flip ^= 1;\n    swap(lson, rson);\n    flip = false;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n  }\n};\n\ntypedef node* root;\ntypedef pair<node*, node*> droot;\nconst int MAX_NODES = 100000 + 10;\nnode* null = new node();\n\nnode nodepool[MAX_NODES];\nnode* nodetop;\n\ninline node* newnode(int key = 0) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->flip = false;\n  nodetop->lson = null;\n  nodetop->rson = null;\n  return nodetop++;\n}\n\ninline void zag(root& o) {\n  node* k = o->rson;\n  o->rson = k->lson;\n  k->lson = o;\n  o = k;\n}\ninline void zig(root& o) {\n  node* k = o->lson;\n  o->lson = k->rson;\n  k->rson = o;\n  o = k;\n}\ninline void rotate(root& o, int d) {\n  d ? zig(o) : zag(o);\n  d ? o->rson->maintain() : o->lson->maintain();\n  o->maintain();\n}\n\ninline void splay(root& o, int k) {\n  o->pushdown();\n  int d = o->cmp(k);\n  if (d == 1) k -= o->lson->siz + 1;\n  if (d != -1) {\n    root& p = d ? o->rson : o->lson;\n    p->pushdown();\n    int d2 = p->cmp(k);\n    if (d2 == 1) k -= p->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? p->rson : p->lson), k);\n      if (d == d2)\n        rotate(o, d ^ 1);\n      else\n        rotate(p, d);\n    }\n    rotate(o, d ^ 1);\n  }\n}\n\ninline void split(root o, int k, root& left, root& right) {\n  splay(o, k);\n  left = o;\n  right = o->rson;\n  o->rson = null;\n  o->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->pushdown();\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\ninline void build(root& o, int lft, int rht) {\n  int mid = (lft + rht) >> 1;\n  o = newnode(mid);\n  if (lft < mid) build(o->lson, lft, mid - 1);\n  if (mid < rht) build(o->rson, mid + 1, rht);\n  o->maintain();\n}\n\ninline void print(root& o) {\n  if (o == null) return;\n  o->pushdown();\n  if (o->lson != null) print(o->lson);\n  if (o->key) printf(\"%d\\n\", o->key);\n  if (o->rson != null) print(o->rson);\n}\n\nroot rt;\ninline void init(int N) {\n  nodetop = nodepool;\n  build(rt, 0, N);\n}\n\nint main() {\n  int N, Q;\n  while (scanf(\"%d%d\", &N, &Q) == 2) {\n    init(N);\n    while (Q--) {\n      int lft, rht;\n      root o, left, middle, right;\n      scanf(\"%d%d\", &lft, &rht);\n      split(rt, lft, left, o);\n      split(o, rht - lft + 1, middle, right);\n      middle->flip ^= 1;\n      rt = merge(merge(left, right), middle);\n    }\n    print(rt);\n  }\n  return 0;\n}\n"},{"type":"thematicBreak"},{"type":"heading","depth":3,"children":[{"type":"text","value":"UVA/11996"}],"identifier":"heading-uva-11996"},{"type":"paragraph","children":[{"type":"text","value":"题目链接： "},{"type":"linkReference","identifier":"problem-uva-11996","label":"problem-uva-11996","referenceType":"full","children":[{"type":"text","value":"UVA/11996 Jewel Magic"}]}]},{"type":"paragraph","children":[{"type":"text","value":"用 hash 求 LCP，则仅需用 Splay 维护 hash 值即可。考虑到用反转操作，每个节点需要维护正反两个 hash 值。"}]},{"type":"code","lang":"cpp","meta":"title=\"uva-11996.cpp\" sourcefile=\"./uva-11996.cpp\" maxlines=\"20\" collapsed linenos","value":"#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int MAXN = 400000 + 10;\nconst int hashkey = 137;\n\nULL xp[MAXN];\n\nstruct node {\n  int key;\n  int siz;\n  ULL val;\n  ULL reval;\n  bool flip;\n  node* lson;\n  node* rson;\n\n  int cmp(int x) {\n    int cnt = lson->siz + 1;\n    if (x == cnt) return -1;\n    return x < cnt ? 0 : 1;\n  }\n  void reverse() {\n    flip ^= 1;\n    swap(lson, rson);\n    swap(val, reval);\n  }\n  void pushdown() {\n    if (!flip) return;\n    lson->reverse();\n    rson->reverse();\n    flip = false;\n  }\n  void maintain() {\n    siz = lson->siz + 1 + rson->siz;\n    val = lson->val + key * xp[lson->siz] + rson->val * xp[lson->siz + 1];\n    reval = rson->reval + key * xp[rson->siz] + lson->reval * xp[rson->siz + 1];\n  }\n};\n\ntypedef node* root;\ntypedef pair<node*, node*> droot;\nconst int MAX_NODES = 400000 + 10;\n\nnode* null;\nnode* nodetop;\nnode nodepool[MAX_NODES];\n\ninline root newnode(int key = 0) {\n  nodetop->key = key;\n  nodetop->siz = 1;\n  nodetop->val = 0;\n  nodetop->reval = 0;\n  nodetop->flip = false;\n  nodetop->lson = null;\n  nodetop->rson = null;\n  return nodetop++;\n}\n\ninline void zag(root& rt) {\n  root k = rt->rson;\n  rt->rson = k->lson;\n  k->lson = rt;\n  rt = k;\n}\ninline void zig(root& rt) {\n  root k = rt->lson;\n  rt->lson = k->rson;\n  k->rson = rt;\n  rt = k;\n}\ninline void rotate(root& rt, int d) {\n  d ? zig(rt) : zag(rt);\n  d ? rt->rson->maintain() : rt->lson->maintain();\n  rt->maintain();\n}\n\ninline void splay(root& rt, int k) {\n  rt->pushdown();\n  int d = rt->cmp(k);\n  if (d == 1) k -= rt->lson->siz + 1;\n  if (d != -1) {\n    root& pt = d ? rt->rson : rt->lson;\n    pt->pushdown();\n    int d2 = pt->cmp(k);\n    if (d2 == 1) k -= pt->lson->siz + 1;\n    if (d2 != -1) {\n      splay((d2 ? pt->rson : pt->lson), k);\n      if (d == d2)\n        rotate(rt, d ^ 1);\n      else\n        rotate(pt, d);\n    }\n    rotate(rt, d ^ 1);\n  }\n}\n\ninline void split(root rt, int k, root& left, root& right) {\n  splay(rt, k);\n  left = rt;\n  right = rt->rson;\n  rt->rson = null;\n  rt->maintain();\n}\n\ninline root merge(root left, root right) {\n  splay(left, left->siz);\n  left->rson = right;\n  left->maintain();\n  return left;\n}\n\n/* insert at (k+1)th position. */\ninline void insert(root& rt, int k, int key) {\n  root left, right;\n  root middle = newnode(key);\n  split(rt, k, left, right);\n  rt = merge(merge(left, middle), right);\n}\n\n/* remove at (k+1)th position. */\ninline void remove(root& rt, int k) {\n  root left, middle, right;\n  split(rt, k, left, right);\n  split(right, 1, middle, right);\n  rt = merge(left, right);\n}\n\n/* modify [lft+1, rht+1]. */\ninline void update(root& rt, int lft, int rht) {\n  splay(rt, lft);\n  splay(rt->rson, rht - lft + 2);\n  rt->rson->lson->reverse(); /* update rt->rson->lson, rt->rson, rt */\n  rt->rson->maintain();\n  rt->maintain();\n}\n\ninline int query(root& rt, int p1, int p2) {\n  int lft = 0, rht = rt->siz - p2;\n  while (lft < rht) {\n    int mid = (lft + rht) >> 1;\n    splay(rt, p1);\n    splay(rt->rson, mid + 1);\n    ULL val1 = rt->rson->lson->val;\n    splay(rt, p2);\n    splay(rt->rson, mid + 1);\n    ULL val2 = rt->rson->lson->val;\n    if (val1 == val2)\n      lft = mid + 1;\n    else\n      rht = mid;\n  }\n  return lft - 1;\n}\n\nroot rt;\nchar s[MAXN];\nint N, Q, op, arg1, arg2;\n\ninline void build(root& rt, int lft, int rht) {\n  int mid = (lft + rht) >> 1;\n  rt = newnode(s[mid] - '0');\n  if (lft < mid) build(rt->lson, lft, mid - 1);\n  if (mid < rht) build(rt->rson, mid + 1, rht);\n  rt->maintain();\n}\n\ninline void Init() {\n  nodetop = nodepool;\n  scanf(\"%s\", s + 1);\n  s[0] = s[N + 1] = '0';\n  build(rt, 0, N + 1);\n}\n\ninline int read() {\n  char c = getchar();\n  int s = 0;\n  for (; c < '0' || c > '9'; c = getchar())\n    ;\n  for (; c >= '0' && c <= '9'; c = getchar()) s = s * 10 + c - '0';\n  return s;\n}\n\nint main() {\n  null = new node();\n  memset(null, 0, sizeof(node));\n  xp[0] = 1;\n  for (int i = 1; i < MAXN; ++i) xp[i] = xp[i - 1] * hashkey;\n\n  while (scanf(\"%d%d\", &N, &Q) == 2) {\n    Init();\n    while (Q--) {\n      op = read();\n      arg1 = read();\n      if (op != 2) arg2 = read();\n      switch (op) {\n      case 1:\n        insert(rt, arg1 + 1, arg2);\n        break;\n      case 2:\n        remove(rt, arg1);\n        break;\n      case 3:\n        update(rt, arg1, arg2);\n        break;\n      case 4:\n        printf(\"%d\\n\", query(rt, arg1, arg2));\n        break;\n      }\n    }\n  }\n  return 0;\n}\n"},{"type":"heading","depth":2,"children":[{"type":"text","value":"Summary"}],"identifier":"heading-summary"},{"type":"table","columns":[{"align":"center"},{"align":"center"},{"align":"center"}],"children":[{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"text","value":"Problems"}]},{"type":"tableCell","children":[{"type":"text","value":"Category"}]},{"type":"tableCell","children":[{"type":"text","value":"solution"}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hiho-coder-1329","label":"problem-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1329"}]}]},{"type":"tableCell","children":[{"type":"text","value":"基础题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hiho-coder-1329","label":"solution-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hiho-coder-1329","label":"code-hiho-coder-1329","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hiho-coder-1333","label":"problem-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"hihoCoder/1333"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hiho-coder-1333","label":"solution-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hiho-coder-1333","label":"code-hiho-coder-1333","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hysbz-1269","label":"problem-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1269"}]}]},{"type":"tableCell","children":[{"type":"text","value":"经典题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hysbz-1269","label":"solution-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hysbz-1269","label":"code-hysbz-1269","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hysbz-1500","label":"problem-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1500"}]}]},{"type":"tableCell","children":[{"type":"text","value":"经典题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hysbz-1500","label":"solution-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hysbz-1500","label":"code-hysbz-1500","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-hysbz-1503","label":"problem-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"HYSBZ/1503"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-hysbz-1503","label":"solution-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-hysbz-1503","label":"code-hysbz-1503","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-la-3961","label":"problem-la-3961","referenceType":"full","children":[{"type":"text","value":"LA/3961"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-la-3961","label":"solution-la-3961","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-la-3961","label":"code-la-3961","referenceType":"full","children":[{"type":"text","value":"Code"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-la-3961_2","label":"code-la-3961_2","referenceType":"full","children":[{"type":"text","value":"Code2"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-poj-2828","label":"problem-poj-2828","referenceType":"full","children":[{"type":"text","value":"POJ/2828"}]}]},{"type":"tableCell","children":[{"type":"text","value":"基础题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-poj-2828","label":"solution-poj-2828","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-poj-2828","label":"code-poj-2828","referenceType":"full","children":[{"type":"text","value":"Code"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-poj-2828_2","label":"code-poj-2828_2","referenceType":"full","children":[{"type":"text","value":"Code2"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-uva-11922","label":"problem-uva-11922","referenceType":"full","children":[{"type":"text","value":"UVa/11922"}]}]},{"type":"tableCell","children":[{"type":"text","value":"基础题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-uva-11922","label":"solution-uva-11922","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-uva-11922","label":"code-uva-11922","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]},{"type":"tableRow","children":[{"type":"tableCell","children":[{"type":"linkReference","identifier":"problem-uva-11996","label":"problem-uva-11996","referenceType":"full","children":[{"type":"text","value":"UVa/11996"}]}]},{"type":"tableCell","children":[{"type":"text","value":"初级题"}]},{"type":"tableCell","children":[{"type":"linkReference","identifier":"solution-uva-11996","label":"solution-uva-11996","referenceType":"full","children":[{"type":"text","value":"Solution"}]},{"type":"text","value":", "},{"type":"linkReference","identifier":"code-uva-11996","label":"code-uva-11996","referenceType":"full","children":[{"type":"text","value":"Code"}]}]}]}]}]},"ecmaImports":[],"definitionMap":{"problem-hiho-coder-1329":{"type":"definition","identifier":"problem-hiho-coder-1329","label":"problem-hiho-coder-1329","url":"http://hihocoder.com/problemset/problem/1329"},"problem-hiho-coder-1333":{"type":"definition","identifier":"problem-hiho-coder-1333","label":"problem-hiho-coder-1333","url":"http://hihocoder.com/problemset/problem/1333"},"problem-hysbz-1269":{"type":"definition","identifier":"problem-hysbz-1269","label":"problem-hysbz-1269","url":"http://www.lydsy.com/JudgeOnline/problem.php?id=1269"},"problem-hysbz-1500":{"type":"definition","identifier":"problem-hysbz-1500","label":"problem-hysbz-1500","url":"http://www.lydsy.com/JudgeOnline/problem.php?id=1500"},"problem-hysbz-1503":{"type":"definition","identifier":"problem-hysbz-1503","label":"problem-hysbz-1503","url":"http://www.lydsy.com/JudgeOnline/problem.php?id=1503"},"problem-la-3961":{"type":"definition","identifier":"problem-la-3961","label":"problem-la-3961","url":"https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1962"},"problem-poj-2828":{"type":"definition","identifier":"problem-poj-2828","label":"problem-poj-2828","url":"http://poj.org/problem?id=2828"},"problem-uva-11922":{"type":"definition","identifier":"problem-uva-11922","label":"problem-uva-11922","url":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3073"},"problem-uva-11996":{"type":"definition","identifier":"problem-uva-11996","label":"problem-uva-11996","url":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3147"},"solution-hiho-coder-1329":{"type":"definition","identifier":"solution-hiho-coder-1329","label":"solution-hiho-coder-1329","url":"#heading-hihocoder-1329"},"solution-hiho-coder-1333":{"type":"definition","identifier":"solution-hiho-coder-1333","label":"solution-hiho-coder-1333","url":"#heading-hihocoder-1333"},"solution-hysbz-1269":{"type":"definition","identifier":"solution-hysbz-1269","label":"solution-hysbz-1269","url":"#heading-hysbz-1269"},"solution-hysbz-1500":{"type":"definition","identifier":"solution-hysbz-1500","label":"solution-hysbz-1500","url":"#heading-hysbz-1500"},"solution-hysbz-1503":{"type":"definition","identifier":"solution-hysbz-1503","label":"solution-hysbz-1503","url":"#heading-hysbz-1503"},"solution-la-3961":{"type":"definition","identifier":"solution-la-3961","label":"solution-la-3961","url":"#heading-la-3961"},"solution-poj-2828":{"type":"definition","identifier":"solution-poj-2828","label":"solution-poj-2828","url":"#heading-poj-2828"},"solution-uva-11922":{"type":"definition","identifier":"solution-uva-11922","label":"solution-uva-11922","url":"#heading-uva-11922"},"solution-uva-11996":{"type":"definition","identifier":"solution-uva-11996","label":"solution-uva-11996","url":"#heading-uva-11996"},"code-hiho-coder-1329":{"type":"definition","identifier":"code-hiho-coder-1329","label":"code-hiho-coder-1329","url":"/static/0f84e678f80fd7d987847a9891ddeb26505d7ab4/hihocoder-1329.cpp"},"code-hiho-coder-1333":{"type":"definition","identifier":"code-hiho-coder-1333","label":"code-hiho-coder-1333","url":"/static/b998c55669910aa2343a55034d41b838331d9a2a/hihocoder-1333.cpp"},"code-hysbz-1269":{"type":"definition","identifier":"code-hysbz-1269","label":"code-hysbz-1269","url":"/static/0f9183ea1e77c3be8536416001dbd669d9a34b5a/hysbz-1269.cpp"},"code-hysbz-1500":{"type":"definition","identifier":"code-hysbz-1500","label":"code-hysbz-1500","url":"/static/c869f687aa7394b4101087a5e988820101c2681c/hysbz-1500.cpp"},"code-hysbz-1503":{"type":"definition","identifier":"code-hysbz-1503","label":"code-hysbz-1503","url":"/static/a06c653991f52dc999299f28aa34b47c6df0110f/hysbz-1503.cpp"},"code-la-3961":{"type":"definition","identifier":"code-la-3961","label":"code-la-3961","url":"/static/8048263f16addac05ea1b6298f733edbf5fd2b27/LA-3961.cpp"},"code-la-3961_2":{"type":"definition","identifier":"code-la-3961_2","label":"code-la-3961_2","url":"/static/b87f85c9915c24f9acfb30850c026b3330564e36/LA-3961_2.cpp"},"code-poj-2828":{"type":"definition","identifier":"code-poj-2828","label":"code-poj-2828","url":"/static/d6578f538b312cf6f936a5b0bdfe527512782d25/poj-2828.cpp"},"code-poj-2828_2":{"type":"definition","identifier":"code-poj-2828_2","label":"code-poj-2828_2","url":"/static/4dc7a2d54d1d471647590118ce4ab74c5d854f35/poj-2828_2.cpp"},"code-uva-11922":{"type":"definition","identifier":"code-uva-11922","label":"code-uva-11922","url":"/static/b30c9611e8b4cb59e5bae015c30641dda0c1cff9/uva-11922.cpp"},"code-uva-11996":{"type":"definition","identifier":"code-uva-11996","label":"code-uva-11996","url":"/static/6fb19d2637fa89a33b90187dfadd2abf22e0fcbe/uva-11996.cpp"}},"footnoteDefinitionMap":{},"fields":{"slug":"/post/data-structure/bbst/splay/"}},"previous":{"title":"CCF 2015-09 最佳文章 解题报告","fields":{"slug":"/post/acm/oj/ccf/2015/09/E/"}},"next":{"title":"二分图","fields":{"slug":"/post/algorithm/graph/bipartite-graph/"}},"postItems":{"nodes":[{"title":"洗牌问题和 knuth-shuffle 算法","createdAt":"2021-07-22","tags":["shuffle","knuth-shuffle","约瑟夫环"],"fields":{"slug":"/post/algorithm/shuffle/"}},{"title":"编译原理-语法制导翻译实现计算器","createdAt":"2016-06-23","tags":["编译原理","语法制导翻译","计算机"],"fields":{"slug":"/post/fundamentals-of-compiling/exercise/"}},{"title":"编译原理-语法分析","createdAt":"2016-06-18","tags":["编译原理","语法分析","计算机"],"fields":{"slug":"/post/fundamentals-of-compiling/grammar/"}},{"title":"端口管理","createdAt":"2021-06-20","tags":["network","port","ssh","netstat"],"fields":{"slug":"/post/network/端口管理/"}},{"title":"防抖和节流","createdAt":"2021-09-03","tags":["coding","debounce","throttle"],"fields":{"slug":"/post/algorithm/debounce-and-throttle/"}},{"title":"精确覆盖问题和 DLX 算法","createdAt":"2021-07-24","tags":["算法","精确覆盖","DLX 算法"],"fields":{"slug":"/post/algorithm/dlx/"}},{"title":"背包九讲","createdAt":"2021-06-27","tags":["acm","算法","动态规划","背包问题"],"fields":{"slug":"/post/algorithm/knapsack/"}},{"title":"最长公共子序列（LCS）","createdAt":"2021-06-02","tags":["最长公共子序列","LCS"],"fields":{"slug":"/post/algorithm/lcs/"}},{"title":"最长上升子序列（LIS）","createdAt":"2021-06-02","tags":["最长上升子序列","LIS"],"fields":{"slug":"/post/algorithm/lis/"}},{"title":"当你想来一把数独","createdAt":"2021-08-01","tags":["game","sudoku"],"fields":{"slug":"/post/game/sudoku/"}},{"title":"函数的极限","createdAt":"2021-05-09","tags":["math","函数","极限"],"fields":{"slug":"/post/math/calculus/函数的极限/"}},{"title":"自然对数底数e","createdAt":"2021-08-07","tags":["math","函数","极限","自然对数"],"fields":{"slug":"/post/math/calculus/自然对数底数e/"}},{"title":"小球放盒模型","createdAt":"2016-04-22","tags":["math","组合数学"],"fields":{"slug":"/post/math/combinatorial/小球放盒模型/"}},{"title":"不修改数组找出重复的数字","createdAt":"2021-06-29","tags":["quiz","分治","追击"],"fields":{"slug":"/post/quiz/partition/find-duplicate-number/"}},{"title":"统计区间内的线段","createdAt":"2021-07-21","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"fields":{"slug":"/post/quiz/scanning-line/segments/"}},{"title":"CSS 选择器","createdAt":"2020-11-02","tags":["web","frontend","css"],"fields":{"slug":"/post/web/css/selector/"}},{"title":"ECMA 2020 新特性","createdAt":"2021-04-05","tags":["javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/2020/"}},{"title":"ECMA 2021 新特性","createdAt":"2021-04-05","tags":["javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/2021/"}},{"title":"Javascript 踩坑记——继承和原型链","createdAt":"2021-09-05","tags":["studynote","javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/inherit/"}},{"title":"React Reconciliation","createdAt":"2021-06-26","tags":["react","react reconciliation"],"fields":{"slug":"/post/web/react/reconciliation/"}},{"title":"XSS 与 CSRF 的攻防","createdAt":"2021-08-19","tags":["web","web security","csrf"],"fields":{"slug":"/post/web/security/xss-csrf/"}},{"title":"二分图","createdAt":"2016-07-17","tags":["算法","图论","二分图","学习笔记"],"fields":{"slug":"/post/algorithm/graph/bipartite-graph/"}},{"title":"最长回文子串 Manacher 算法","createdAt":"2016-04-18","tags":["算法","字符串","回文串","manacher"],"fields":{"slug":"/post/algorithm/string/manacher/"}},{"title":"树链剖分","createdAt":"2016-04-23","tags":["acm","算法","树链剖分"],"fields":{"slug":"/post/algorithm/tree/tcs/"}},{"title":"伸展树专题","createdAt":"2016-07-03","tags":["acm","Splay","解题报告","专题训练"],"fields":{"slug":"/post/data-structure/bbst/splay/"}},{"title":"组合游戏基础之 SG 函数和 SG 定理","createdAt":"2016-09-04","tags":["组合数学","组合游戏","SG 定理"],"fields":{"slug":"/post/math/combinatorial/SG/"}},{"title":"快速傅里叶变换和雷德算法","createdAt":"2016-04-10","tags":["acm","大数乘法","fft","快速傅里叶变换"],"fields":{"slug":"/post/math/number-theory/fft/"}},{"title":"数论基础之筛法","createdAt":"2016-05-06","tags":["math","数论","素数","欧拉函数","线性筛"],"fields":{"slug":"/post/math/number-theory/sieve/"}},{"title":"数论基础之原根","createdAt":"2016-05-16","tags":["math","数论","原根"],"fields":{"slug":"/post/math/number-theory/原根/"}},{"title":"数论基础之欧拉函数","createdAt":"2016-05-10","tags":["math","数论","既约剩余系","欧拉函数"],"fields":{"slug":"/post/math/number-theory/欧拉函数/"}},{"title":"约瑟夫环问题","createdAt":"2021-07-16","tags":["quiz","经典问题","约瑟夫环"],"fields":{"slug":"/post/quiz/classical/Josephus-ring/"}},{"title":"扔鸡蛋问题","createdAt":"2021-06-20","tags":["quiz","动态规划"],"fields":{"slug":"/post/quiz/dp/egg-drop/"}},{"title":"在 excel 中启用正则表达式","createdAt":"2021-03-29","tags":["excel","tools"],"fields":{"slug":"/post/tool/excel/regex/"}},{"title":"百度之星 2016 解题报告","createdAt":"2016-06-03","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"fields":{"slug":"/post/acm/contest/baiduzhixing/2016/"}},{"title":"51nod-1462 数据结构 -- 解题报告","createdAt":"2016-04-23","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/51nod/1462/"}},{"title":"HDU-5306 Gorgeous Sequence 解题报告","createdAt":"2016-04-09","tags":["acm","数据结构","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5306/"}},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","createdAt":"2016-04-12","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5574/"}},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","createdAt":"2016-04-24","tags":["acm","动态规划","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5576/"}},{"title":"剑指offer 解题报告","createdAt":"2021-07-15","tags":["专题训练","解题报告"],"fields":{"slug":"/post/acm/oj/nowcoder/jz-offer/"}},{"title":"POJ-1324 Holedox Moving 解题报告","createdAt":"2016-04-13","tags":["acm","bfs","图论","状态压缩","解题报告"],"fields":{"slug":"/post/acm/oj/poj/1324/"}},{"title":"网络流 24 题","createdAt":"2016-07-30","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"fields":{"slug":"/post/algorithm/graph/network-flow/24-problems/"}},{"title":"网络流基础之最大权闭合图","createdAt":"2016-07-24","tags":["算法","图论","网络流","最大权闭合图"],"fields":{"slug":"/post/algorithm/graph/network-flow/最大权闭合图/"}},{"title":"Dijkstra 算法","createdAt":"2021-05-29","tags":["算法","最短路","单源最短路","dijkstra"],"fields":{"slug":"/post/algorithm/graph/shortest-path/dijkstra/"}},{"title":"Custom React Hooks","createdAt":"2020-10-29","tags":["react","react hooks"],"fields":{"slug":"/post/web/react/hooks/custom/"}},{"title":"2016 多校第 2 场","createdAt":"2016-07-22","tags":["acm","训练赛","数据结构","解题报告"],"fields":{"slug":"/post/acm/contest/multi-university-training/2016/2/"}},{"title":"CCF 2015-09 最佳文章 解题报告","createdAt":"2016-06-26","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"fields":{"slug":"/post/acm/oj/ccf/2015/09/E/"}},{"title":"数论基础之模方程初步","createdAt":"2016-05-04","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"fields":{"slug":"/post/math/number-theory/模方程/basic/"}}]}},"pageContext":{"id":"9188eb5f-6d4a-542a-981f-42e18dd99bff","contentType":"post","paginationUrl":"/posts","previousPostId":"e983fdab-a9b2-52d9-ba88-617ccd501c47","nextPostId":"4e4651d2-7672-5c73-8ef7-7da41bd81f88"}},"staticQueryHashes":[],"slicesMap":{}}