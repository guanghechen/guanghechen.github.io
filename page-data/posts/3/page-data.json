{"componentChunkName":"component---src-layout-post-post-list-tsx","path":"/posts/3/","result":{"data":{"allMarkdownYozora":{"nodes":[{"title":"不修改数组找出重复的数字","description":"不修改数组找出重复的数字","createdAt":"2021-06-29","updatedAt":null,"timeToRead":"10min 34s","categories":[],"tags":["quiz","分治","追击"],"ecmaImports":[],"definitionMap":{},"footnoteDefinitionMap":{"footnote-1":{"type":"footnoteDefinition","identifier":"footnote-1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"可以用反证法来证明：若至多有 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 个数的值落在区间 "},{"type":"inlineMath","value":"[1,x]"},{"type":"text","value":" 中，至多有 "},{"type":"inlineMath","value":"N-x-1"},{"type":"text","value":"\n个值落在区间 "},{"type":"inlineMath","value":"[x+1,N)"},{"type":"text","value":" 中，则数字总数为 "},{"type":"inlineMath","value":"x+(N-x-1)=N-1 \\neq N"},{"type":"text","value":"，与原数列大小矛盾。"}]}]},"footnote-2":{"type":"footnoteDefinition","identifier":"footnote-2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"需要注意的是，快指针是每次走两步，而不是直接跳两步。显然快指针会先进入环，慢指针后进入环，之后在环内快指针一定会和慢指针相遇。"}]}]},"footnote-3":{"type":"footnoteDefinition","identifier":"footnote-3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"在环内走的时候，若慢指针刚好走完一圈，此时快指针走完两圈，必然会遇见慢指针，因此慢指针最多走一圈；又因为慢指针刚好走完一圈时相遇则慢指针在刚入环时也必然和快指针相遇，故慢指针未走完一圈就会被快指针追上；不过这个条件其实不是必要的，事实上使用任意步长都不会影响算法的结果"}]}]},"footnote-4":{"type":"footnoteDefinition","identifier":"footnote-4","label":"4","children":[{"type":"paragraph","children":[{"type":"text","value":"可用反证法证明：若存在相同的两个值，根据定义，下一步它门将作为位置，即存在相同的两个位置，即链表中出现了环，与假设矛盾。"}]}]}},"excerptAst":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"问题描述"}],"identifier":"heading-问题描述"},{"type":"paragraph","children":[{"type":"text","value":"给定一个长度为 "},{"type":"inlineMath","value":"N + 1"},{"type":"text","value":" 的数列 "},{"type":"inlineMath","value":"A=\\lbrace a_0, a_1, a_2 \\cdots, a_N \\rbrace"},{"type":"text","value":"."},{"type":"break"},{"type":"text","value":"\n其中 "},{"type":"inlineMath","value":"1 \\leqslant a_i \\leqslant N,\\; 0 \\leqslant i \\leqslant N,\\; N \\geqslant 1"},{"type":"text","value":"."}]},{"type":"paragraph","children":[{"type":"text","value":"在满足以下限制的前提下找出数组中任意一个重复的数字："}]},{"type":"list","ordered":false,"marker":42,"spread":false,"children":[{"type":"listItem","children":[{"type":"text","value":"不能修改输入的数组；"}]},{"type":"listItem","children":[{"type":"text","value":"只能使用 "},{"type":"inlineMath","value":"O(1)"},{"type":"text","value":" 的额外空间；"}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"分治法"}],"identifier":"heading-分治法"},{"type":"paragraph","children":[{"type":"text","value":"分治算法的思想是不断收紧区间范围以确定重复的数字"},{"type":"strong","children":[{"type":"text","value":"其值"}]},{"type":"text","value":"所在的区间范围，当区间长度为 "},{"type":"inlineMath","value":"1"},{"type":"text","value":" 时，则找到了那个重复的数字（相当于二分答案）。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"算法描述"}],"identifier":"heading-算法描述"},{"type":"paragraph","children":[{"type":"text","value":"根据鸽巢原理易知，原数组中必然至少有一个重复的数字，即答案所在区间为 "},{"type":"inlineMath","value":"[1,N]"},{"type":"text","value":"。不妨取 "},{"type":"inlineMath","value":"\\displaystyle x = \\left\\lfloor \\frac{1+N}{2} \\right\\rfloor"}]}]},"fields":{"slug":"/post/quiz/partition/find-duplicate-number/"}},{"title":"背包九讲","description":"背包九讲","createdAt":"2021-06-27","updatedAt":null,"timeToRead":"43min 44s","categories":[],"tags":["acm","算法","动态规划","背包问题"],"ecmaImports":[],"definitionMap":{"背包九讲.pdf":{"type":"definition","identifier":"背包九讲.pdf","label":"背包九讲.pdf","url":"/static/b34782dabb6c97d71589a1f7e29806403b6dc916/背包九讲.pdf"},"01背包-算法优化":{"type":"definition","identifier":"01背包-算法优化","label":"01背包-算法优化","url":"#heading-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"},"problem-01背包":{"type":"definition","identifier":"problem-01背包","label":"problem-01背包","url":"https://www.acwing.com/problem/content/2/"},"problem-完全背包":{"type":"definition","identifier":"problem-完全背包","label":"problem-完全背包","url":"https://www.acwing.com/problem/content/3/"},"problem-多重背包-2":{"type":"definition","identifier":"problem-多重背包-2","label":"problem-多重背包-2","url":"https://www.acwing.com/problem/content/5/"},"problem-多重背包-3":{"type":"definition","identifier":"problem-多重背包-3","label":"problem-多重背包-3","url":"https://www.acwing.com/problem/content/6/"},"problem-混合背包":{"type":"definition","identifier":"problem-混合背包","label":"problem-混合背包","url":"https://www.acwing.com/problem/content/7/"},"problem-二维费用的背包":{"type":"definition","identifier":"problem-二维费用的背包","label":"problem-二维费用的背包","url":"https://www.acwing.com/problem/content/8/"},"problem-分组背包":{"type":"definition","identifier":"problem-分组背包","label":"problem-分组背包","url":"https://www.acwing.com/problem/content/9/"},"problem-有依赖的背包":{"type":"definition","identifier":"problem-有依赖的背包","label":"problem-有依赖的背包","url":"https://www.acwing.com/problem/content/10/"},"problem-背包方案数":{"type":"definition","identifier":"problem-背包方案数","label":"problem-背包方案数","url":"https://www.acwing.com/problem/content/11/"},"problem-最小字典序方案":{"type":"definition","identifier":"problem-最小字典序方案","label":"problem-最小字典序方案","url":"https://www.acwing.com/problem/content/12/"},"solution-01背包":{"type":"definition","identifier":"solution-01背包","label":"solution-01背包","url":"#heading-01-%E8%83%8C%E5%8C%85"},"solution-完全背包":{"type":"definition","identifier":"solution-完全背包","label":"solution-完全背包","url":"#heading-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"},"solution-多重背包":{"type":"definition","identifier":"solution-多重背包","label":"solution-多重背包","url":"#heading-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"},"solution-混合背包":{"type":"definition","identifier":"solution-混合背包","label":"solution-混合背包","url":"#heading-%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85"},"solution-二维费用的背包":{"type":"definition","identifier":"solution-二维费用的背包","label":"solution-二维费用的背包","url":"#heading-%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E7%9A%84%E8%83%8C%E5%8C%85"},"solution-分组背包":{"type":"definition","identifier":"solution-分组背包","label":"solution-分组背包","url":"#heading-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"},"solution-有依赖的背包":{"type":"definition","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","url":"#heading-%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85"},"solution-最优解方案数":{"type":"definition","identifier":"solution-最优解方案数","label":"solution-最优解方案数","url":"#heading-%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E7%9A%84%E6%80%BB%E6%95%B0"},"solution-最小字典序方案":{"type":"definition","identifier":"solution-最小字典序方案","label":"solution-最小字典序方案","url":"#heading-%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E6%96%B9%E6%A1%88"},"有依赖的背包-简化版的问题":{"type":"definition","identifier":"有依赖的背包-简化版的问题","label":"有依赖的背包-简化版的问题","url":"#heading-%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84%E9%97%AE%E9%A2%98"}},"footnoteDefinitionMap":{"footnote-1":{"type":"footnoteDefinition","identifier":"footnote-1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"假设物品消耗的背包容量恰好等于其体积。"}]}]},"footnote-2":{"type":"footnoteDefinition","identifier":"footnote-2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"这里的影响指的是依赖耦合，如要求“放入第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品时必须也放入第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 件物品；若只是放入第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品导致背包容量不足以放入第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 件物品，这种情况可规约为背包剩余容量是否足以放入第 "},{"type":"inlineMath","value":"j"},{"type":"text","value":" 件物品，而和前 "},{"type":"inlineMath","value":"j-1"},{"type":"text","value":" 件物品中是否放入了第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品无关。"}]}]},"footnote-3":{"type":"footnoteDefinition","identifier":"footnote-3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"对于“不放入”的决策，"},{"type":"inlineMath","value":"f(i,x)=f(i-1,x)"}]}]},"footnote-4":{"type":"footnoteDefinition","identifier":"footnote-4","label":"4","children":[{"type":"paragraph","children":[{"type":"text","value":"将它们分别捆绑到一起，比如 "},{"type":"inlineMath","value":"2^k"},{"type":"text","value":" 个可以视作一个体积为 "},{"type":"inlineMath","value":"2^k \\cdot v_i"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"2^k \\cdot w_i"},{"type":"text","value":" 的物品"}]}]},"footnote-5":{"type":"footnoteDefinition","identifier":"footnote-5","label":"5","children":[{"type":"paragraph","children":[{"type":"text","value":"因为 "},{"type":"inlineMath","value":"\\left\\lbrace 2^0, 2^1, 2^2, \\cdots, ... 2^{k-1}\\right\\rbrace"},{"type":"text","value":" 可以表示 "},{"type":"inlineMath","value":"0 \\sim 2^k-1"},{"type":"text","value":" 之间的任意整数。"}]}]},"footnote-6":{"type":"footnoteDefinition","identifier":"footnote-6","label":"6","children":[{"type":"paragraph","children":[{"type":"text","value":"在更新时不记录状态，即仅用 "},{"type":"inlineMath","value":"f(i-1)"},{"type":"text","value":" 去更新 "},{"type":"inlineMath","value":"f(i)"},{"type":"text","value":"，则在第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 组物品中枚举时，所有的考虑都不具有后效性，即状态中不会出现“既选了第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 组物品中的第 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 件物品又选了第 "},{"type":"inlineMath","value":"y"},{"type":"text","value":" 件物品”这种情形。"}]}]},"footnote-7":{"type":"footnoteDefinition","identifier":"footnote-7","label":"7","children":[{"type":"paragraph","children":[{"type":"inlineMath","value":"f"},{"type":"text","value":" 的定义使用了泛化物品的思想，可参考下一节。"}]}]},"footnote-8":{"type":"footnoteDefinition","identifier":"footnote-8","label":"8","children":[{"type":"paragraph","children":[{"type":"text","value":"这里实际上应用了一个优化：如果花费 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 就可以获得第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品，则无需考虑任何需要大于 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" 的花费才能获得第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品的情形。"}]}]},"footnote-9":{"type":"footnoteDefinition","identifier":"footnote-9","label":"9","children":[{"type":"paragraph","children":[{"type":"text","value":"这个问题等价于"},{"type":"linkReference","identifier":"solution-有依赖的背包","label":"solution-有依赖的背包","referenceType":"full","children":[{"type":"text","value":"有依赖的背包"}]},{"type":"text","value":"中合并两棵树或两个兄弟节点。"}]}]}},"excerptAst":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"01背包"}],"identifier":"heading-01背包"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 件物品和一个容量为 "},{"type":"inlineMath","value":"C"},{"type":"text","value":" 的背包。"},{"type":"break"},{"type":"text","value":"\n其中，第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品体积为 "},{"type":"inlineMath","value":"v_i"},{"type":"text","value":" "},{"type":"footnoteReference","identifier":"footnote-1","label":"1"},{"type":"text","value":"，价值为 "},{"type":"inlineMath","value":"w_i"},{"type":"text","value":"。"},{"type":"break"},{"type":"text","value":"\n求选择将哪些物品装入背包可使获得的价值总和最大。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"问题简析"}],"identifier":"heading-问题简析"},{"type":"paragraph","children":[{"type":"text","value":"因为每件物品只有两种选择：放或不放入背包。且每件物品之间相互独立，即无论第 "},{"type":"inlineMath","value":"i"},{"type":"text","value":"\n件物品怎么选都不影响第 "},{"type":"inlineMath","value":"j\\;(i < j \\leqslant N)"},{"type":"text","value":" 件物品的决策 "},{"type":"footnoteReference","identifier":"footnote-2","label":"2"},{"type":"text","value":"。故可以考虑前\n"},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品在背包剩余容量为 "},{"type":"inlineMath","value":"c"},{"type":"text","value":" 时的最佳决策，即记 "},{"type":"inlineMath","value":"f(i, c)"},{"type":"text","value":" 表示当背包剩余容量为\n"},{"type":"inlineMath","value":"c"},{"type":"text","value":"，在前 "},{"type":"inlineMath","value":"i"},{"type":"text","value":" 件物品中做选择时可以获得的最大价值，不难得到状态转移方程："}]},{"type":"math","value":"f(i,c) = \\max \\big\\lbrace f(i-1, c),\\; f(i-1, c-v_i) + w_i \\big\\rbrace\n"}]},"fields":{"slug":"/post/algorithm/knapsack/"}},{"title":"React Reconciliation","description":"React Reconciliation","createdAt":"2021-06-27","updatedAt":null,"timeToRead":"15min 50s","categories":[],"tags":["react","react reconciliation"],"ecmaImports":[],"definitionMap":{"doc-introduction":{"type":"definition","identifier":"doc-introduction","label":"doc-introduction","url":"#heading-introduction"},"react-reconciliation":{"type":"definition","identifier":"react-reconciliation","label":"react-reconciliation","url":"https://facebook.github.io/react/docs/reconciliation.html"},"react-the-diffing-algorithm":{"type":"definition","identifier":"react-the-diffing-algorithm","label":"react-the-diffing-algorithm","url":"https://reactjs.org/docs/reconciliation.html?#the-diffing-algorithm"},"react-scheduling":{"type":"definition","identifier":"react-scheduling","label":"react-scheduling","url":"https://reactjs.org/docs/design-principles.html#scheduling"},"react-terms":{"type":"definition","identifier":"react-terms","label":"react-terms","url":"https://reactjs.org/docs/glossary.html"},"react-virtual-dom":{"type":"definition","identifier":"react-virtual-dom","label":"react-virtual-dom","url":"https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom"},"a survey on tree edit distance and related problems":{"type":"definition","identifier":"a survey on tree edit distance and related problems","label":"A Survey on Tree Edit Distance and Related Problems","url":"http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf"}},"footnoteDefinitionMap":{"footnote-1":{"type":"footnoteDefinition","identifier":"footnote-1","label":"1","children":[{"type":"paragraph","children":[{"type":"text","value":"网络响应晚一点到没什么影响，但是动画被延时执行可能会导致掉帧"}]}]},"footnote-2":{"type":"footnoteDefinition","identifier":"footnote-2","label":"2","children":[{"type":"paragraph","children":[{"type":"text","value":"相对地，\n"},{"type":"inlineCode","value":"push"},{"type":"text","value":" 模型的框架在数据发生改变时会立即触发订阅者的更新操作。参见"},{"type":"linkReference","identifier":"react-scheduling","label":"react-scheduling","referenceType":"collapsed","children":[{"type":"text","value":"react-scheduling"}]}]}]},"footnote-3":{"type":"footnoteDefinition","identifier":"footnote-3","label":"3","children":[{"type":"paragraph","children":[{"type":"text","value":"在使用\nFiber Reconciliation 的 React@16 中，React 实现了自己的任务栈，并定义了任务的优先级，真正具有了调度任务的能力"}]}]}},"excerptAst":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"预备知识"}],"identifier":"heading-预备知识"},{"type":"heading","depth":3,"children":[{"type":"text","value":"Reconciliation"}],"identifier":"heading-reconciliation"},{"type":"paragraph","children":[{"type":"text","value":"使用 React 构建的应用，在初次渲染时 React 会调用的 "},{"type":"inlineCode","value":"render()"},{"type":"text","value":" 方法生成一棵\nReact Elements 树，在下一次 "},{"type":"inlineCode","value":"props"},{"type":"text","value":", "},{"type":"inlineCode","value":"state"},{"type":"text","value":" 发生变化时，将重新调用 "},{"type":"inlineCode","value":"render()"},{"type":"text","value":"\n方法并得到一棵新的 React Elements 树。为了高效地完成更新，需要计算出两棵树之间的差异，然后仅对差异部分应用更新。收集差异的过程被称为\n"},{"type":"linkReference","identifier":"react-reconciliation","label":"react-reconciliation","referenceType":"full","children":[{"type":"text","value":"Reconciliation"}]},{"type":"text","value":"（React@15 及其之前的协调算法又被称为\nStack Reconciler），有些地方也直接将它等同于 "},{"type":"linkReference","identifier":"react-the-diffing-algorithm","label":"react-the-diffing-algorithm","referenceType":"full","children":[{"type":"text","value":"diffing 算法"}]},{"type":"text","value":"。"}]},{"type":"paragraph","children":[{"type":"text","value":"还有一个关于 Reconciliation 的定义：React 拥有多个渲染器，如 "}]}]},"fields":{"slug":"/post/web/react/reconciliation/"}},{"title":"扔鸡蛋问题","description":"扔鸡蛋问题","createdAt":"2021-06-20","updatedAt":null,"timeToRead":"4min 36s","categories":[],"tags":["quiz","动态规划"],"ecmaImports":[],"definitionMap":{},"footnoteDefinitionMap":{},"excerptAst":{"type":"root","children":[{"type":"heading","depth":2,"children":[{"type":"text","value":"问题描述"}],"identifier":"heading-问题描述"},{"type":"paragraph","children":[{"type":"text","value":"有 "},{"type":"inlineMath","value":"K"},{"type":"text","value":" 个鸡蛋和 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 层楼，测试最多试验几次可以测出让鸡蛋摔碎的最低楼层。假定鸡蛋无磨损，即如果在第 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 层楼扔下没碎，那么在第 "},{"type":"inlineMath","value":"x"},{"type":"text","value":" 层楼重复扔无限次都不会碎。没碎的鸡蛋可以重复使用（用于测试），已碎的鸡蛋无法继续使用。"}]},{"type":"heading","depth":3,"children":[{"type":"text","value":"算法一"}],"identifier":"heading-算法一"},{"type":"paragraph","children":[{"type":"text","value":"将 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 层楼看作长度为 "},{"type":"inlineMath","value":"N"},{"type":"text","value":" 的区间，记 "},{"type":"inlineMath","value":"dp(k, n)"},{"type":"text","value":" 表示至多使用 "},{"type":"inlineMath","value":"k"},{"type":"text","value":" 个鸡蛋测出区间长度为 "},{"type":"inlineMath","value":"n"},{"type":"text","value":" 的楼层里任意楼层是否能摔碎鸡蛋的最少试验次数，则状态转移方程为："}]},{"type":"math","value":"dp(k, n) = \n  \\min \\big\\lbrace \n    \\max \\lbrace dp(k-1, x-1), dp(k, n-x) \\rbrace\n    \\; \\big\\vert \\; 1 \\leqslant x \\leqslant n \n  \\big\\rbrace + 1\n"}]},"fields":{"slug":"/post/quiz/dp/egg-drop/"}},{"title":"端口管理","description":"端口管理","createdAt":"2021-06-20","updatedAt":null,"timeToRead":"3min 48s","categories":[],"tags":["network","port","ssh","netstat"],"ecmaImports":[],"definitionMap":{},"footnoteDefinitionMap":{},"excerptAst":{"type":"root","children":[{"type":"admonition","keyword":"caution","title":[],"children":[{"type":"paragraph","children":[{"type":"text","value":"本文未完成，长期更新中..."}]}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"端口和进程"}],"identifier":"heading-端口和进程"},{"type":"list","ordered":false,"marker":42,"spread":true,"children":[{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"列出所有进程 id 和端口信息"}]},{"type":"code","lang":"bash","meta":null,"value":"$ sudo netstat -ntlp\n"}]},{"type":"listItem","children":[{"type":"paragraph","children":[{"type":"text","value":"杀死占用了指定端口的进程"}]},{"type":"code","lang":"bash","meta":null,"value":"$ sudo netstat -nltp\\\n  | grep ':1001\\|:1002'\\\n  | awk '{print $7}'\\\n  | grep -o '^[0-9]\\+'\\\n  | sort\\\n  | uniq\\\n  | xargs kill -9\n"},{"type":"paragraph","children":[{"type":"text","value":"其中："}]},{"type":"list","ordered":false,"marker":45,"spread":false,"children":[{"type":"listItem","children":[{"type":"inlineCode","value":"sudo netstat -nltp"},{"type":"text","value":": 列出所有进程 id 和端口信息（如果不使用 "},{"type":"inlineCode","value":"root"},{"type":"text","value":" 权限，有些进程 id 不会显示）"}]},{"type":"listItem","children":[{"type":"inlineCode","value":"grep ':1001\\|:1002"},{"type":"text","value":": 过滤出使用了端口号 1001 或 1002 的进程"}]},{"type":"listItem","children":[{"type":"inlineCode","value":"awk '{print $7}'"}]}]}]}]}]},"fields":{"slug":"/post/network/端口管理/"}}]},"postItems":{"nodes":[{"title":"Custom React Hooks","createdAt":"2020-10-30","tags":["react","react hooks"],"fields":{"slug":"/post/web/react/hooks/custom/"}},{"title":"React Reconciliation","createdAt":"2021-06-27","tags":["react","react reconciliation"],"fields":{"slug":"/post/web/react/reconciliation/"}},{"title":"ECMA 2020 新特性","createdAt":"2021-04-05","tags":["javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/2020/"}},{"title":"XSS 与 CSRF 的攻防","createdAt":"2021-08-19","tags":["web","web security","csrf"],"fields":{"slug":"/post/web/security/xss-csrf/"}},{"title":"Javascript 踩坑记——继承和原型链","createdAt":"2021-09-05","tags":["studynote","javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/inherit/"}},{"title":"CSS 选择器","createdAt":"2020-11-02","tags":["web","frontend","css"],"fields":{"slug":"/post/web/css/selector/"}},{"title":"ECMA 2021 新特性","createdAt":"2021-04-05","tags":["javascript","ecmascript"],"fields":{"slug":"/post/web/javascript/2021/"}},{"title":"在 excel 中启用正则表达式","createdAt":"2021-03-30","tags":["excel","tools"],"fields":{"slug":"/post/tool/excel/regex/"}},{"title":"统计区间内的线段","createdAt":"2021-07-21","tags":["quiz","扫描线","前缀和","树状数组","线段树"],"fields":{"slug":"/post/quiz/scanning-line/segments/"}},{"title":"约瑟夫环问题","createdAt":"2021-07-17","tags":["quiz","经典问题","约瑟夫环"],"fields":{"slug":"/post/quiz/classical/Josephus-ring/"}},{"title":"端口管理","createdAt":"2021-06-20","tags":["network","port","ssh","netstat"],"fields":{"slug":"/post/network/端口管理/"}},{"title":"数论基础之欧拉函数","createdAt":"2016-05-10","tags":["math","数论","既约剩余系","欧拉函数"],"fields":{"slug":"/post/math/number-theory/欧拉函数/"}},{"title":"扔鸡蛋问题","createdAt":"2021-06-20","tags":["quiz","动态规划"],"fields":{"slug":"/post/quiz/dp/egg-drop/"}},{"title":"数论基础之模方程初步","createdAt":"2016-05-04","tags":["math","数论","扩展欧几里得算法","中国剩余定理","Baby Step Gaint Step"],"fields":{"slug":"/post/math/number-theory/模方程/basic/"}},{"title":"不修改数组找出重复的数字","createdAt":"2021-06-29","tags":["quiz","分治","追击"],"fields":{"slug":"/post/quiz/partition/find-duplicate-number/"}},{"title":"数论基础之原根","createdAt":"2016-05-16","tags":["math","数论","原根"],"fields":{"slug":"/post/math/number-theory/原根/"}},{"title":"快速傅里叶变换和雷德算法","createdAt":"2016-04-10","tags":["acm","大数乘法","fft","快速傅里叶变换"],"fields":{"slug":"/post/math/number-theory/fft/"}},{"title":"小球放盒模型","createdAt":"2016-04-22","tags":["math","组合数学"],"fields":{"slug":"/post/math/combinatorial/小球放盒模型/"}},{"title":"组合游戏基础之 SG 函数和 SG 定理","createdAt":"2016-09-04","tags":["组合数学","组合游戏","SG 定理"],"fields":{"slug":"/post/math/combinatorial/SG/"}},{"title":"数论基础之筛法","createdAt":"2016-05-06","tags":["math","数论","素数","欧拉函数","线性筛"],"fields":{"slug":"/post/math/number-theory/sieve/"}},{"title":"函数的极限","createdAt":"2021-05-09","tags":["math","函数","极限"],"fields":{"slug":"/post/math/calculus/函数的极限/"}},{"title":"当你想来一把数独","createdAt":"2021-08-01","tags":["game","sudoku"],"fields":{"slug":"/post/game/sudoku/"}},{"title":"编译原理-语法制导翻译实现计算器","createdAt":"2016-06-23","tags":["编译原理","语法制导翻译","计算机"],"fields":{"slug":"/post/fundamentals-of-compiling/exercise/"}},{"title":"编译原理-语法分析","createdAt":"2016-06-18","tags":["编译原理","语法分析","计算机"],"fields":{"slug":"/post/fundamentals-of-compiling/grammar/"}},{"title":"伸展树专题","createdAt":"2016-07-03","tags":["acm","Splay","解题报告","专题训练"],"fields":{"slug":"/post/data-structure/bbst/splay/"}},{"title":"洗牌问题和 knuth-shuffle 算法","createdAt":"2021-07-22","tags":["shuffle","knuth-shuffle","约瑟夫环"],"fields":{"slug":"/post/algorithm/shuffle/"}},{"title":"自然对数底数e","createdAt":"2021-08-07","tags":["math","函数","极限","自然对数"],"fields":{"slug":"/post/math/calculus/自然对数底数e/"}},{"title":"树链剖分","createdAt":"2016-04-23","tags":["acm","算法","树链剖分"],"fields":{"slug":"/post/algorithm/tree/tcs/"}},{"title":"最长上升子序列（LIS）","createdAt":"2021-06-02","tags":["最长上升子序列","LIS"],"fields":{"slug":"/post/algorithm/lis/"}},{"title":"最长回文子串 Manacher 算法","createdAt":"2016-04-18","tags":["算法","字符串","回文串","manacher"],"fields":{"slug":"/post/algorithm/string/manacher/"}},{"title":"最长公共子序列（LCS）","createdAt":"2021-06-02","tags":["最长公共子序列","LCS"],"fields":{"slug":"/post/algorithm/lcs/"}},{"title":"背包九讲","createdAt":"2021-06-27","tags":["acm","算法","动态规划","背包问题"],"fields":{"slug":"/post/algorithm/knapsack/"}},{"title":"Dijkstra 算法","createdAt":"2021-05-29","tags":["算法","最短路","单源最短路","dijkstra"],"fields":{"slug":"/post/algorithm/graph/shortest-path/dijkstra/"}},{"title":"二分图","createdAt":"2016-07-17","tags":["算法","图论","二分图","学习笔记"],"fields":{"slug":"/post/algorithm/graph/bipartite-graph/"}},{"title":"防抖和节流","createdAt":"2021-09-03","tags":["coding","debounce","throttle"],"fields":{"slug":"/post/algorithm/debounce-and-throttle/"}},{"title":"精确覆盖问题和 DLX 算法","createdAt":"2021-07-24","tags":["算法","精确覆盖","DLX 算法"],"fields":{"slug":"/post/algorithm/dlx/"}},{"title":"POJ-1324 Holedox Moving 解题报告","createdAt":"2016-04-13","tags":["acm","bfs","图论","状态压缩","解题报告"],"fields":{"slug":"/post/acm/oj/poj/1324/"}},{"title":"网络流 24 题","createdAt":"2016-07-30","tags":["acm","算法","图论","网络流","二分图","解题报告","专题训练"],"fields":{"slug":"/post/algorithm/graph/network-flow/24-problems/"}},{"title":"网络流基础之最大权闭合图","createdAt":"2016-07-24","tags":["算法","图论","网络流","最大权闭合图"],"fields":{"slug":"/post/algorithm/graph/network-flow/最大权闭合图/"}},{"title":"HDU-5576 Expection of String 解题报告（原 2015-上海区域赛-E)","createdAt":"2016-04-24","tags":["acm","动态规划","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5576/"}},{"title":"剑指offer 解题报告","createdAt":"2021-07-15","tags":["专题训练","解题报告"],"fields":{"slug":"/post/acm/oj/nowcoder/jz-offer/"}},{"title":"2016 多校第 2 场","createdAt":"2016-07-22","tags":["acm","训练赛","数据结构","解题报告"],"fields":{"slug":"/post/acm/contest/multi-university-training/2016/2/"}},{"title":"HDU-5306 Gorgeous Sequence 解题报告","createdAt":"2016-04-09","tags":["acm","数据结构","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5306/"}},{"title":"51nod-1462 数据结构 -- 解题报告","createdAt":"2016-04-23","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/51nod/1462/"}},{"title":"百度之星 2016 解题报告","createdAt":"2016-06-03","tags":["acm","递推","状态压缩","动态规划","字典树","解题报告"],"fields":{"slug":"/post/acm/contest/baiduzhixing/2016/"}},{"title":"CCF 2015-09 最佳文章 解题报告","createdAt":"2016-06-26","tags":["acm","Aho-Corasick 自动机","矩阵快速幂","动态规划","解题报告"],"fields":{"slug":"/post/acm/oj/ccf/2015/09/E/"}},{"title":"HDU-5574 Colorful Tree 解题报告（原 2015-上海区域赛-C）","createdAt":"2016-04-12","tags":["acm","数据结构","树链剖分","线段树","解题报告"],"fields":{"slug":"/post/acm/oj/hdu/5574/"}}]}},"pageContext":{"contentType":"post","paginationUrl":"/posts","urlPrefix":"/posts","pageTotal":10,"pageSize":5,"pageCurrent":3,"limit":5,"skip":10}},"staticQueryHashes":[],"slicesMap":{}}