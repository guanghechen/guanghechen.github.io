<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>光和尘's RSS Feed</title>
        <link>https://me.guanghechen.com</link>
        <description>This is my personal feed!</description>
        <lastBuildDate>Sat, 04 Sep 2021 16:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>zh-cn</language>
        <image>
            <title>光和尘's RSS Feed</title>
            <url>https://me.guanghechen.com/favicon.png</url>
            <link>https://me.guanghechen.com</link>
        </image>
        <copyright>All rights reserved 2017-2023, guanghechen</copyright>
        <category>Technologie</category>
        <item>
            <title><![CDATA[Javascript 踩坑记——继承和原型链]]></title>
            <link>https://me.guanghechen.com/post/web/javascript/inherit</link>
            <guid>https://me.guanghechen.com/post/web/javascript/inherit</guid>
            <pubDate>Sat, 04 Sep 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">和其它面向对象的语言不同——继承只存在于两个不同的类之间——，Javascript 没有真正的类的概念。它采用一种原型链的机制，通过原型对象的连接关系来表达继承：通过某个属性（</span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text">）将原型对象连接成树形结构，则所谓的继承即为该树中节点与其祖先节点的血缘关系。在访问某个对象的属性时，会顺着原型对象树往上寻找目标属性，并返回第一个含有此属性的节点的对应属性值。这种继承策略带来的副产品是，可以轻易地通过修改原型对象上的属性使得所有继承它的对象都拥有此新增属性</span></p><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">其它面向对象的语言不得不修改类的实现才能获得此能力。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，构造函数如果返回一个对象，则此对象的 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 将指向
</span><pre class="yozora-inline-code"><code>Object.prototype</code></pre><span class="yozora-text">，如：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> alice <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'alice'</span><span class="token punctuation">)</span>
alice<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// => true</span>
alice<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">Javascript 访问属性时，会沿着继承链往上找，所以即便是一个空对象，还是能够访问其祖先节点上定义的属性的。</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">其它面向对象的语言不得不修改类的实现才能获得此能力。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，构造函数如果返回一个对象，则此对象的 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 将指向
</span><pre class="yozora-inline-code"><code>Object.prototype</code></pre><span class="yozora-text">，如：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> alice <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'alice'</span><span class="token punctuation">)</span>
alice<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// => true</span>
alice<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">Javascript 访问属性时，会沿着继承链往上找，所以即便是一个空对象，还是能够访问其祖先节点上定义的属性的。</span></p></div></div></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">和其它面向对象的语言不同——继承只存在于两个不同的类之间——，Javascript 没有真正的类的概念。它采用一种原型链的机制，通过原型对象的连接关系来表达继承：通过某个属性（</span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text">）将原型对象连接成树形结构，则所谓的继承即为该树中节点与其祖先节点的血缘关系。在访问某个对象的属性时，会顺着原型对象树往上寻找目标属性，并返回第一个含有此属性的节点的对应属性值。这种继承策略带来的副产品是，可以轻易地通过修改原型对象上的属性使得所有继承它的对象都拥有此新增属性</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text">。</span></p><div class="yozora-admonition yozora-admonition--warning"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" /></svg></span><span class="yozora-admonition__heading-title">CAUTION</span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 虽然被纳入了 ECMA 标准中，但目前它是不被推荐使用的，请使用
</span><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Reflect.getPrototypeOf()</span></a><span class="yozora-text"> 和 </span><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Reflect.setPrototypeOf()</span></a><span class="yozora-text">
代替。</span></p><p class="yozora-paragraph"><span class="yozora-text">出于方便叙述考虑，本文仍采用 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 进行演示。</span></p></div></div><h2 class="yozora-heading"><span class="yozora-text">原型链</span></h2><p class="yozora-paragraph"><span class="yozora-text">在 ES6 标准里，所有的对象都有两个内置属性 </span><pre class="yozora-inline-code"><code>constructor</code></pre><span class="yozora-text"> 和 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text">，其中：</span></p><ul class="yozora-list"><li class="yozora-list-item"><pre class="yozora-inline-code"><code>constructor</code></pre><span class="yozora-text">: 指向创建它的构造函数。</span></li><li class="yozora-list-item"><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text">: 指向创建它的构造函数的原型对象。</span></li></ul><p class="yozora-paragraph"><span class="yozora-text">构造函数还有一个内置属性 </span><pre class="yozora-inline-code"><code>prototype</code></pre><span class="yozora-text"> 指向它的原型对象；而构造函数的原型对象的
</span><pre class="yozora-inline-code"><code>constructor</code></pre><span class="yozora-text"> 又指向此构造函数。有点绕，可以看下面的代码示例</span><sup id="reference-2" class="yozora-footnote-reference"><a href="#2" title="2">[2]</a></sup><span class="yozora-text">：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token keyword">const</span> alice <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">)</span>

alice<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person <span class="token comment">// => true</span>
alice<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function <span class="token comment">// => true</span>
Person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person <span class="token comment">// => true</span>
</code></pre><h2 class="yozora-heading"><span class="yozora-text">继承</span></h2><p class="yozora-paragraph"><span class="yozora-text">前面提到过，Javascript 通过原型对象的连接关系来表达继承，因此我们可以修改连接关系来实现继承。比如下面的代码中，想让 </span><pre class="yozora-inline-code"><code>Student</code></pre><span class="yozora-text"> 继承自 </span><pre class="yozora-inline-code"><code>Person</code></pre><span class="yozora-text">，只需要将
</span><pre class="yozora-inline-code"><code>Student</code></pre><span class="yozora-text"> 的原型对象的 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 指向 </span><pre class="yozora-inline-code"><code>Person</code></pre><span class="yozora-text"> 的原型对象就好了（仅用于演示，请不要投入到生产中）：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">great</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade <span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showGrade</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Grade: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>grade<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span>

<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype

<span class="token keyword">const</span> alice <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
alice <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> <span class="token comment">// => true</span>
alice <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> <span class="token comment">// => true</span>

alice<span class="token punctuation">.</span><span class="token function">great</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// => 'Hello, undefined!'</span>
alice<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Alice'</span>
alice<span class="token punctuation">.</span><span class="token function">showGrade</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// => 'Grade: 2'</span>
alice<span class="token punctuation">.</span><span class="token function">great</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// => 'Hello, Alice!'</span>
</code></pre><div class="yozora-admonition yozora-admonition--warning"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" /></svg></span><span class="yozora-admonition__heading-title">CAUTION</span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">上面的修改看起来很直观，但直接操作 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 是不被推荐的，你可以使用
</span><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Reflect.setPrototypeOf()</span></a><span class="yozora-text"> 来做修改。</span></p></div></div><hr class="yozora-thematic-break" /><p class="yozora-paragraph"><span class="yozora-text">此外，原型对象之间的连接还可以通过 </span><pre class="yozora-inline-code"><code>constructor</code></pre><span class="yozora-text"> 和 </span><pre class="yozora-inline-code"><code>constructor.prototype</code></pre><span class="yozora-text"> 来表达，（前文提到过，对象的 </span><pre class="yozora-inline-code"><code>constructor</code></pre><span class="yozora-text"> 指向其构造函数）如最开始的例子中：</span></p><pre class="yozora-code"><code>alice<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
Student<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
Person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
</code></pre><p class="yozora-paragraph"><span class="yozora-text">等价于：</span></p><pre class="yozora-code"><code>alice<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
</code></pre><p class="yozora-paragraph"><span class="yozora-text">因此我们可以利用 </span><pre class="yozora-inline-code"><code>Object.create</code></pre><span class="yozora-text"> 来创建一个以 </span><pre class="yozora-inline-code"><code>Person.prototype</code></pre><span class="yozora-text"> 为原型对象的对象，然后将 </span><pre class="yozora-inline-code"><code>Student.prototype</code></pre><span class="yozora-text"> 指向此对象：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">Child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>
    prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
  <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype
<span class="token punctuation">}</span>
</code></pre><div class="yozora-admonition yozora-admonition--success"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z" /></svg></span><span class="yozora-admonition__heading-title">SUCCESS</span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">注意上面代码高亮部分，将 </span><pre class="yozora-inline-code"><code>Child.prototype</code></pre><span class="yozora-text"> 的值复制到了新的原型对象中，否则调用此继承函数后，原先定义在 </span><pre class="yozora-inline-code"><code>Child.prototype</code></pre><span class="yozora-text"> 上的属性会丢失。</span></p></div></div><h2 class="yozora-heading"><span class="yozora-text">创建对象</span></h2><p class="yozora-paragraph"><span class="yozora-text">在 </span><pre class="yozora-inline-code"><code>Javascript</code></pre><span class="yozora-text"> 中创建对象有多种方式：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>new</code></pre><span class="yozora-text">: </span><pre class="yozora-inline-code"><code>new Person()</code></pre><span class="yozora-text"> 创建并返回一个以 </span><pre class="yozora-inline-code"><code>Person.constructor</code></pre><span class="yozora-text"> 作为原型对象的对象，因此返回的对象继承自 </span><pre class="yozora-inline-code"><code>Person</code></pre></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Object.create</code></pre><span class="yozora-text">: </span><pre class="yozora-inline-code"><code>Object.create(__proto__)</code></pre><span class="yozora-text">: 接受一个对象 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text">，创建并返回一个以此对象作为原型对象的对象，因此使用 </span><pre class="yozora-inline-code"><code>Object.create(null)</code></pre><span class="yozora-text"> 可以创建一个不继承自任何对象的对象。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>const alice = { name: 'alice' }</code></pre><span class="yozora-text">: 等价于 </span><pre class="yozora-inline-code"><code>const alice = new Object({ name: 'alice' })</code></pre></p></li></ul><h2 class="yozora-heading"><span class="yozora-text">Related</span></h2><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Reflect.getPrototypeOf() | MDN</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Reflect.setPrototypeOf() | MDN</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" title="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Inheritance in JavaScript | MDN</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://stackoverflow.com/questions/12201082/prototypal-inheritance-concept-in-javascript-as-a-prototype-based-language" title="https://stackoverflow.com/questions/12201082/prototypal-inheritance-concept-in-javascript-as-a-prototype-based-language" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">prototypal inheritance concept in javascript as a prototype based language | Stack Overflow</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://stackoverflow.com/questions/4166616/understanding-the-difference-between-object-create-and-new-somefunction" title="https://stackoverflow.com/questions/4166616/understanding-the-difference-between-object-create-and-new-somefunction" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Understanding the difference between Object.create() and new SomeFunction() | Stack Overflow</span></a></li></ul><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">其它面向对象的语言不得不修改类的实现才能获得此能力。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，构造函数如果返回一个对象，则此对象的 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 将指向
</span><pre class="yozora-inline-code"><code>Object.prototype</code></pre><span class="yozora-text">，如：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> alice <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'alice'</span><span class="token punctuation">)</span>
alice<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// => true</span>
alice<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">Javascript 访问属性时，会沿着继承链往上找，所以即便是一个空对象，还是能够访问其祖先节点上定义的属性的。</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">其它面向对象的语言不得不修改类的实现才能获得此能力。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，构造函数如果返回一个对象，则此对象的 </span><pre class="yozora-inline-code"><code>__proto__</code></pre><span class="yozora-text"> 将指向
</span><pre class="yozora-inline-code"><code>Object.prototype</code></pre><span class="yozora-text">，如：</span></p><pre class="yozora-code"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> alice <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">'alice'</span><span class="token punctuation">)</span>
alice<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// => true</span>
alice<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// => true</span>
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">Javascript 访问属性时，会沿着继承链往上找，所以即便是一个空对象，还是能够访问其祖先节点上定义的属性的。</span></p></div></div></ul></div></footer></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[防抖和节流]]></title>
            <link>https://me.guanghechen.com/post/algorithm/debounce-and-throttle</link>
            <guid>https://me.guanghechen.com/post/algorithm/debounce-and-throttle</guid>
            <pubDate>Thu, 02 Sep 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">防抖（debounce）和节流（throttle）在前端开发中十分常见，它们都是针对一个事件被连续触发时限制执行次数的算法，不同的是 debounce 只处理最后一次事件触发，而 throttle
则以一个固定的频率处理事件触发。你可以在</span><a class="yozora-link" href="http://demo.nimius.net/debounce_throttle/" title="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">这里</span></a><span class="yozora-text">直观地观察到它们之间的区别。</span></p><p class="yozora-paragraph"><span class="yozora-text">在开始正文之前，先看一下 Typescript 的两个工具类型 </span></p><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>infer</code></pre><span class="yozora-text"> 关键字是在 </span><em class="yozora-emphasis"><span class="yozora-text">Typescript@2.9</span></em><span class="yozora-text"> 引入的，它用于在条件类型下的类型推断，比如我们在想要获得一个 </span><pre class="yozora-inline-code"><code>Promise</code></pre><span class="yozora-text"> 对象的返回值类型：</span></p><pre class="yozora-code"><code>type DataType = T extends Promise ? R : T

type A = DataType          // =&gt; number[]
type B = DataType&gt;   // =&gt; string
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">若开启了 </span><pre class="yozora-inline-code"><code>use strict;</code></pre><span class="yozora-text"> 选项，则 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针默认指向 </span><pre class="yozora-inline-code"><code>undefined</code></pre></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>infer</code></pre><span class="yozora-text"> 关键字是在 </span><em class="yozora-emphasis"><span class="yozora-text">Typescript@2.9</span></em><span class="yozora-text"> 引入的，它用于在条件类型下的类型推断，比如我们在想要获得一个 </span><pre class="yozora-inline-code"><code>Promise</code></pre><span class="yozora-text"> 对象的返回值类型：</span></p><pre class="yozora-code"><code>type DataType = T extends Promise ? R : T

type A = DataType          // =&gt; number[]
type B = DataType&gt;   // =&gt; string
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">若开启了 </span><pre class="yozora-inline-code"><code>use strict;</code></pre><span class="yozora-text"> 选项，则 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针默认指向 </span><pre class="yozora-inline-code"><code>undefined</code></pre></p></div></div></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">防抖（debounce）和节流（throttle）在前端开发中十分常见，它们都是针对一个事件被连续触发时限制执行次数的算法，不同的是 debounce 只处理最后一次事件触发，而 throttle
则以一个固定的频率处理事件触发。你可以在</span><a class="yozora-link" href="http://demo.nimius.net/debounce_throttle/" title="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">这里</span></a><span class="yozora-text">直观地观察到它们之间的区别。</span></p><p class="yozora-paragraph"><span class="yozora-text">在开始正文之前，先看一下 Typescript 的两个工具类型 </span><pre class="yozora-inline-code"><code>Parameters</code></pre><span class="yozora-text"> 和 </span><pre class="yozora-inline-code"><code>ReturnType</code></pre><span class="yozora-text">，引入它们的目的是因为 </span><pre class="yozora-inline-code"><code>debounce</code></pre><span class="yozora-text"> 和 </span><pre class="yozora-inline-code"><code>throttle</code></pre><span class="yozora-text"> 的实现都以高阶函数的方式展现，本着</span><del class="yozora-delete"><span class="yozora-text">作死无极限</span></del><span class="yozora-text">精益求精的态度，在实现时自然要考虑返回的函数和原函数应具有相同的参数类型的调用体验啦。</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Parameters</code></pre><span class="yozora-text">: </span><em class="yozora-emphasis"><span class="yozora-text">Typescript@3.1</span></em><span class="yozora-text"> 引入的工具类型，用于获取一个函数的参数类型</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text">：</span></p><pre class="yozora-code"><code>type Parameters any&gt; = 
  T extends (...args: infer P) =&gt; any ? P : never

type A = Parameters&lt;(x: number, y: number) =&gt; void&gt;
// A 的类型为 [x: number, y: number]
</code></pre></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>ReturnType</code></pre><span class="yozora-text">: </span><em class="yozora-emphasis"><span class="yozora-text">Typescript@2.8</span></em><span class="yozora-text"> 引入的工具类型，用于获取一个函数的返回类型：</span></p><pre class="yozora-code"><code>type ReturnType any&gt; =
  T extends (...args: any) =&gt; infer R ? R : any

type A = ReturnType&lt;(x: number, y: number) =&gt; string&gt;
// A 的类型为 string
</code></pre></li></ul><h2 class="yozora-heading"><span class="yozora-text">防抖 (debounce)</span></h2><p class="yozora-paragraph"><span class="yozora-text">防抖是指事件连续触发时，只在最后一次事件触发后再执行响应动作。比如，事件被触发的
</span><span class="yozora-inline-math">t</span><span class="yozora-text"> 秒后才执行回调，若 </span><span class="yozora-inline-math">t</span><span class="yozora-text"> 秒内此事件被再次触发，则重新计时。</span></p><p class="yozora-paragraph"><span class="yozora-text">适用场景：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">提交表单时，快速点击多次，但只执行一次提交。</span></li><li class="yozora-list-item"><span class="yozora-text">搜索框中输入内容实时展示关联条目，只在输入停顿时才发起查询请求（和 </span><pre class="yozora-inline-code"><code>throttle</code></pre><span class="yozora-text">
中列出的场景有所不同）。</span></li></ul><h3 class="yozora-heading"><span class="yozora-text">简化版</span></h3><p class="yozora-paragraph"><span class="yozora-text">在了解了 debounce 要解决的问题后，不难想到可以利用 </span><pre class="yozora-inline-code"><code>setTimeout</code></pre><span class="yozora-text"> 来倒计时，当函数被顺利执行时，则重置定时器，表示当前处于空闲状态；否则，有一个新的事件在倒计时未结束时触发，则同样将计时器重置，但只开始计时，不执行任务。由此不难实现一个简单的版本：</span></p><pre class="yozora-code"><code>export function debounce any&gt;(
  fn: T,
  wait?: number,
): (...args: Parameters) =&gt; void {
  // 浏览器中 setTimeout 返回的是 number
  // 而 NodeJs 中返回的是 NodeJs.Timeout
  let timeout: ReturnType
  return debounced

  function debounced(...args: Parameters): void {
    if (timeout) clearTimeout(timeout)
    const context = this
    timeout = setTimeout(() =&gt; fn.apply(context, args), wait)
  }
}
</code></pre><p class="yozora-paragraph"><span class="yozora-text">注意上面代码的高亮部分，将 </span><pre class="yozora-inline-code"><code>debounced</code></pre><span class="yozora-text"> 的 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针绑定到 </span><pre class="yozora-inline-code"><code>fn</code></pre><span class="yozora-text"> 中再执行，这是
Javascript 老生常谈的问题了：当 </span><pre class="yozora-inline-code"><code>fn</code></pre><span class="yozora-text"> 中通过 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 引用变量时，</span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针将默认指向 </span><pre class="yozora-inline-code"><code>Window</code></pre><span class="yozora-text"> </span><sup id="reference-footnote-2" class="yozora-footnote-reference"><a href="#footnote-2" title="2">[2]</a></sup><span class="yozora-text">，而在有些情况下，执行 </span><pre class="yozora-inline-code"><code>fn</code></pre><span class="yozora-text"> 时会显式地绑定一个 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针，如 DOM 事件的回调函数中，会把触发事件的元素作为 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 绑定到 </span><pre class="yozora-inline-code"><code>fn</code></pre><span class="yozora-text"> 中，于是我们可以通过 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针去访问当前触发事件的元素：</span></p><pre class="yozora-code"><code>document.body.addEventListener('click', debounce(function () {
  console.log(this.innerText)
}))
</code></pre><h3 class="yozora-heading"><span class="yozora-text">带返回值</span></h3><p class="yozora-paragraph"><span class="yozora-text">上面的实现版本中，</span><pre class="yozora-inline-code"><code>debounced</code></pre><span class="yozora-text"> 返回的是 </span><pre class="yozora-inline-code"><code>void</code></pre><span class="yozora-text">，对于大多数场景已经够用了，但如果要返回值的话，应该如何考虑呢？</span><pre class="yozora-inline-code"><code>debounced</code></pre><span class="yozora-text"> 在事件连续多次触发时只会执行一次，我们可以记录下最后一次执行时的结果，然后在每次非实际执行时，返回上一次的结果：</span></p><pre class="yozora-code"><code>export function debounce any&gt;(
  fn: T,
  wait?: number,
): (...args: Parameters) =&gt; ReturnType | void {
  let timeout: ReturnType
  let lastResult: ReturnType | undefined
  return debounced

  function debounced(...args: Parameters): ReturnType | void {
    if (timeout) clearTimeout(timeout)

    const context = this
    timeout = setTimeout(function () {
      lastResult = fn.apply(context, args)
    }, wait)
    return lastResult
  }
}
</code></pre><h2 class="yozora-heading"><span class="yozora-text">节流 (throttle)</span></h2><p class="yozora-paragraph"><span class="yozora-text">节流是指事件连续触发时，在一个固定的时间间隔内只执行一次响应动作。比如事件被触发的 </span><span class="yozora-inline-math">t</span><span class="yozora-text"> 秒后再次执行回调，若 </span><span class="yozora-inline-math">t</span><span class="yozora-text"> 秒内此事件被再次触发，直接无视，并不重新计时；而对于 </span><span class="yozora-inline-math">t</span><span class="yozora-text"> 秒后第一次触发的事件会执行响应，并重新计时。</span></p><p class="yozora-paragraph"><span class="yozora-text">适用场景：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">UI 的拖拽事件、鼠标点击事件、滚动事件等，无需为每一次事件触发进行响应，但需要在一个时间范围内至少作出一次响应，否则会影响用户体验（掉帧）。</span></li><li class="yozora-list-item"><span class="yozora-text">搜索框中输入内容实时展示关联条目，每隔一个固定的时间间隔（如 </span><span class="yozora-inline-math">1</span><span class="yozora-text"> 秒）发起一次查询请求（和 </span><pre class="yozora-inline-code"><code>debounce</code></pre><span class="yozora-text"> 中列出的场景有所不同）。</span></li></ul><h3 class="yozora-heading"><span class="yozora-text">简化版</span></h3><p class="yozora-paragraph"><span class="yozora-text">既然节流只需保证一个固定周期内只执行一次函数，则可以在空闲状态时接收事件触发，并在事件触发时启动一个倒计时的定时器，在倒计时未结束前，忽略所有的其它事件触发，等到上一次处理操作完成后，再将计时器重置，表明重新进入空闲状态。由此可以实现一个简化版的节流函数：</span></p><pre class="yozora-code"><code>export function throttle any&gt;(
  fn: T,
  wait?: number,
): (...args: Parameters) =&gt; void {
  let timeout: ReturnType
  return throttled

  function throttled(...args: Parameters): void {
    if (timeout) return

    const context = this
    timeout = setTimeout(function () {
      fn.apply(context, args)
      timeout = null
    }, wait)
  }
}
</code></pre><p class="yozora-paragraph"><span class="yozora-text">上面的代码中仍然考虑了 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针的指向问题，此处不再赘述。</span></p><h3 class="yozora-heading"><span class="yozora-text">带返回值</span></h3><p class="yozora-paragraph"><span class="yozora-text">同样地，我们可以记录下上一次 </span><pre class="yozora-inline-code"><code>throttled</code></pre><span class="yozora-text"> 返回值，在未实际执行的事件触发中，简单地返回一次记录的返回值。</span></p><pre class="yozora-code"><code>export function throttle any&gt;(
  fn: T,
  wait?: number,
): (...args: Parameters) =&gt; ReturnType | void {
  let timeout: ReturnType
  let lastResult: ReturnType | undefined
  return throttled

  function throttled(...args: Parameters): ReturnType | void {
    if (timeout) return lastResult

    const context = this
    timeout = setTimeout(function () {
      lastResult = fn.apply(context, args)
      timeout = null
    }, wait)
  }
}
</code></pre><h2 class="yozora-heading"><span class="yozora-text">Related</span></h2><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function" title="https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Difference Between throttling and debouncing a function | Stack Overflow</span></a></li></ul><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>infer</code></pre><span class="yozora-text"> 关键字是在 </span><em class="yozora-emphasis"><span class="yozora-text">Typescript@2.9</span></em><span class="yozora-text"> 引入的，它用于在条件类型下的类型推断，比如我们在想要获得一个 </span><pre class="yozora-inline-code"><code>Promise</code></pre><span class="yozora-text"> 对象的返回值类型：</span></p><pre class="yozora-code"><code>type DataType = T extends Promise ? R : T

type A = DataType          // =&gt; number[]
type B = DataType&gt;   // =&gt; string
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">若开启了 </span><pre class="yozora-inline-code"><code>use strict;</code></pre><span class="yozora-text"> 选项，则 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针默认指向 </span><pre class="yozora-inline-code"><code>undefined</code></pre></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>infer</code></pre><span class="yozora-text"> 关键字是在 </span><em class="yozora-emphasis"><span class="yozora-text">Typescript@2.9</span></em><span class="yozora-text"> 引入的，它用于在条件类型下的类型推断，比如我们在想要获得一个 </span><pre class="yozora-inline-code"><code>Promise</code></pre><span class="yozora-text"> 对象的返回值类型：</span></p><pre class="yozora-code"><code>type DataType = T extends Promise ? R : T

type A = DataType          // =&gt; number[]
type B = DataType&gt;   // =&gt; string
</code></pre></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">若开启了 </span><pre class="yozora-inline-code"><code>use strict;</code></pre><span class="yozora-text"> 选项，则 </span><pre class="yozora-inline-code"><code>this</code></pre><span class="yozora-text"> 指针默认指向 </span><pre class="yozora-inline-code"><code>undefined</code></pre></p></div></div></ul></div></footer></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[XSS 与 CSRF 的攻防]]></title>
            <link>https://me.guanghechen.com/post/web/security/xss-csrf</link>
            <guid>https://me.guanghechen.com/post/web/security/xss-csrf</guid>
            <pubDate>Wed, 18 Aug 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">本文主要参考了美团技术团队的系列文章：</span></p><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://tech.meituan.com/2018/09/27/fe-security.html" title="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（一）：如何防止XSS攻击？</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" title="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（二）：如何防止CSRF攻击？</span></a></li></ul><h2 class="yozora-heading"><span class="yozora-text">XSS 攻击</span></h2><p class="yozora-paragraph"><span class="yozora-text">XSS</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text"> (Cross-site Scripting) 跨站脚本攻击，是一种代码注入攻击。攻击者通过在
web 页面中插入浏览器上可执行的恶意代码，在用户浏览网页时恶意代码会被浏览器执行，从而完成攻击。</span></p><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">为不和层叠样式表（Cascading Styles Sheets, CSS）的缩写混淆，故将跨站脚本攻击缩写写为 XSS。可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC</span></a></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">有趣的是，</span><pre class="yozora-inline-code"><code>Referer</code></pre><span class="yozora-text"> 实际上是 </span><pre class="yozora-inline-code"><code>Referrer</code></pre><span class="yozora-text"> 的错误拼写，难以想象这样低级的错误在制定规范的过程发生并保留了下来，可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" title="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80</span></a></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">为不和层叠样式表（Cascading Styles Sheets, CSS）的缩写混淆，故将跨站脚本攻击缩写写为 XSS。可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC</span></a></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">有趣的是，</span><pre class="yozora-inline-code"><code>Referer</code></pre><span class="yozora-text"> 实际上是 </span><pre class="yozora-inline-code"><code>Referrer</code></pre><span class="yozora-text"> 的错误拼写，难以想象这样低级的错误在制定规范的过程发生并保留了下来，可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" title="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80</span></a></p></div></div></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">本文主要参考了美团技术团队的系列文章：</span></p><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://tech.meituan.com/2018/09/27/fe-security.html" title="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（一）：如何防止XSS攻击？</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" title="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（二）：如何防止CSRF攻击？</span></a></li></ul><h2 class="yozora-heading"><span class="yozora-text">XSS 攻击</span></h2><p class="yozora-paragraph"><span class="yozora-text">XSS</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text"> (Cross-site Scripting) 跨站脚本攻击，是一种代码注入攻击。攻击者通过在
web 页面中插入浏览器上可执行的恶意代码，在用户浏览网页时恶意代码会被浏览器执行，从而完成攻击。</span></p><p class="yozora-paragraph"><span class="yozora-text">根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">存储型 XSS 攻击步骤</span></p><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">攻击者将恶意代码提交到目标网站的数据库中（如在输入框中输入
</span><pre class="yozora-inline-code"><code>"&gt;</code></pre><span class="yozora-text">）；</span></li><li class="yozora-list-item"><span class="yozora-text">用户访问目标网站，</span><strong class="yozora-strong"><span class="yozora-text">服务端</span></strong><span class="yozora-text">从数据库中取出包含恶意代码的数据，未经正确转义就通过模板引擎渲染成 HTML 返回；</span></li><li class="yozora-list-item"><span class="yozora-text">用户浏览器渲染接收到的 HTML，混在其中的恶意代码得到执行。</span></li></ol></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">反射型 XSS 攻击步骤</span></p><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">攻击者构造出特殊的 url，其中包含恶意代码（如
</span><pre class="yozora-inline-code"><code>https://example.com/?keyword=%3Cscript%3Ealert('xss')%3C/script%3E</code></pre><span class="yozora-text">）；</span></li><li class="yozora-list-item"><span class="yozora-text">用户访问携带恶意代码的 URL，</span><strong class="yozora-strong"><span class="yozora-text">服务端</span></strong><span class="yozora-text">从 URL 中取出含恶意代码的参数，未经正确转义就通过模板引擎渲染成 HTML 返回；</span></li><li class="yozora-list-item"><span class="yozora-text">用户浏览器渲染接收到的 HTML，混在其中的恶意代码得到执行。</span></li></ol></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">DOM 型 XSS 攻击步骤</span></p><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">攻击者构造出特殊的 url，其中包含恶意代码（如
</span><pre class="yozora-inline-code"><code>https://example.com/?to=javascript%3Aalert('xss')</code></pre><span class="yozora-text">）；</span></li><li class="yozora-list-item"><span class="yozora-text">用户访问携带恶意代码的 URL，</span><strong class="yozora-strong"><span class="yozora-text">前端</span></strong><span class="yozora-text">从 URL 中取出含恶意代码的参数，传入特殊的 HTML 属性中（如 </span><pre class="yozora-inline-code"><code>link</code></pre><span class="yozora-text">），在接下来的事件触发中（如点击前一个括号中的链接）恶意代码得到执行。</span></li></ol></li></ul><p class="yozora-paragraph"><span class="yozora-text">在 web 页面中，脚本注入有很多方法，常见的有：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">构造特殊的 url：有些网站会从 url 中拉取参数直接进行字符串拼接；</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">特殊的 HTML 属性：如在 </span><pre class="yozora-inline-code"><code>href</code></pre><span class="yozora-text">、</span><pre class="yozora-inline-code"><code>src</code></pre><span class="yozora-text"> 属性中，包含 </span><pre class="yozora-inline-code"><code>javascript:</code></pre><span class="yozora-text"> 等可执行代码；</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">事件回调函数（如 </span><pre class="yozora-inline-code"><code>onload</code></pre><span class="yozora-text">、</span><pre class="yozora-inline-code"><code>onclick</code></pre><span class="yozora-text">）中注入恶意代码；</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">在标签属性中包含 </span><pre class="yozora-inline-code"><code>"</code></pre><span class="yozora-text"> 或 </span><pre class="yozora-inline-code"><code>&gt;</code></pre><span class="yozora-text">，提前关闭属性甚至合法的标签，从而注入额外的属性甚至 HTML 标签。</span></p></li></ul><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">XSS 攻击举例 节选自 </span><a class="yozora-link" href="https://tech.meituan.com/2018/09/27/fe-security.html" title="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（一）：如何防止XSS攻击？</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">在早期前后端未分离时，很流行使用 JSP 等模板引擎生成 HTML，很容易忘记对用户输入的数据进行转义，直接通过模板引擎进行字符串拼接，从而产生 XSS 漏洞：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>script</code></pre><span class="yozora-text"> 标签</span></p><pre class="yozora-code"><code>keyword: &lt;%= getParameter("keyword") %&gt;
</code></pre><p class="yozora-paragraph"><span class="yozora-text">如上是一段 JSP 代码，如果攻击者分享了一个 url，其内容为
</span><pre class="yozora-inline-code"><code>https://example.com/?keyword=%3Cscript%3Ealert('xss')%3C/script%3E</code></pre><span class="yozora-text">，则渲染结果为：</span></p><pre class="yozora-code"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>keyword: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre><p class="yozora-paragraph"><span class="yozora-text">url 中包含的 js 代码得到执行。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">内联脚本 </span><pre class="yozora-inline-code"><code>javascript:</code></pre><span class="yozora-text">（这段字符浏览器不区分大小写）</span></p><pre class="yozora-code"><code>"&gt;跳转...
</code></pre><p class="yozora-paragraph"><span class="yozora-text">同样地，对于面面这段 JSP 代码，若 url 为
</span><pre class="yozora-inline-code"><code>https://example.com/?to=javascript:alert('xss')</code></pre><span class="yozora-text">，则渲染结果为：</span></p><pre class="yozora-code"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:alert('xss')<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>跳转...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>
</code></pre><pre class="yozora-code"><code>() =&gt; (
  跳转...`
    }} 
  /&gt;
)
</code></pre></li></ul></div></div><h2 class="yozora-heading"><span class="yozora-text">XSS 攻击的预防</span></h2><p class="yozora-paragraph"><span class="yozora-text">XSS 攻击有如下特点：</span></p><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">攻击者构造并提交恶意代码</span></li><li class="yozora-list-item"><span class="yozora-text">浏览器执行恶意代码</span></li></ol><p class="yozora-paragraph"><span class="yozora-text">我们可以针对这些特点进行防御。</span></p><h3 class="yozora-heading"><span class="yozora-text">输入过滤</span></h3><p class="yozora-paragraph"><span class="yozora-text">由于网络服务中所有请求都可以绕过前端直接向服务端发起，因此仅在浏览器端中做输入过滤是不能起到防范xss的效果的。但是后端做输入过滤同样存在问题，原因是不同的客户端及其渲染框架对于要接受的数据的转义规则存在差别，而服务端要做过滤只能选择某一种转义规则，众口难调。贸然进行转义可能会丢失原意。</span></p><p class="yozora-paragraph"><span class="yozora-text">比如一个合法用户提交的内容为 </span><pre class="yozora-inline-code"><code>a &lt; b</code></pre><span class="yozora-text">，后端在写入数据前，将其转义成 </span><pre class="yozora-inline-code"><code>a &lt; b</code></pre><span class="yozora-text">，这在纯 HTML 中渲染是有效的，但如果它是作为一段 url 内容则这个转义会破坏了原意。此外，对于 React / Vue 等现代前端框架，在渲染内容时需要的是原始的字符串内容，转义后的内容无法正确展示。</span></p><h3 class="yozora-heading"><span class="yozora-text">纯前端渲染</span></h3><p class="yozora-paragraph"><span class="yozora-text">采用前后端分离的开发模式，前端使用 React / Vue 等现代前端框架进行开发，以 React
为例：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">在不使用 </span><pre class="yozora-inline-code"><code>dangerouslySetInnerHTML</code></pre><span class="yozora-text"> 属性渲染数据时，其内部逻辑天然地对 HTML
进行了严格的转义。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">在代码规范中严禁内联 javascript 的事件注册方式，统一通过 React / jsx 提供的
Event Handlers 进行定义（在原始的 html / js 项目中，可以用 </span><pre class="yozora-inline-code"><code>.addEventListener</code></pre><span class="yozora-text">
方法进行事件注册） 函数来注册事件回调函数。</span></p></li></ul><h3 class="yozora-heading"><span class="yozora-text">其它防御策略</span></h3><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://tech.meituan.com/2018/09/27/fe-security.html" title="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（一）：如何防止XSS攻击？</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">Content Security Policy
严格的 CSP 在 XSS 的防范中可以起到以下的作用：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">禁止加载外域代码，防止复杂的攻击逻辑。</span></li><li class="yozora-list-item"><span class="yozora-text">禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</span></li><li class="yozora-list-item"><span class="yozora-text">禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</span></li><li class="yozora-list-item"><span class="yozora-text">禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</span></li><li class="yozora-list-item"><span class="yozora-text">合理使用上报可以及时发现 XSS，利于尽快修复问题。</span></li></ul></div></div><h2 class="yozora-heading"><span class="yozora-text">CSRF 攻击</span></h2><p class="yozora-paragraph"><span class="yozora-text">CSRF (Cross-site Request Forgery) 跨站请求伪造，是通过诱导受害者访问第三方网站，并在第三方网站中盗用用户在目标网站上的身份（Cookie）发送跨站请求进行攻击的。</span></p><div class="yozora-admonition yozora-admonition--success"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">CSRF 攻击举例</span></span></h5><div class="yozora-admonition__body"><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">受害者登录 </span><pre class="yozora-inline-code"><code>a.com</code></pre></li><li class="yozora-list-item"><span class="yozora-text">攻击者引诱受害者访问 </span><pre class="yozora-inline-code"><code>danger.com</code></pre><span class="yozora-text">（攻击者可以利用或控制的站点）</span></li><li class="yozora-list-item"><span class="yozora-text">在 </span><pre class="yozora-inline-code"><code>danger.com</code></pre><span class="yozora-text"> 中，向 </span><pre class="yozora-inline-code"><code>a.com</code></pre><span class="yozora-text"> 发起一个请求（浏览器默认会携带 </span><pre class="yozora-inline-code"><code>a.com</code></pre><span class="yozora-text"> 的 Cookie）</span></li><li class="yozora-list-item"><pre class="yozora-inline-code"><code>a.com</code></pre><span class="yozora-text"> 接收到请求，对请求进行验证（校验 Cookie），确认是受害者的凭证后执行请求</span></li></ol></div></div><p class="yozora-paragraph"><span class="yozora-text">发送跨站请求有多种方式：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">图片地址：浏览器在渲染页面时会自动访问 </span><pre class="yozora-inline-code"><code>img</code></pre><span class="yozora-text"> 元素中指定的 </span><pre class="yozora-inline-code"><code>src</code></pre><span class="yozora-text"> 地址来加载图片，它本质上是一个 </span><pre class="yozora-inline-code"><code>GET</code></pre><span class="yozora-text"> 请求，如将此地址设置成 </span><pre class="yozora-inline-code"><code></code></pre><span class="yozora-text">，则在浏览器尝试加载此“图片”时，一次恶意的跨站请求就完成了。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">链接地址：需要诱导用户点击才会触发，如 </span><pre class="yozora-inline-code"><code></code></pre></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">提交表单：此攻击方式比较严格，通常需要黑客完全控制第三方站点，可以在其上执行自己的 javascript 脚本，如：</span></p><pre class="yozora-code"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> 
  <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hack-form<span class="token punctuation">"</span></span>
  <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://bank.com/withdraw<span class="token punctuation">"</span></span>
  <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span>
<span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>amount<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>to<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'hack-form'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre></li></ul><h2 class="yozora-heading"><span class="yozora-text">CSRF 攻击的防护</span></h2><p class="yozora-paragraph"><span class="yozora-text">CSRF 攻击有如下特点：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">攻击通常发生在第三方网站。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">攻击通过冒用受害者的登陆凭证发起恶意请求完成，整个阶段中不能获得用户的登录凭证。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">跨站请求十分容易达成，图片、超链接、表单提交，在一些可以发图、链接的第三方平台中可以直接嵌入恶意请求（如在一些支持 Markdown 语法的评论框中内嵌一个恶意的请求地址作为 url 的图片）。</span></p><p class="yozora-paragraph"><span class="yozora-text">如果被攻击的目标站点中有上述容易被利用的功能，则攻击可以直接在本域下进行，此时攻击可以绕过同源策略的防御机制。</span></p></li></ul><p class="yozora-paragraph"><span class="yozora-text">我们可以针对这些特点进行防御。</span></p><h3 class="yozora-heading"><span class="yozora-text">同源检测</span></h3><p class="yozora-paragraph"><span class="yozora-text">CSRF 攻击大多是利用第三方站点发起恶意请求，因此直接拒绝来自第三方站点的请求进行规避（此方法对于本站下发起的 CSRF 攻击无效）。</span></p><p class="yozora-paragraph"><span class="yozora-text">如何判断请求是否来自外域：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">检查 HTTP Header 中的 </span><pre class="yozora-inline-code"><code>Origin</code></pre><span class="yozora-text"> 字段</span></p><div class="yozora-admonition yozora-admonition--warning"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" title="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（二）：如何防止CSRF攻击？</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">Origin 在以下两种情况下不存在：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">IE11 同源策略：IE11 不会在 CORS 请求上添加 Origin 字段。参见
</span><a class="yozora-link" href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#IE_Exceptions" title="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#IE_Exceptions" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#IE_Exceptions</span></a></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">302 重定向：在 302 重定向之后的请求中，请求头上不包含 Origin 字段。</span></p></li></ul></div></div></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">检查 HTTP Header 中的 </span><pre class="yozora-inline-code"><code>Referer</code></pre><sup id="reference-2" class="yozora-footnote-reference"><a href="#2" title="2">[2]</a></sup><span class="yozora-text"> 字段</span></p><p class="yozora-paragraph"><span class="yozora-text">Referer 字段记录了请求的来源地址：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">对于 ajax 请求以及图片、脚本等资源请求，Referer 为发起请求的页面地址</span></li><li class="yozora-list-item"><span class="yozora-text">对于页面跳转，Referer 为页面历史记录中的上一个页面地址</span></li></ul><div class="yozora-admonition yozora-admonition--info"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 15h2v2h-2v-2zm0-8h2v6h-2V7zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Referrer-Policy | MDN</span></a></span></h5><div class="yozora-admonition__body"><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: no-referrer</code></pre><span class="yozora-text">:
整个 Referer 首部会被移除。访问来源信息不随着请求一起发送。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: no-referrer-when-downgrade</code></pre><span class="yozora-text">: （默认值）在没有指定任何策略的情况下用户代理的默认行为。在同等安全级别的情况下，引用页面的地址会被发送(HTTPS-&gt;HTTPS)，但是在降级的情况下不会被发送 (HTTPS-&gt;HTTP)。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: origin</code></pre><span class="yozora-text">:
在任何情况下，仅发送文件的源作为引用地址。例如 https</span><pre class="yozora-inline-code"><code>://example.com/page.html</code></pre><span class="yozora-text">
会将 </span><pre class="yozora-inline-code"><code>https://example.com/</code></pre><span class="yozora-text"> 作为引用地址。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: origin-when-cross-origin</code></pre><span class="yozora-text">:
对于同源的请求，会发送完整的 url 作为引用地址，但是对于非同源请求仅发送文件的源。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: same-origin</code></pre><span class="yozora-text">:
对于同源的请求会发送引用地址，但是对于非同源请求则不发送引用地址信息。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: strict-origin</code></pre><span class="yozora-text">:
在同等安全级别的情况下，发送文件的源作为引用地址(HTTPS-&gt;HTTPS)，但是在降级的情况下不会发送 (HTTPS-&gt;HTTP)。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: strict-origin-when-cross-origin</code></pre><span class="yozora-text">:
对于同源的请求，会发送完整的URL作为引用地址；在同等安全级别的情况下，发送文件的源作为引用地址(HTTPS-&gt;HTTPS)；在降级的情况下不发送此首部 (HTTPS-&gt;HTTP)。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><pre class="yozora-inline-code"><code>Referrer-Policy: unsafe-url</code></pre><span class="yozora-text">:
无论是同源请求还是非同源请求，都发送完整的 URL（移除参数信息之后）作为引用地址。</span></p><div class="yozora-admonition yozora-admonition--warning"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" /></svg></span><span class="yozora-admonition__heading-title">CAUTION</span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">这项设置会将受 TLS 安全协议保护的资源的源和路径信息泄露给非安全的源服务器。进行此项设置的时候要慎重考虑。</span></p></div></div></li></ul></div></div></li></ul><h3 class="yozora-heading"><span class="yozora-text">CSRF Token</span></h3><p class="yozora-paragraph"><span class="yozora-text">前文中提到 CSRF 攻击是利用了浏览器在发送请求时默认携带对应站点的 Cookie 的机制完成的，如果服务器要求所有的请求都需要携带一个 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text">，且该 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text"> 不存在服务器上，则校验此 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text"> 就可以完全防御 CSRF 攻击了。</span></p><p class="yozora-paragraph"><span class="yozora-text">使用此方法需要在所有的请求中携带一个固定的 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text">，可以将其写入在 </span><pre class="yozora-inline-code"><code>html</code></pre><span class="yozora-text"> 的某个 </span><pre class="yozora-inline-code"><code>meta</code></pre><span class="yozora-text"> 元素中，然后在发起请求时通过 js 查询此 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text">；或者在服务端渲染页面时将此 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text"> 注入到链接（站点链接，非用户填入的链接）和表单中。此外，还可以将
</span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text"> 写入 HTTP Header 中，如使用 </span><a class="yozora-link" href="https://github.com/axios/axios" title="https://github.com/axios/axios" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">axios</span></a><span class="yozora-text"> 请求库时，可以设置默认的 HTTP Headers。</span></p><div class="yozora-admonition yozora-admonition--success"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z" /></svg></span><span class="yozora-admonition__heading-title"><a class="yozora-link" href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" title="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">jwt</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">由于此 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text"> 是为了防止 CSRF 攻击存在的，仅用来校验请求是否从可信源中发出，而无需在服务器端废止它（仅设置一个过期时间让它自然失效即可），故可以使用 </span><pre class="yozora-inline-code"><code>jwt</code></pre><span class="yozora-text"> 来实现，将用户名写进 </span><pre class="yozora-inline-code"><code>jwt</code></pre><span class="yozora-text"> 中即可防止攻击者伪造 </span><pre class="yozora-inline-code"><code>token</code></pre><span class="yozora-text">。这样服务器端就无需存储额外的信息了，仅需通过算法进行校验就可以完成验证了。</span></p></div></div><h3 class="yozora-heading"><span class="yozora-text">其它防御策略</span></h3><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">双重 Cookie: 在 Cookie 中写入一个随机数（作为 CSRF Token），之后所有的请求中手动在请求参数中携带此随机数，服务器端通过检查 Cookie 中的随机数和请求中的随机数是否一致进行检验。</span></p><p class="yozora-paragraph"><span class="yozora-text">此方法和 CSRF Token 差不多，换汤不换药</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">Samesite Cookie: 服务器在 http 请求头上写入 </span><pre class="yozora-inline-code"><code>Set-Cookie: xxxxx; Samesite=Strict</code></pre><span class="yozora-text">
表示此 Cookie 仅限同站下使用，从根源上杜绝了 CSRF 攻击。</span></p></li></ul><h2 class="yozora-heading"><span class="yozora-text">Related</span></h2><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://tech.meituan.com/2018/09/27/fe-security.html" title="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（一）：如何防止XSS攻击？</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" title="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">前端安全系列（二）：如何防止CSRF攻击？</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" title="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">JSON Web Token 入门教程</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Referrer-Policy | MDN</span></a></li></ul><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">为不和层叠样式表（Cascading Styles Sheets, CSS）的缩写混淆，故将跨站脚本攻击缩写写为 XSS。可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC</span></a></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">有趣的是，</span><pre class="yozora-inline-code"><code>Referer</code></pre><span class="yozora-text"> 实际上是 </span><pre class="yozora-inline-code"><code>Referrer</code></pre><span class="yozora-text"> 的错误拼写，难以想象这样低级的错误在制定规范的过程发生并保留了下来，可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" title="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80</span></a></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">为不和层叠样式表（Cascading Styles Sheets, CSS）的缩写混淆，故将跨站脚本攻击缩写写为 XSS。可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" title="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC</span></a></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">有趣的是，</span><pre class="yozora-inline-code"><code>Referer</code></pre><span class="yozora-text"> 实际上是 </span><pre class="yozora-inline-code"><code>Referrer</code></pre><span class="yozora-text"> 的错误拼写，难以想象这样低级的错误在制定规范的过程发生并保留了下来，可参见
</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" title="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80</span></a></p></div></div></ul></div></footer></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[自然对数底数e]]></title>
            <link>https://me.guanghechen.com/post/math/calculus/自然对数底数e</link>
            <guid>https://me.guanghechen.com/post/math/calculus/自然对数底数e</guid>
            <pubDate>Fri, 06 Aug 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-inline-math">e</span><span class="yozora-text"> 是一个很神奇的常数，长期以来我只知道它是一个很重要的对数底数。以它为底的对数被称为自然对数，它有一个很重要的性质：对数函数 </span><span class="yozora-inline-math">\log_a(x)</span><span class="yozora-text"> 的导数为
</span><span class="yozora-inline-math">\displaystyle \frac{1}{x\ln a}</span><span class="yozora-text">，幂函数 </span><span class="yozora-inline-math">y=a^x</span><span class="yozora-text"> 的导数为 </span><span class="yozora-inline-math">a^x\ln a</span><span class="yozora-text">。</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text">
也就是说所有对数函数和幂函数的导数都与 </span></p><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{96}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">对于函数 </span><span class="yozora-inline-math">y = \log_a x \, (a &gt; 0, a \neq 1)</span><span class="yozora-text">，增量
</span><span class="yozora-inline-math">\Delta y=\log_a(x + \Delta x) - \log_a x</span><span class="yozora-text">，则有：</span></p><div class="yozora-math">\frac{\Delta y}{\Delta x}
= \frac{1}{\Delta x} \log_a \left( 1 + \frac{\Delta x}{x} \right)
= \frac{1}{x} \log_a \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}}.
</div><p class="yozora-paragraph"><span class="yozora-text">取极限，有</span><sup id="reference-footnote-5" class="yozora-footnote-reference"><a href="#footnote-5" title="5">[5]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}
  &amp;= \frac{1}{x} \log_a \left[ \lim_{\Delta x \rightarrow 0} \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}} \right] \\
  &amp;= \frac{1}{x} \log_a e = \frac{1}{x \ln a}.
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即：</span></p><div class="yozora-math">(\log_a x)' = \frac{1}{x\ln a}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{38}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">a &gt; b &gt; 0</span><span class="yozora-text"> 时，有</span></p><div class="yozora-math">\begin{aligned}
 a^{n+1} - b^{n+1} &amp;= (a - b) \cdot \left(\sum_{k=0}^{n} a^k \cdot b^{n-k} \right)\\
                   &amp;&lt; (n + 1) \cdot (a - b) \cdot a^n\\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即</span></p><div class="yozora-math">a^n [(n+1)b - na] &lt; b^{n+1} \label{eq-1}\tag{1}
</div><p class="yozora-paragraph"><span class="yozora-text">取 </span><span class="yozora-inline-math">\displaystyle a=1 + \frac{1}{2n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">b=1</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^n &lt; 2
</div><p class="yozora-paragraph"><span class="yozora-text">从而</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">再取 </span><span class="yozora-inline-math">\displaystyle a = 1 + \frac{1}{n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">\displaystyle b = 1 + \frac{1}{n+1}</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{n+1} \right)^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">从而数列 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 是严格单调递增的，故有</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 有上界，又由于它是单调递增的，故它是一个收敛的数列。通常我们将这个数列的极限值记为 </span><span class="yozora-inline-math">e</span><span class="yozora-text">.</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{134}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">麦克劳林（Maclaurin）公式如下（其中，</span><span class="yozora-inline-math">\xi</span><span class="yozora-text"> 在 </span><span class="yozora-inline-math">0</span><span class="yozora-text"> 和 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 之间）：</span></p><div class="yozora-math">  f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!} + \cdots + 
         \frac{f^{(n)}(0)}{n!}x + \frac{f^{(n+1)}(\xi)}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">求 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 的麦克劳林级数时应用到了 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的一个重要性质： </span><span class="yozora-inline-math">(e^x)' = e^x</span></p><p class="yozora-paragraph"><span class="yozora-text">由于 </span><span class="yozora-inline-math">f'(x) = (e^x)' = e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(x)=e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n + 1)}(x)=e^x</span><span class="yozora-text">， </span><br class="yozora-break" /><span class="yozora-text">
得 </span><span class="yozora-inline-math">f(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f'(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n+1)}(\xi)=e^x</span><span class="yozora-text">. 故有：</span></p><div class="yozora-math">e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \frac{e^\xi}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">x \rightarrow 0</span><span class="yozora-text"> 时，有：</span></p><div class="yozora-math">\lim_{x \rightarrow 0} e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^2}{n!}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">欧拉公式 | 维基百科</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">首先，在复数域上对 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 进行定义：</span></p><blockquote class="yozora-blockquote"><p class="yozora-paragraph"><span class="yozora-text">对于 </span><span class="yozora-inline-math">a,b \in \mathbb{R}, c=a+ib \in \mathbb{C}</span><span class="yozora-text">，规定
</span><span class="yozora-inline-math">\displaystyle e^{\mathbb C}=\lim_{n \rightarrow \infty} \left(1 + \frac{c}{n} \right)^n</span><span class="yozora-text">.</span></p></blockquote><p class="yozora-paragraph"><span class="yozora-text">对</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">复数的极坐标表示</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w= \mu + i\nu = r(\cos\theta + i\sin\theta)</span><span class="yozora-text">，从而有：</span></p><div class="yozora-math">r = \sqrt{\mu^2 + \nu^2} \in \mathbb{R}, \; \theta=\arctan \left( \frac{\nu}{\mu} \right) \in \mathbb{R}
</div><p class="yozora-paragraph"><span class="yozora-text">根据</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">棣莫弗公式</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w^n=(\mu + i\nu)^n = r^n(\cos{n\theta} + i\sin{n\theta})</span><span class="yozora-text">，有：</span></p><div class="yozora-math">\left( 1 + \frac{a + bi}{n} \right)^n 
= \left[ \left( 1 + \frac{a}{n} \right) + i \cdot \frac{b}{n} \right]^n 
= r_n(\cos\theta_n + i\sin\theta_n)
</div><p class="yozora-paragraph"><span class="yozora-text">假设 </span><span class="yozora-inline-math">n &gt; \lvert a \rvert</span><span class="yozora-text">，则：</span></p><div class="yozora-math">r_n = \left[ \left( 1 + \frac{a}{n} \right)^2 + \left( \frac{b}{n} \right)^2 \right]^{\frac{n}{2}}, \quad 
\theta_n=n \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有</span><sup id="reference-footnote-6" class="yozora-footnote-reference"><a href="#footnote-6" title="6">[6]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln r_n 
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \ln \left( 1 + \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \left( \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= a \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">又因为：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln \theta_n
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= b \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \left( 1 + \frac{a+bi}{n} \right)^n
    &amp;= \lim_{n \rightarrow \infty} r_n(\cos\theta_n + i\sin\theta_n) \\
    &amp;= \lim_{n \rightarrow \infty} r_n \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \left( \lim_{n \rightarrow \infty} \cos\theta_n + \lim_{n \rightarrow \infty} i\sin\theta_n \right) \\
    &amp;= e^a \cdot (\cos b + i\sin b)
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">e^{a+ib} = e^a(\cos b + i\sin b)</span><span class="yozora-text">，令 </span><span class="yozora-inline-math">a=0</span><span class="yozora-text">，则有</span></p><div class="yozora-math">e^{ix} = \cos x + i\sin x
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了无穷小量 </span><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \left( 1+\frac{1}{x} \right)^x = e</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-6">&uarr;</a><span>&nbsp;[6]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了墨卡托级数： </span><span class="yozora-inline-math">\ln (1+x) \sim x</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{96}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">对于函数 </span><span class="yozora-inline-math">y = \log_a x \, (a &gt; 0, a \neq 1)</span><span class="yozora-text">，增量
</span><span class="yozora-inline-math">\Delta y=\log_a(x + \Delta x) - \log_a x</span><span class="yozora-text">，则有：</span></p><div class="yozora-math">\frac{\Delta y}{\Delta x}
= \frac{1}{\Delta x} \log_a \left( 1 + \frac{\Delta x}{x} \right)
= \frac{1}{x} \log_a \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}}.
</div><p class="yozora-paragraph"><span class="yozora-text">取极限，有</span><sup id="reference-footnote-5" class="yozora-footnote-reference"><a href="#footnote-5" title="5">[5]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}
  &amp;= \frac{1}{x} \log_a \left[ \lim_{\Delta x \rightarrow 0} \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}} \right] \\
  &amp;= \frac{1}{x} \log_a e = \frac{1}{x \ln a}.
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即：</span></p><div class="yozora-math">(\log_a x)' = \frac{1}{x\ln a}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{38}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">a &gt; b &gt; 0</span><span class="yozora-text"> 时，有</span></p><div class="yozora-math">\begin{aligned}
 a^{n+1} - b^{n+1} &amp;= (a - b) \cdot \left(\sum_{k=0}^{n} a^k \cdot b^{n-k} \right)\\
                   &amp;&lt; (n + 1) \cdot (a - b) \cdot a^n\\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即</span></p><div class="yozora-math">a^n [(n+1)b - na] &lt; b^{n+1} \label{eq-1}\tag{1}
</div><p class="yozora-paragraph"><span class="yozora-text">取 </span><span class="yozora-inline-math">\displaystyle a=1 + \frac{1}{2n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">b=1</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^n &lt; 2
</div><p class="yozora-paragraph"><span class="yozora-text">从而</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">再取 </span><span class="yozora-inline-math">\displaystyle a = 1 + \frac{1}{n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">\displaystyle b = 1 + \frac{1}{n+1}</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{n+1} \right)^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">从而数列 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 是严格单调递增的，故有</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 有上界，又由于它是单调递增的，故它是一个收敛的数列。通常我们将这个数列的极限值记为 </span><span class="yozora-inline-math">e</span><span class="yozora-text">.</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{134}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">麦克劳林（Maclaurin）公式如下（其中，</span><span class="yozora-inline-math">\xi</span><span class="yozora-text"> 在 </span><span class="yozora-inline-math">0</span><span class="yozora-text"> 和 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 之间）：</span></p><div class="yozora-math">  f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!} + \cdots + 
         \frac{f^{(n)}(0)}{n!}x + \frac{f^{(n+1)}(\xi)}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">求 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 的麦克劳林级数时应用到了 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的一个重要性质： </span><span class="yozora-inline-math">(e^x)' = e^x</span></p><p class="yozora-paragraph"><span class="yozora-text">由于 </span><span class="yozora-inline-math">f'(x) = (e^x)' = e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(x)=e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n + 1)}(x)=e^x</span><span class="yozora-text">， </span><br class="yozora-break" /><span class="yozora-text">
得 </span><span class="yozora-inline-math">f(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f'(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n+1)}(\xi)=e^x</span><span class="yozora-text">. 故有：</span></p><div class="yozora-math">e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \frac{e^\xi}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">x \rightarrow 0</span><span class="yozora-text"> 时，有：</span></p><div class="yozora-math">\lim_{x \rightarrow 0} e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^2}{n!}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">欧拉公式 | 维基百科</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">首先，在复数域上对 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 进行定义：</span></p><blockquote class="yozora-blockquote"><p class="yozora-paragraph"><span class="yozora-text">对于 </span><span class="yozora-inline-math">a,b \in \mathbb{R}, c=a+ib \in \mathbb{C}</span><span class="yozora-text">，规定
</span><span class="yozora-inline-math">\displaystyle e^{\mathbb C}=\lim_{n \rightarrow \infty} \left(1 + \frac{c}{n} \right)^n</span><span class="yozora-text">.</span></p></blockquote><p class="yozora-paragraph"><span class="yozora-text">对</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">复数的极坐标表示</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w= \mu + i\nu = r(\cos\theta + i\sin\theta)</span><span class="yozora-text">，从而有：</span></p><div class="yozora-math">r = \sqrt{\mu^2 + \nu^2} \in \mathbb{R}, \; \theta=\arctan \left( \frac{\nu}{\mu} \right) \in \mathbb{R}
</div><p class="yozora-paragraph"><span class="yozora-text">根据</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">棣莫弗公式</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w^n=(\mu + i\nu)^n = r^n(\cos{n\theta} + i\sin{n\theta})</span><span class="yozora-text">，有：</span></p><div class="yozora-math">\left( 1 + \frac{a + bi}{n} \right)^n 
= \left[ \left( 1 + \frac{a}{n} \right) + i \cdot \frac{b}{n} \right]^n 
= r_n(\cos\theta_n + i\sin\theta_n)
</div><p class="yozora-paragraph"><span class="yozora-text">假设 </span><span class="yozora-inline-math">n &gt; \lvert a \rvert</span><span class="yozora-text">，则：</span></p><div class="yozora-math">r_n = \left[ \left( 1 + \frac{a}{n} \right)^2 + \left( \frac{b}{n} \right)^2 \right]^{\frac{n}{2}}, \quad 
\theta_n=n \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有</span><sup id="reference-footnote-6" class="yozora-footnote-reference"><a href="#footnote-6" title="6">[6]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln r_n 
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \ln \left( 1 + \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \left( \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= a \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">又因为：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln \theta_n
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= b \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \left( 1 + \frac{a+bi}{n} \right)^n
    &amp;= \lim_{n \rightarrow \infty} r_n(\cos\theta_n + i\sin\theta_n) \\
    &amp;= \lim_{n \rightarrow \infty} r_n \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \left( \lim_{n \rightarrow \infty} \cos\theta_n + \lim_{n \rightarrow \infty} i\sin\theta_n \right) \\
    &amp;= e^a \cdot (\cos b + i\sin b)
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">e^{a+ib} = e^a(\cos b + i\sin b)</span><span class="yozora-text">，令 </span><span class="yozora-inline-math">a=0</span><span class="yozora-text">，则有</span></p><div class="yozora-math">e^{ix} = \cos x + i\sin x
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了无穷小量 </span><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \left( 1+\frac{1}{x} \right)^x = e</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-6">&uarr;</a><span>&nbsp;[6]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了墨卡托级数： </span><span class="yozora-inline-math">\ln (1+x) \sim x</span></p></div></div></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-inline-math">e</span><span class="yozora-text"> 是一个很神奇的常数，长期以来我只知道它是一个很重要的对数底数。以它为底的对数被称为自然对数，它有一个很重要的性质：对数函数 </span><span class="yozora-inline-math">\log_a(x)</span><span class="yozora-text"> 的导数为
</span><span class="yozora-inline-math">\displaystyle \frac{1}{x\ln a}</span><span class="yozora-text">，幂函数 </span><span class="yozora-inline-math">y=a^x</span><span class="yozora-text"> 的导数为 </span><span class="yozora-inline-math">a^x\ln a</span><span class="yozora-text">。</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text">
也就是说所有对数函数和幂函数的导数都与 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 有关。</span></p><p class="yozora-paragraph"><span class="yozora-text">为了理解它为什么被称为自然对数，翻阅了一些网上的资料，发现不少都拿银行的复利来举例；此外 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 还与对数螺旋线有关。如果你只是对 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 为什么被称为自然对数感兴趣，推荐直接阅读下面两篇文章，本文更多的是记录一些和 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 相关的数学式子和证明：</span></p><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://zhuanlan.zhihu.com/p/48391829" title="https://zhuanlan.zhihu.com/p/48391829" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">飞蛾真的是因为趋光，所以扑火？ | 知乎专栏</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zhuanlan.zhihu.com/p/48391055" title="https://zhuanlan.zhihu.com/p/48391055" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">自然底数e怎么就“自然”了？ | 知乎专栏</span></a></li></ul><h2 class="yozora-heading"><span class="yozora-inline-math">e</span><span class="yozora-text"> 的由来</span></h2><p class="yozora-paragraph"><span class="yozora-inline-math">e</span><span class="yozora-text"> 有两种表示法：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">\displaystyle e = \lim_{x \rightarrow +\infty} \left(1 + \frac{1}{n} \right)^n</span><span class="yozora-text">.</span></p><p class="yozora-paragraph"><span class="yozora-text">这种表示方式正是 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的定义</span><sup id="reference-2" class="yozora-footnote-reference"><a href="#2" title="2">[2]</a></sup></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">\displaystyle e = \sum_{i=0}^{+\infty} \frac{1}{i!} = 1 + \frac{1}{1!} + \frac{1}{2!} + \cdots</span><span class="yozora-text">.</span></p><p class="yozora-paragraph"><span class="yozora-text">这是 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 的麦克劳林级数在 </span><span class="yozora-inline-math">x=1</span><span class="yozora-text"> 时的值。</span><sup id="reference-3" class="yozora-footnote-reference"><a href="#3" title="3">[3]</a></sup></p></li></ul><hr class="yozora-thematic-break" /><p class="yozora-paragraph"><span class="yozora-inline-math">e</span><span class="yozora-text"> 的第一种表示方法与复利率模型有关。在介绍复利率之前，我们先看一下指数增长模型。</span></p><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">指数增长模型</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">假设某种细菌每天分裂一次，那么 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 天后，一个细菌将会繁殖总数为（假设这些天里没有细菌死亡）</span><span class="yozora-inline-math">2^x</span><span class="yozora-text"> 的菌落。这是一个经典的指数增长模型，无论初始时有多少细菌，在 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 天后的总数量是初始时的 </span><span class="yozora-inline-math">2^x</span><span class="yozora-text"> 倍，它的数学表达为：</span></p><div class="yozora-math">Q = 2^x = (1 + 1)^x = (1 + 100\%)^x
</div><p class="yozora-paragraph"><span class="yozora-text">上式中隐含的是增长率为 </span><span class="yozora-inline-math">100\%</span><span class="yozora-text"> 时，</span><span class="yozora-inline-math">x</span><span class="yozora-text"> 天后的总数量是初始时的 </span><span class="yozora-inline-math">Q</span><span class="yozora-text"> 倍。更宽泛地，记增长率为 </span><span class="yozora-inline-math">r</span><span class="yozora-text">，则有：</span></p><div class="yozora-math">Q = (1 + r)^x
</div><p class="yozora-paragraph"><span class="yozora-text">表示在一个增长周期内的增长率为 </span><span class="yozora-inline-math">r</span><span class="yozora-text"> （增加了 </span><span class="yozora-inline-math">r</span><span class="yozora-text"> 倍），则在增长了 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 个周期后，总数量将为初始时的 </span><span class="yozora-inline-math">Q</span><span class="yozora-text"> 倍。</span></p></div></div><p class="yozora-paragraph"><span class="yozora-text">复利率法是一种计算利息的方法，按照指的是某段时间后利息也能产生利息。它和上文提到的细菌分裂有些类似，只不过复利率可以是小数：</span></p><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">复利率模型</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">现在在一家年利率为 </span><span class="yozora-inline-math">100\%</span><span class="yozora-text"> 的银行存入了一元钱，银行每季度支付一次利息，这样一年可取四次利息，总计能获得一元的利息，手上的钱变成了两元。聪明的你在每次获得利息后转手又存入银行，则一年后手上的钱变为：</span></p><div class="yozora-math">Q = \left( 1 + \frac{100\%}{4} \right)^4 = 2.4414
</div><p class="yozora-paragraph"><span class="yozora-text">虽然年利率没有改变，但因为结算的周期变短了，使得最后拿到手的钱变多了。贪心的你开始思考如果银行交付的周期变成无限小，那拿到手的钱会不会变成无穷多呢？不妨记银行一年支付利息 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 次，则每次的利率为 </span><span class="yozora-inline-math">\displaystyle \frac{100\%}{x}</span><span class="yozora-text">，当 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 趋于无穷时，结合 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的第一种表示法可知，一年后到手的钱为：</span></p><div class="yozora-math">Q = \lim_{x \rightarrow +\infty} \left( 1 + \frac{100\%}{x} \right)^x = e
</div></div></div><h2 class="yozora-heading"><span class="yozora-inline-math">e</span><span class="yozora-text"> 是一个无理数</span></h2><p class="yozora-paragraph"><span class="yozora-text">可以用反证法来证明。若 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 是一个有理数，不妨记它为 </span><span class="yozora-inline-math">\displaystyle e = \frac{a}{b}</span><span class="yozora-text">，其中 </span><span class="yozora-inline-math">a</span><span class="yozora-text"> 和 </span><span class="yozora-inline-math">b</span><span class="yozora-text"> 都是正整数。我们可以取一个正整数 </span><span class="yozora-inline-math">n</span><span class="yozora-text">，并在等式两次同乘以 </span><span class="yozora-inline-math">b \cdot n!</span><span class="yozora-text">：</span></p><div class="yozora-math">e \cdot b \cdot n!= \frac{a}{b} \cdot b \cdot n! = a \cdot n!
</div><p class="yozora-paragraph"><span class="yozora-text">显然，等式右侧是一个正整数。现在观察等式的左侧，根据前文 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的第二个表式法</span></p><div class="yozora-math">e = \sum_{i=0}^{+\infty} \frac{1}{i!} = 1 + \frac{1}{1!} + \frac{1}{2!} + \cdots
</div><p class="yozora-paragraph"><span class="yozora-text">有：</span></p><div class="yozora-math">\begin{aligned}
  b \cdot n! \cdot e 
    &amp;= b \cdot n! \cdot \left( \sum_{i=0}^{+\infty} \frac{1}{i!} \right) \\
    &amp;= b \cdot n! \cdot \left(1 + \frac{1}{1!} + \cdots + \frac{1}{n!} \right) \\
    &amp;\quad + b \cdot \left(\frac{1}{n+1} + \frac{1}{(n+1) \cdot (n+2)} + \cdots \right) \\
\end{aligned} \label{eq-2} \tag{2}
</div><p class="yozora-paragraph"><span class="yozora-text">等式右侧的第一项显然是个整数，现在继续观察第二项，令</span></p><div class="yozora-math">\begin{aligned}
  0 &lt; \epsilon &amp;= b \cdot \left( \frac{1}{n+1} + \frac{1}{(n+1) \cdot (n+2)} + \frac{1}{(n+1) \cdot (n+2) \cdot (n+3)} + \cdots \right) \\
        &amp;&lt; b \cdot \left( \frac{1}{n+1} + \frac{1}{(n+1)^2} + \frac{1}{(n+1)^3} + \cdots \right) \\
        &amp;= b \cdot \left( \frac{1}{n+1} \cdot \frac{1 - \left(\frac{1}{n+1}\right)^{+\infty}}{1 - \frac{1}{n+1}} \right) \\
        &amp;= b \cdot \left( \frac{1}{n+1} \cdot \frac{1}{1 - \frac{1}{n+1}} \right)
         = b \cdot \frac{1}{n} \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">则当 </span><span class="yozora-inline-math">n</span><span class="yozora-text"> 取一个大于 </span><span class="yozora-inline-math">b</span><span class="yozora-text"> 的整数时，有： </span><span class="yozora-inline-math">0 &lt; \epsilon &lt; 1</span><span class="yozora-text">，即第二项不为整数，即式 </span><span class="yozora-inline-math">\eqref{eq-2}</span><span class="yozora-text"> 不成立，故原假设矛盾，</span><span class="yozora-inline-math">e</span><span class="yozora-text"> 不可能为有理数，所以 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 是一个无理数。</span></p><h2 class="yozora-heading"><span class="yozora-text">欧拉方程</span></h2><p class="yozora-paragraph"><span class="yozora-text">谈到自然对数 </span><span class="yozora-inline-math">e</span><span class="yozora-text">，就不得不提起大名鼎鼎的欧拉方程</span><sup id="reference-4" class="yozora-footnote-reference"><a href="#4" title="4">[4]</a></sup><span class="yozora-text">了：</span></p><div class="yozora-math">e^{ix} = \cos x + \sin x
</div><p class="yozora-paragraph"><span class="yozora-text">特别地，当取 </span><span class="yozora-inline-math">x=\pi</span><span class="yozora-text"> 时，有：</span></p><div class="yozora-math">e^{i\pi} + 1= 0
</div><p class="yozora-paragraph"><span class="yozora-text">初次见到它还是在大一时的一门选修课上，由于它实在是太优美了，以至于自初见起便一直念念不忘。它包含了数学上最奇妙的几个常数：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">e</span><span class="yozora-text">: 自然对数的底数</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">i</span><span class="yozora-text">: 复数的单位，凭借一己之力表达了整个复数域（以实数作为系数）</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">\pi</span><span class="yozora-text">: 圆周率（</span><span class="yozora-inline-math">\pi</span><span class="yozora-text"> 是我学到的第一个无理数）</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">0</span><span class="yozora-text">: 零是数学上极为重要的数字，它拥有许多性质：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 是唯一可以作为无穷小量的常数</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 是唯一既非正也非负的实数，</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 的相反数和绝对值都是其本身</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 是唯一找不到复数 </span><span class="yozora-inline-math">w</span><span class="yozora-text"> 使得 </span><span class="yozora-inline-math">e^w = z</span><span class="yozora-text"> 的复数 </span><span class="yozora-inline-math">z</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 在概率上代表不可能事件</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 是多个重要数列的项，如</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E4%BD%A9%E5%B0%94%E6%95%B0" title="https://zh.wikipedia.org/wiki/%E4%BD%A9%E5%B0%94%E6%95%B0" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">佩尔数</span></a><span class="yozora-text">、 </span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" title="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">斐波那契数</span></a><span class="yozora-text">、</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B8" title="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B8" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">高斯整数</span></a><span class="yozora-text">等</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 是加减法运算的零元：任何数字和零做加减法运算都得到它本身</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 乘任何数都得到 </span><span class="yozora-inline-math">0</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 是任何数的倍数，</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 除任何数都得到 </span><span class="yozora-inline-math">0</span></li><li class="yozora-list-item"><span class="yozora-inline-math">0</span><span class="yozora-text"> 不能作为除数，也不能作为对数的底，它没有倒数</span></li><li class="yozora-list-item"><span class="yozora-text">...</span></li></ul></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">1</span><span class="yozora-text">: 一也是一个重要的数字，它同样拥有很多性质：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-inline-math">1</span><span class="yozora-text"> 是第一个</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%B9%B8%E8%BF%90%E6%95%B0" title="https://zh.wikipedia.org/wiki/%E5%B9%B8%E8%BF%90%E6%95%B0" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">幸运数</span></a></li><li class="yozora-list-item"><span class="yozora-inline-math">1</span><span class="yozora-text"> 是第一个</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E6%A8%82%E6%95%B8" title="https://zh.wikipedia.org/wiki/%E5%BF%AB%E6%A8%82%E6%95%B8" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">快乐数</span></a></li><li class="yozora-list-item"><span class="yozora-inline-math">1</span><span class="yozora-text"> 在概率上代表必然事件</span></li><li class="yozora-list-item"><span class="yozora-inline-math">1</span><span class="yozora-text"> 是乘除法运算的零元：任何数字和一做乘除法运算都得到它本身</span></li><li class="yozora-list-item"><span class="yozora-inline-math">1</span><span class="yozora-text"> 是唯一不能作为对数的底的正数</span></li><li class="yozora-list-item"><span class="yozora-text">...</span></li></ul></li></ul><h2 class="yozora-heading"><span class="yozora-text">几个重要的极限和无穷量</span></h2><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \left( 1+\frac{1}{x} \right)^x = e</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \ln(1+x) = \lim_{x \rightarrow 0} x</span><span class="yozora-text"> （墨卡托级数）</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \left( a^x - 1 \right) = \lim_{x \rightarrow 0} x\ln a</span></p><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{70}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">令 </span><span class="yozora-inline-math">y=a^x - 1</span><span class="yozora-text">，则 </span><span class="yozora-inline-math">x \rightarrow 0</span><span class="yozora-text"> 时，</span><span class="yozora-inline-math">y \rightarrow 0</span><span class="yozora-text">，且
</span><span class="yozora-inline-math">\displaystyle x = \log_a (1+y) = \frac{\ln (1 + y)}{\ln a}</span><span class="yozora-text">，故：</span></p><div class="yozora-math">\lim_{x \rightarrow 0} \frac{a^x - 1}{x\ln a}
  = \lim_{y \rightarrow 0} \frac{y}{\ln (1 + y)}
  = \lim_{y \rightarrow 0} \frac{1}{\ln (1 + y)^{\frac{1}{y}}}
  = \frac{1}{\ln e}
  = 1
</div><p class="yozora-paragraph"><span class="yozora-text">即</span></p><div class="yozora-math">\lim_{x \rightarrow 0} \left( a^x - 1 \right) = \lim_{x \rightarrow 0} x\ln a
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></li></ul><h2 class="yozora-heading"><span class="yozora-text">Related</span></h2><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="https://zhuanlan.zhihu.com/p/48391829" title="https://zhuanlan.zhihu.com/p/48391829" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">飞蛾真的是因为趋光，所以扑火？ | 知乎专栏</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zhuanlan.zhihu.com/p/48391055" title="https://zhuanlan.zhihu.com/p/48391055" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">自然底数e怎么就“自然”了？ | 知乎专栏</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E5%B0%8D%E6%95%B8" title="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E5%B0%8D%E6%95%B8" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">自然对数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0" title="https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">泰勒级数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/0" title="https://zh.wikipedia.org/wiki/0" target="_blank" rel="noopener,noreferrer"><span class="yozora-inline-math">0</span><span class="yozora-text"> | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/1" title="https://zh.wikipedia.org/wiki/1" target="_blank" rel="noopener,noreferrer"><span class="yozora-inline-math">1</span><span class="yozora-text"> | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E4%BD%A9%E5%B0%94%E6%95%B0" title="https://zh.wikipedia.org/wiki/%E4%BD%A9%E5%B0%94%E6%95%B0" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">佩尔数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" title="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">斐波那契数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B8" title="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B8" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">高斯整数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%B9%B8%E8%BF%90%E6%95%B0" title="https://zh.wikipedia.org/wiki/%E5%B9%B8%E8%BF%90%E6%95%B0" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">幸运数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E6%A8%82%E6%95%B8" title="https://zh.wikipedia.org/wiki/%E5%BF%AB%E6%A8%82%E6%95%B8" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">快乐数 | 维基百科</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">欧拉公式 | 维基百科</span></a></li><li class="yozora-list-item"><span class="yozora-text">湖南大学《大学数学1》第三版</span></li></ul><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{96}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">对于函数 </span><span class="yozora-inline-math">y = \log_a x \, (a &gt; 0, a \neq 1)</span><span class="yozora-text">，增量
</span><span class="yozora-inline-math">\Delta y=\log_a(x + \Delta x) - \log_a x</span><span class="yozora-text">，则有：</span></p><div class="yozora-math">\frac{\Delta y}{\Delta x}
= \frac{1}{\Delta x} \log_a \left( 1 + \frac{\Delta x}{x} \right)
= \frac{1}{x} \log_a \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}}.
</div><p class="yozora-paragraph"><span class="yozora-text">取极限，有</span><sup id="reference-footnote-5" class="yozora-footnote-reference"><a href="#footnote-5" title="5">[5]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}
  &amp;= \frac{1}{x} \log_a \left[ \lim_{\Delta x \rightarrow 0} \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}} \right] \\
  &amp;= \frac{1}{x} \log_a e = \frac{1}{x \ln a}.
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即：</span></p><div class="yozora-math">(\log_a x)' = \frac{1}{x\ln a}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{38}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">a &gt; b &gt; 0</span><span class="yozora-text"> 时，有</span></p><div class="yozora-math">\begin{aligned}
 a^{n+1} - b^{n+1} &amp;= (a - b) \cdot \left(\sum_{k=0}^{n} a^k \cdot b^{n-k} \right)\\
                   &amp;&lt; (n + 1) \cdot (a - b) \cdot a^n\\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即</span></p><div class="yozora-math">a^n [(n+1)b - na] &lt; b^{n+1} \label{eq-1}\tag{1}
</div><p class="yozora-paragraph"><span class="yozora-text">取 </span><span class="yozora-inline-math">\displaystyle a=1 + \frac{1}{2n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">b=1</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^n &lt; 2
</div><p class="yozora-paragraph"><span class="yozora-text">从而</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">再取 </span><span class="yozora-inline-math">\displaystyle a = 1 + \frac{1}{n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">\displaystyle b = 1 + \frac{1}{n+1}</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{n+1} \right)^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">从而数列 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 是严格单调递增的，故有</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 有上界，又由于它是单调递增的，故它是一个收敛的数列。通常我们将这个数列的极限值记为 </span><span class="yozora-inline-math">e</span><span class="yozora-text">.</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{134}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">麦克劳林（Maclaurin）公式如下（其中，</span><span class="yozora-inline-math">\xi</span><span class="yozora-text"> 在 </span><span class="yozora-inline-math">0</span><span class="yozora-text"> 和 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 之间）：</span></p><div class="yozora-math">  f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!} + \cdots + 
         \frac{f^{(n)}(0)}{n!}x + \frac{f^{(n+1)}(\xi)}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">求 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 的麦克劳林级数时应用到了 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的一个重要性质： </span><span class="yozora-inline-math">(e^x)' = e^x</span></p><p class="yozora-paragraph"><span class="yozora-text">由于 </span><span class="yozora-inline-math">f'(x) = (e^x)' = e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(x)=e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n + 1)}(x)=e^x</span><span class="yozora-text">， </span><br class="yozora-break" /><span class="yozora-text">
得 </span><span class="yozora-inline-math">f(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f'(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n+1)}(\xi)=e^x</span><span class="yozora-text">. 故有：</span></p><div class="yozora-math">e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \frac{e^\xi}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">x \rightarrow 0</span><span class="yozora-text"> 时，有：</span></p><div class="yozora-math">\lim_{x \rightarrow 0} e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^2}{n!}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">欧拉公式 | 维基百科</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">首先，在复数域上对 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 进行定义：</span></p><blockquote class="yozora-blockquote"><p class="yozora-paragraph"><span class="yozora-text">对于 </span><span class="yozora-inline-math">a,b \in \mathbb{R}, c=a+ib \in \mathbb{C}</span><span class="yozora-text">，规定
</span><span class="yozora-inline-math">\displaystyle e^{\mathbb C}=\lim_{n \rightarrow \infty} \left(1 + \frac{c}{n} \right)^n</span><span class="yozora-text">.</span></p></blockquote><p class="yozora-paragraph"><span class="yozora-text">对</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">复数的极坐标表示</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w= \mu + i\nu = r(\cos\theta + i\sin\theta)</span><span class="yozora-text">，从而有：</span></p><div class="yozora-math">r = \sqrt{\mu^2 + \nu^2} \in \mathbb{R}, \; \theta=\arctan \left( \frac{\nu}{\mu} \right) \in \mathbb{R}
</div><p class="yozora-paragraph"><span class="yozora-text">根据</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">棣莫弗公式</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w^n=(\mu + i\nu)^n = r^n(\cos{n\theta} + i\sin{n\theta})</span><span class="yozora-text">，有：</span></p><div class="yozora-math">\left( 1 + \frac{a + bi}{n} \right)^n 
= \left[ \left( 1 + \frac{a}{n} \right) + i \cdot \frac{b}{n} \right]^n 
= r_n(\cos\theta_n + i\sin\theta_n)
</div><p class="yozora-paragraph"><span class="yozora-text">假设 </span><span class="yozora-inline-math">n &gt; \lvert a \rvert</span><span class="yozora-text">，则：</span></p><div class="yozora-math">r_n = \left[ \left( 1 + \frac{a}{n} \right)^2 + \left( \frac{b}{n} \right)^2 \right]^{\frac{n}{2}}, \quad 
\theta_n=n \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有</span><sup id="reference-footnote-6" class="yozora-footnote-reference"><a href="#footnote-6" title="6">[6]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln r_n 
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \ln \left( 1 + \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \left( \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= a \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">又因为：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln \theta_n
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= b \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \left( 1 + \frac{a+bi}{n} \right)^n
    &amp;= \lim_{n \rightarrow \infty} r_n(\cos\theta_n + i\sin\theta_n) \\
    &amp;= \lim_{n \rightarrow \infty} r_n \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \left( \lim_{n \rightarrow \infty} \cos\theta_n + \lim_{n \rightarrow \infty} i\sin\theta_n \right) \\
    &amp;= e^a \cdot (\cos b + i\sin b)
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">e^{a+ib} = e^a(\cos b + i\sin b)</span><span class="yozora-text">，令 </span><span class="yozora-inline-math">a=0</span><span class="yozora-text">，则有</span></p><div class="yozora-math">e^{ix} = \cos x + i\sin x
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了无穷小量 </span><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \left( 1+\frac{1}{x} \right)^x = e</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-6">&uarr;</a><span>&nbsp;[6]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了墨卡托级数： </span><span class="yozora-inline-math">\ln (1+x) \sim x</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{96}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">对于函数 </span><span class="yozora-inline-math">y = \log_a x \, (a &gt; 0, a \neq 1)</span><span class="yozora-text">，增量
</span><span class="yozora-inline-math">\Delta y=\log_a(x + \Delta x) - \log_a x</span><span class="yozora-text">，则有：</span></p><div class="yozora-math">\frac{\Delta y}{\Delta x}
= \frac{1}{\Delta x} \log_a \left( 1 + \frac{\Delta x}{x} \right)
= \frac{1}{x} \log_a \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}}.
</div><p class="yozora-paragraph"><span class="yozora-text">取极限，有</span><sup id="reference-footnote-5" class="yozora-footnote-reference"><a href="#footnote-5" title="5">[5]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}
  &amp;= \frac{1}{x} \log_a \left[ \lim_{\Delta x \rightarrow 0} \left( 1 + \frac{\Delta x}{x} \right)^{\frac{x}{\Delta x}} \right] \\
  &amp;= \frac{1}{x} \log_a e = \frac{1}{x \ln a}.
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即：</span></p><div class="yozora-math">(\log_a x)' = \frac{1}{x\ln a}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{38}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">a &gt; b &gt; 0</span><span class="yozora-text"> 时，有</span></p><div class="yozora-math">\begin{aligned}
 a^{n+1} - b^{n+1} &amp;= (a - b) \cdot \left(\sum_{k=0}^{n} a^k \cdot b^{n-k} \right)\\
                   &amp;&lt; (n + 1) \cdot (a - b) \cdot a^n\\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即</span></p><div class="yozora-math">a^n [(n+1)b - na] &lt; b^{n+1} \label{eq-1}\tag{1}
</div><p class="yozora-paragraph"><span class="yozora-text">取 </span><span class="yozora-inline-math">\displaystyle a=1 + \frac{1}{2n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">b=1</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^n &lt; 2
</div><p class="yozora-paragraph"><span class="yozora-text">从而</span></p><div class="yozora-math">\left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">再取 </span><span class="yozora-inline-math">\displaystyle a = 1 + \frac{1}{n}</span><span class="yozora-text">，</span><span class="yozora-inline-math">\displaystyle b = 1 + \frac{1}{n+1}</span><span class="yozora-text">，代入 </span><span class="yozora-inline-math">\eqref{eq-1}</span><span class="yozora-text"> 式，得</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{n+1} \right)^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">从而数列 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 是严格单调递增的，故有</span></p><div class="yozora-math">\left( 1 + \frac{1}{n} \right)^n &lt; \left( 1 + \frac{1}{2n} \right)^{2n} &lt; 4, \qquad n=1,2,\cdots
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">\displaystyle \left\{ \left( 1 + \frac{1}{n} \right)^n \right\}</span><span class="yozora-text"> 有上界，又由于它是单调递增的，故它是一个收敛的数列。通常我们将这个数列的极限值记为 </span><span class="yozora-inline-math">e</span><span class="yozora-text">.</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自湖南大学《大学数学1》第三版 </span><span class="yozora-inline-math">\;P_{134}</span></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">麦克劳林（Maclaurin）公式如下（其中，</span><span class="yozora-inline-math">\xi</span><span class="yozora-text"> 在 </span><span class="yozora-inline-math">0</span><span class="yozora-text"> 和 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 之间）：</span></p><div class="yozora-math">  f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!} + \cdots + 
         \frac{f^{(n)}(0)}{n!}x + \frac{f^{(n+1)}(\xi)}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">求 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 的麦克劳林级数时应用到了 </span><span class="yozora-inline-math">e</span><span class="yozora-text"> 的一个重要性质： </span><span class="yozora-inline-math">(e^x)' = e^x</span></p><p class="yozora-paragraph"><span class="yozora-text">由于 </span><span class="yozora-inline-math">f'(x) = (e^x)' = e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(x)=e^x</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n + 1)}(x)=e^x</span><span class="yozora-text">， </span><br class="yozora-break" /><span class="yozora-text">
得 </span><span class="yozora-inline-math">f(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f'(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">\cdots</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n)}(0)=1</span><span class="yozora-text">, </span><span class="yozora-inline-math">f^{(n+1)}(\xi)=e^x</span><span class="yozora-text">. 故有：</span></p><div class="yozora-math">e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + \frac{e^\xi}{(n+1)!} x^{n+1}
</div><p class="yozora-paragraph"><span class="yozora-text">当 </span><span class="yozora-inline-math">x \rightarrow 0</span><span class="yozora-text"> 时，有：</span></p><div class="yozora-math">\lim_{x \rightarrow 0} e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^2}{n!}
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><div class="yozora-admonition yozora-admonition--note"><h5 class="yozora-admonition__heading"><span class="yozora-admonition__heading-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" /></svg></span><span class="yozora-admonition__heading-title"><span class="yozora-text">节选自 </span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">欧拉公式 | 维基百科</span></a></span></h5><div class="yozora-admonition__body"><p class="yozora-paragraph"><span class="yozora-text">首先，在复数域上对 </span><span class="yozora-inline-math">e^x</span><span class="yozora-text"> 进行定义：</span></p><blockquote class="yozora-blockquote"><p class="yozora-paragraph"><span class="yozora-text">对于 </span><span class="yozora-inline-math">a,b \in \mathbb{R}, c=a+ib \in \mathbb{C}</span><span class="yozora-text">，规定
</span><span class="yozora-inline-math">\displaystyle e^{\mathbb C}=\lim_{n \rightarrow \infty} \left(1 + \frac{c}{n} \right)^n</span><span class="yozora-text">.</span></p></blockquote><p class="yozora-paragraph"><span class="yozora-text">对</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6)#%E6%9E%81%E5%9D%90%E6%A0%87%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">复数的极坐标表示</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w= \mu + i\nu = r(\cos\theta + i\sin\theta)</span><span class="yozora-text">，从而有：</span></p><div class="yozora-math">r = \sqrt{\mu^2 + \nu^2} \in \mathbb{R}, \; \theta=\arctan \left( \frac{\nu}{\mu} \right) \in \mathbb{R}
</div><p class="yozora-paragraph"><span class="yozora-text">根据</span><a class="yozora-link" href="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" title="https://zh.wikipedia.org/wiki/%E6%A3%A3%E8%8E%AB%E5%BC%97%E5%85%AC%E5%BC%8F" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">棣莫弗公式</span></a><span class="yozora-text"> </span><span class="yozora-inline-math">w^n=(\mu + i\nu)^n = r^n(\cos{n\theta} + i\sin{n\theta})</span><span class="yozora-text">，有：</span></p><div class="yozora-math">\left( 1 + \frac{a + bi}{n} \right)^n 
= \left[ \left( 1 + \frac{a}{n} \right) + i \cdot \frac{b}{n} \right]^n 
= r_n(\cos\theta_n + i\sin\theta_n)
</div><p class="yozora-paragraph"><span class="yozora-text">假设 </span><span class="yozora-inline-math">n &gt; \lvert a \rvert</span><span class="yozora-text">，则：</span></p><div class="yozora-math">r_n = \left[ \left( 1 + \frac{a}{n} \right)^2 + \left( \frac{b}{n} \right)^2 \right]^{\frac{n}{2}}, \quad 
\theta_n=n \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有</span><sup id="reference-footnote-6" class="yozora-footnote-reference"><a href="#footnote-6" title="6">[6]</a></sup><span class="yozora-text">：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln r_n 
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \ln \left( 1 + \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= \lim_{n \rightarrow \infty} \left[ \frac{n}{2} \cdot \left( \frac{2a}{n} + \frac{a^2 + b^2}{n^2} \right) \right] \\
    &amp;= a \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">又因为：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \ln \theta_n
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \arctan \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= \lim_{n \rightarrow \infty} \left( n \cdot \frac{\frac{b}{n}}{1 + \frac{a}{n}} \right) \\
    &amp;= b \\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">从而有：</span></p><div class="yozora-math">\begin{aligned}
  \lim_{n \rightarrow \infty} \left( 1 + \frac{a+bi}{n} \right)^n
    &amp;= \lim_{n \rightarrow \infty} r_n(\cos\theta_n + i\sin\theta_n) \\
    &amp;= \lim_{n \rightarrow \infty} r_n \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \lim_{n \rightarrow \infty} (\cos\theta_n + i\sin\theta_n) \\
    &amp;= e^{\lim_{n \rightarrow \infty} \ln r_n} \cdot \left( \lim_{n \rightarrow \infty} \cos\theta_n + \lim_{n \rightarrow \infty} i\sin\theta_n \right) \\
    &amp;= e^a \cdot (\cos b + i\sin b)
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">即 </span><span class="yozora-inline-math">e^{a+ib} = e^a(\cos b + i\sin b)</span><span class="yozora-text">，令 </span><span class="yozora-inline-math">a=0</span><span class="yozora-text">，则有</span></p><div class="yozora-math">e^{ix} = \cos x + i\sin x
</div><p class="yozora-paragraph"><span class="yozora-text">【证毕】</span></p></div></div></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了无穷小量 </span><span class="yozora-inline-math">\displaystyle \lim_{x \rightarrow 0} \left( 1+\frac{1}{x} \right)^x = e</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-6">&uarr;</a><span>&nbsp;[6]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">用到了墨卡托级数： </span><span class="yozora-inline-math">\ln (1+x) \sim x</span></p></div></div></ul></div></footer></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[当你想来一把数独]]></title>
            <link>https://me.guanghechen.com/post/game/sudoku</link>
            <guid>https://me.guanghechen.com/post/game/sudoku</guid>
            <pubDate>Sat, 31 Jul 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">前一阵子想要整理一下</span><a class="yozora-link" href="/post/algorithm/dlx/" title="/post/algorithm/dlx/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">精确覆盖问题和 DLX 算法</span></a><span class="yozora-text">，为了验证对算法理解的准确性写了一道数独的题目。想起大学时用 </span><pre class="yozora-inline-code"><code>C++</code></pre><span class="yozora-text"> 写过一个回溯版的，当时还兴致冲冲地拿它去求解手机上的数独游戏。想到这里时还特意在电脑上翻了好久也没能找到当时的代码；想起那时在 codevs.cn 上做过提交，本来还想去嫌弃下自己当年写的代码的，结果发现
codevs.cn 好像死掉了。</span></p><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">即上述约束中第四个约束提到的“子方阵”</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为空的面板必然存在解，最坏的情况是擦除所有的格子上的值（当然，不可能等到所有格子都被擦除才找到解）</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">否则将存在多个解，因为此时格子 </span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text"> 至少可以有 </span><span class="yozora-inline-math">v</span><span class="yozora-text">
和 </span><span class="yozora-inline-math">v'</span><span class="yozora-text"> 两种选择</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为可以简单检查格子所处的行、列、子方阵上的值构成的集合，即可在 </span><span class="yozora-inline-math">O(x^2)</span><span class="yozora-text"> 的复杂度内排除部分答案，这个预处理的开销远远小于运行求解数独算法的开销，且事先排除掉不可能的情况有利于消除边缘数据</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">即上述约束中第四个约束提到的“子方阵”</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为空的面板必然存在解，最坏的情况是擦除所有的格子上的值（当然，不可能等到所有格子都被擦除才找到解）</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">否则将存在多个解，因为此时格子 </span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text"> 至少可以有 </span><span class="yozora-inline-math">v</span><span class="yozora-text">
和 </span><span class="yozora-inline-math">v'</span><span class="yozora-text"> 两种选择</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为可以简单检查格子所处的行、列、子方阵上的值构成的集合，即可在 </span><span class="yozora-inline-math">O(x^2)</span><span class="yozora-text"> 的复杂度内排除部分答案，这个预处理的开销远远小于运行求解数独算法的开销，且事先排除掉不可能的情况有利于消除边缘数据</span></p></div></div></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">前一阵子想要整理一下</span><a class="yozora-link" href="/post/algorithm/dlx/" title="/post/algorithm/dlx/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">精确覆盖问题和 DLX 算法</span></a><span class="yozora-text">，为了验证对算法理解的准确性写了一道数独的题目。想起大学时用 </span><pre class="yozora-inline-code"><code>C++</code></pre><span class="yozora-text"> 写过一个回溯版的，当时还兴致冲冲地拿它去求解手机上的数独游戏。想到这里时还特意在电脑上翻了好久也没能找到当时的代码；想起那时在 codevs.cn 上做过提交，本来还想去嫌弃下自己当年写的代码的，结果发现
codevs.cn 好像死掉了。</span></p><p class="yozora-paragraph"><span class="yozora-text">时间过得可真快，转眼间又是几个春秋。而我仿佛总是在迟到，好几件事情都没能在最希望完成的时候做到，却又在过后耿耿于怀，不甘心地追逐着过去的时空里所发生的期待。不是在原地踏步，可还是开始动摇，想必继续往前的地方是没有尽头的。</span></p><h2 class="yozora-heading"><span class="yozora-text">什么是数独</span></h2><p class="yozora-paragraph"><span class="yozora-text">一个经典的数独游戏由 </span><span class="yozora-inline-math">x^2</span><span class="yozora-text"> </span><span class="yozora-inline-math">\times x^2</span><span class="yozora-text"> 的网格构成，游戏的规则就是在网格上填数直到满足下述四个约束：</span></p><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">网格中所有的格子都恰好填上一个数字</span></li><li class="yozora-list-item"><span class="yozora-text">每一行中需要出现 </span><span class="yozora-inline-math">[1, x^2]</span><span class="yozora-text"> 之间的所有整数</span></li><li class="yozora-list-item"><span class="yozora-text">每一列中需要出现 </span><span class="yozora-inline-math">[1, x^2]</span><span class="yozora-text"> 之间的所有整数</span></li><li class="yozora-list-item"><span class="yozora-text">每一个子方阵中需要出现 </span><span class="yozora-inline-math">[1, x^2]</span><span class="yozora-text"> 之间的所有整数</span></li></ol><p class="yozora-paragraph"><span class="yozora-text">如下所示是一个经典的 </span><span class="yozora-inline-math">9 \times 9</span><span class="yozora-text"> 的数独面板，其中粗线围成了 </span><span class="yozora-inline-math">x^2=9</span><span class="yozora-text"> 个子方阵
</span><sup id="reference-footnote-1" class="yozora-footnote-reference"><a href="#footnote-1" title="1">[1]</a></sup><span class="yozora-text">。</span></p><pre class="yozora-code"><code>() =&gt; ()
</code></pre><h2 class="yozora-heading"><span class="yozora-text">生成一个数独谜题</span></h2><p class="yozora-paragraph"><span class="yozora-text">要写一个离线游戏首先要解决数据的问题，对于数独要考虑的问题有：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">如何确保存在解</span></li><li class="yozora-list-item"><span class="yozora-text">如何确保唯一解</span></li><li class="yozora-list-item"><span class="yozora-text">如何区分难度</span></li><li class="yozora-list-item"><span class="yozora-text">如何获得更好的随机性</span></li></ul><h3 class="yozora-heading"><span class="yozora-text">如何确保存在解</span></h3><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">先生成一个填满的数独面板 </span><span class="yozora-inline-math">G(r, c)</span></p><p class="yozora-paragraph"><span class="yozora-text">在数独面板上选取若干个位置，无冲突地填入值，然后跑求解数独的算法，若无解，则从之前选取填入的位置中选取一个，将其上面的值擦除，再运行求解数独的算法，不断重复此过程，必然能得到一个填满的数独</span><sup id="reference-footnote-2" class="yozora-footnote-reference"><a href="#footnote-2" title="2">[2]</a></sup><span class="yozora-text">。</span></p><p class="yozora-paragraph"><span class="yozora-text">如何求解数独可参见 </span><a class="yozora-link" href="/post/algorithm/dlx/" title="/post/algorithm/dlx/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">精确覆盖问题和 DLX 算法</span></a></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">在一个填满的数独面板中选取若干个位置，依次枚举这些位置 </span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text">，尝试将上面的值 </span><span class="yozora-inline-math">v=G(r, c)</span><span class="yozora-text"> 擦除，则得到一个必定存在解的数独谜题。</span></p></li></ul><h3 class="yozora-heading"><span class="yozora-text">如何确保唯一解</span></h3><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">在上一步选取待擦除位置的操作中增加一个校验的逻辑：尝试擦除位置 </span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text"> 上的值
</span><span class="yozora-inline-math">v = G(r, c)</span><span class="yozora-text"> 时，枚举 </span><span class="yozora-inline-math">[1, x^2]</span><span class="yozora-text"> 之间除 </span><span class="yozora-inline-math">v</span><span class="yozora-text"> 外的所有整数 </span><span class="yozora-inline-math">v'</span><span class="yozora-text">，并将格子
</span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text"> 的值设置为 </span><span class="yozora-inline-math">v'</span><span class="yozora-text">，对于每次枚举都分别跑一次求解数独的算法，若存在解，说明此位置上的值不能擦除</span><sup id="reference-footnote-3" class="yozora-footnote-reference"><a href="#footnote-3" title="3">[3]</a></sup><span class="yozora-text">；否则，擦除此格子上的值。</span></li></ul><h3 class="yozora-heading"><span class="yozora-text">如何区分难度</span></h3><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">一个直观的印象是：数独面板中缺失的格子越多，想要解决的困难度越大。所以难度可以映射为在生成数独谜题时尽可能多地尝试擦除格子。</span></li></ul><p class="yozora-paragraph"><span class="yozora-text">下面是一个示例，拖动滑块以切换难度。</span></p><pre class="yozora-code"><code>() =&gt; ()
</code></pre><h3 class="yozora-heading"><span class="yozora-text">如何获得更好的随机性</span></h3><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">在初始填充的数独面板时：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">随机选取填充的位置</span></p><p class="yozora-paragraph"><span class="yozora-text">将所有的格子排成一排，为方便叙述不妨将其记为 </span><span class="yozora-inline-math">T</span><span class="yozora-text">，应用 </span><a class="yozora-link" href="/post/algorithm/shuffle/" title="/post/algorithm/shuffle/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Knuth Shuffle</span></a><span class="yozora-text">
算法将其顺序打乱。则在随机选取格子时直接遍历打乱顺序后的 </span><span class="yozora-inline-math">T</span><span class="yozora-text"> 就可以了。一方面 </span><a class="yozora-link" href="/post/algorithm/shuffle/" title="/post/algorithm/shuffle/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Knuth Shuffle</span></a><span class="yozora-text"> 保证了每个格子以相同的概率排在任一位置上；另一方面直接遍历 </span><span class="yozora-inline-math">T</span><span class="yozora-text"> 相比随机枚举格子，不存在重复枚举的可能性。</span></p></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">按随机顺序枚举某个位置上可填入的值</span></p><p class="yozora-paragraph"><span class="yozora-text">枚举 </span><span class="yozora-inline-math">v'</span><span class="yozora-text"> 时可以先求出一个候选项列表</span><sup id="reference-footnote-4" class="yozora-footnote-reference"><a href="#footnote-4" title="4">[4]</a></sup><span class="yozora-text">，同样地，将候选项列表打乱顺序后进行遍历。</span></p></li></ul></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">在尝试擦除格子时：</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">随机选取待擦除的位置</span></p><p class="yozora-paragraph"><span class="yozora-text">类似地，在尝试擦除格子时，可以通过遍历 </span><span class="yozora-inline-math">T</span><span class="yozora-text"> 达到随机枚举格子的效果。检查擦除此位置时是否存在多解时，直接按顺序遍历即可。</span></p><p class="yozora-paragraph"><span class="yozora-text">为了体现难度，可以只对前 </span><span class="yozora-inline-math">\displaystyle \left\lceil difficulty \times \big\lvert T \big\rvert \right\rceil</span><span class="yozora-text">
个格子进行擦除尝试。</span></p></li></ul></li></ul><h2 class="yozora-heading"><span class="yozora-text">交互设计</span></h2><p class="yozora-paragraph"><span class="yozora-text">除了数据外还需要考虑几个交互问题：</span></p><ul class="yozora-list"><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">切换难度和数独面板的大小</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">暂停（暂停时用模糊滤镜遮住谜题）、继续游戏、重新开始游戏</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">计时器：支持暂停、恢复、重置</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">区分谜题预填充的格子和玩家填充的格子</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">格子的输入</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">输入冲突的值时高亮提醒</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">选中非空格子时高亮与之值相同的格子</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">完成游戏时的简易提示</span></li><li class="yozora-list-item"><input checked="" disabled="" type="checkbox" /> <span class="yozora-text">简易的提示和小抄</span></li><li class="yozora-list-item"><input disabled="" type="checkbox" /> <span class="yozora-text">完成某行、列或子方阵时的提示动画</span></li></ul><h2 class="yozora-heading"><span class="yozora-text">附录</span></h2><p class="yozora-paragraph"><span class="yozora-text">下面我实现的一个简易数独，求解数独以及生成数独所需的数据的算法我封装到了
</span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/tree/main/packages/sudoku" title="https://github.com/guanghechen/algorithm.ts/tree/main/packages/sudoku" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a><span class="yozora-text"> 中，有兴趣的朋友可以自取。ui 组件打算之后做好整理再开源。</span></p><pre class="yozora-code"><code>() =&gt; 
</code></pre><h2 class="yozora-heading"><span class="yozora-text">Related</span></h2><ul class="yozora-list"><li class="yozora-list-item"><a class="yozora-link" href="/post/algorithm/dlx/" title="/post/algorithm/dlx/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">精确覆盖问题和 DLX 算法 | 光和尘</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="/post/algorithm/shuffle/" title="/post/algorithm/shuffle/" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">洗牌问题和 Knuth-Shuffle 算法 | 光和尘</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="/game/sudoku" title="/game/sudoku" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">Sudoku Game | 光和尘</span></a></li><li class="yozora-list-item"><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/tree/main/packages/sudoku" title="https://github.com/guanghechen/algorithm.ts/tree/main/packages/sudoku" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a></li></ul><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">即上述约束中第四个约束提到的“子方阵”</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为空的面板必然存在解，最坏的情况是擦除所有的格子上的值（当然，不可能等到所有格子都被擦除才找到解）</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">否则将存在多个解，因为此时格子 </span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text"> 至少可以有 </span><span class="yozora-inline-math">v</span><span class="yozora-text">
和 </span><span class="yozora-inline-math">v'</span><span class="yozora-text"> 两种选择</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为可以简单检查格子所处的行、列、子方阵上的值构成的集合，即可在 </span><span class="yozora-inline-math">O(x^2)</span><span class="yozora-text"> 的复杂度内排除部分答案，这个预处理的开销远远小于运行求解数独算法的开销，且事先排除掉不可能的情况有利于消除边缘数据</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">即上述约束中第四个约束提到的“子方阵”</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为空的面板必然存在解，最坏的情况是擦除所有的格子上的值（当然，不可能等到所有格子都被擦除才找到解）</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">否则将存在多个解，因为此时格子 </span><span class="yozora-inline-math">(r, c)</span><span class="yozora-text"> 至少可以有 </span><span class="yozora-inline-math">v</span><span class="yozora-text">
和 </span><span class="yozora-inline-math">v'</span><span class="yozora-text"> 两种选择</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">因为可以简单检查格子所处的行、列、子方阵上的值构成的集合，即可在 </span><span class="yozora-inline-math">O(x^2)</span><span class="yozora-text"> 的复杂度内排除部分答案，这个预处理的开销远远小于运行求解数独算法的开销，且事先排除掉不可能的情况有利于消除边缘数据</span></p></div></div></ul></div></footer></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[精确覆盖问题和 DLX 算法]]></title>
            <link>https://me.guanghechen.com/post/algorithm/dlx</link>
            <guid>https://me.guanghechen.com/post/algorithm/dlx</guid>
            <pubDate>Fri, 23 Jul 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">很早就想要补一下舞蹈链和精确覆盖算法，却一直各种拖延，趁着最近有空，又重新翻开了刘汝佳的书。大学的时候看过几次，甚至照着书里的思路手敲了一遍并通过了例题，但对于算法的原理一直有些不求甚解。很早以前，一位同学告诉我说“现在看不懂的东西不用勉强，以后慢慢就会懂了”，后来也真的在不断印证这句话；但我很担心随着年纪的增长，记忆力和学习能力不断退化之后，恐怕这个 flag 会逐渐倒下。所以趁着眼下尚能理解进去，尽量用自己的语言做一下记录。</span></p><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，此处并没有构成递归删除，因为只有被选择的行才需要删除行上的其余列，而删除这些列时所删除的其它行并未被选择（被选择行的此时均已被删除），也就不会进一步删除它们的列了。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">每次删除时都是选择一个未被覆盖的列，然后枚举覆盖此列的行，之后删除该行上的其它列。即每次选取了一个集合 </span><span class="yozora-inline-math">s</span><span class="yozora-text">，将目标集合中所有在 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 中出现的数字都删去，同时删除所有与 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 有非空交集的那些集合，也就是每次选择集合都保证了和之前已选择的集合间没有交集。而当目标集合为空时，说明所有数字都在已选择的集合中出现过了，也就是已选择的集合中无重叠、无遗漏的覆盖了目标集合中的所有数字。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">这里指的是虚拟列，即相当于目标集合中的未被覆盖的元素，对应于下文中将提到的舞蹈链中中的列虚拟节点，所以即便所有行都被删除，列虚拟节点构成的链表仍可能不为空。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">在使用数组模拟链表的实现中，虚拟节点用列号表示就行了。而舞蹈链的头指针有
</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 表示即可。需要注意的是，舞蹈链中所有列号均为正整数。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，</span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" title="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a><span class="yozora-text"> 中对于一个 </span><span class="yozora-inline-math">x^2 \times x^2</span><span class="yozora-text">
的数独，使用 </span><span class="yozora-inline-math">[-1, x^2)</span><span class="yozora-text"> 之间的整数作为数独格子的值，其中 </span><span class="yozora-inline-math">-1</span><span class="yozora-text"> 代表对应格子未预置值</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，此处并没有构成递归删除，因为只有被选择的行才需要删除行上的其余列，而删除这些列时所删除的其它行并未被选择（被选择行的此时均已被删除），也就不会进一步删除它们的列了。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">每次删除时都是选择一个未被覆盖的列，然后枚举覆盖此列的行，之后删除该行上的其它列。即每次选取了一个集合 </span><span class="yozora-inline-math">s</span><span class="yozora-text">，将目标集合中所有在 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 中出现的数字都删去，同时删除所有与 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 有非空交集的那些集合，也就是每次选择集合都保证了和之前已选择的集合间没有交集。而当目标集合为空时，说明所有数字都在已选择的集合中出现过了，也就是已选择的集合中无重叠、无遗漏的覆盖了目标集合中的所有数字。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">这里指的是虚拟列，即相当于目标集合中的未被覆盖的元素，对应于下文中将提到的舞蹈链中中的列虚拟节点，所以即便所有行都被删除，列虚拟节点构成的链表仍可能不为空。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">在使用数组模拟链表的实现中，虚拟节点用列号表示就行了。而舞蹈链的头指针有
</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 表示即可。需要注意的是，舞蹈链中所有列号均为正整数。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，</span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" title="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a><span class="yozora-text"> 中对于一个 </span><span class="yozora-inline-math">x^2 \times x^2</span><span class="yozora-text">
的数独，使用 </span><span class="yozora-inline-math">[-1, x^2)</span><span class="yozora-text"> 之间的整数作为数独格子的值，其中 </span><span class="yozora-inline-math">-1</span><span class="yozora-text"> 代表对应格子未预置值</span></p></div></div></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><h2 class="yozora-heading"><span class="yozora-text">前言</span></h2><p class="yozora-paragraph"><span class="yozora-text">很早就想要补一下舞蹈链和精确覆盖算法，却一直各种拖延，趁着最近有空，又重新翻开了刘汝佳的书。大学的时候看过几次，甚至照着书里的思路手敲了一遍并通过了例题，但对于算法的原理一直有些不求甚解。很早以前，一位同学告诉我说“现在看不懂的东西不用勉强，以后慢慢就会懂了”，后来也真的在不断印证这句话；但我很担心随着年纪的增长，记忆力和学习能力不断退化之后，恐怕这个 flag 会逐渐倒下。所以趁着眼下尚能理解进去，尽量用自己的语言做一下记录。</span></p><h2 class="yozora-heading"><span class="yozora-text">精确覆盖问题</span></h2><p class="yozora-paragraph"><span class="yozora-text">有一些由整数 </span><span class="yozora-inline-math">1 \sim n</span><span class="yozora-text"> 中的数字组成的集合 </span><span class="yozora-inline-math">S_1, S_2, \cdots, S_m</span><span class="yozora-text">，要求选择若干个集合 </span><span class="yozora-inline-math">S_i</span><span class="yozora-text">，使得 </span><span class="yozora-inline-math">1 \sim n</span><span class="yozora-text"> 中每个整数都在选出的集合中的某个出现且恰好仅出现一次。举个栗子：</span></p><blockquote class="yozora-blockquote"><p class="yozora-paragraph"><span class="yozora-text">不妨假设 </span><span class="yozora-inline-math">n=7, m=6</span><span class="yozora-text">，集合为：</span></p><div class="yozora-math">\begin{aligned}
  S_1&amp;=\lbrace 1, 4, 7 \rbrace\\
  S_2&amp;=\lbrace 1, 4 \rbrace\\
  S_3&amp;=\lbrace 4,5,7 \rbrace\\
  S_4&amp;=\lbrace 3, 5, 6 \rbrace\\
  S_5&amp;=\lbrace 2, 3, 6, 7 \rbrace\\
  S_6&amp;=\lbrace 2, 7 \rbrace\\
\end{aligned}
</div><p class="yozora-paragraph"><span class="yozora-text">则一个精确覆盖为 </span><span class="yozora-inline-math">\lbrace S_2, S_4, S_6 \rbrace</span><span class="yozora-text">，因为 </span><span class="yozora-inline-math">\lbrace 1, 4 \rbrace</span><span class="yozora-text">,
</span><span class="yozora-inline-math">\lbrace 3, 5, 6 \rbrace</span><span class="yozora-text">, </span><span class="yozora-inline-math">\lbrace 2, 7 \rbrace</span><span class="yozora-text"> 无重复、无遗漏地包含了 </span><span class="yozora-inline-math">1 \sim 7</span><span class="yozora-text">
中的所有整数。</span></p></blockquote><p class="yozora-paragraph"><span class="yozora-text">我们可以用一个 </span><span class="yozora-inline-math">m \times n</span><span class="yozora-text"> 的 </span><span class="yozora-inline-math">01</span><span class="yozora-text"> 矩阵来表示集合，其中，</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 表示不包含，</span><span class="yozora-inline-math">1</span><span class="yozora-text"> 表示包含。比如第 </span><span class="yozora-inline-math">(i, j)</span><span class="yozora-text"> 个位置若为 </span><span class="yozora-inline-math">0</span><span class="yozora-text">，则说明 </span><span class="yozora-inline-math">S_i</span><span class="yozora-text"> 中不包含 </span><span class="yozora-inline-math">j</span><span class="yozora-text">。上文中的栗子用矩阵表示如下所示：</span></p><table class="yozora-table"><thead class="yozora-table__thead"><tr class="yozora-table-row"><th class="yozora-table-cell" align="center"><span class="yozora-inline-math"> </span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">2</span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">3</span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">4</span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">5</span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">6</span></th><th class="yozora-table-cell" align="center"><span class="yozora-inline-math">7</span></th></tr></thead><tbody class="yozora-table__tbody"><tr class="yozora-table-row"><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">S_1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td></tr><tr class="yozora-table-row"><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">S_2</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td></tr><tr class="yozora-table-row"><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">S_3</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td></tr><tr class="yozora-table-row"><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">S_4</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td></tr><tr class="yozora-table-row"><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">S_5</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td></tr><tr class="yozora-table-row"><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">S_6</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">0</span></td><td class="yozora-table-cell" align="center"><span class="yozora-inline-math">1</span></td></tr></tbody></table><p class="yozora-paragraph"><span class="yozora-text">则精确覆盖问题可重新表述为：在一个 </span><span class="yozora-inline-math">m \times n</span><span class="yozora-text"> 的 </span><span class="yozora-inline-math">01</span><span class="yozora-text"> 矩阵中，选择若干行，对这些行做向量加法，得到的结果为 </span><span class="yozora-inline-math">(1, 1, \cdots, 1)</span><span class="yozora-text">。即：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">选出的行里，不存在某列同时在两行中值均为 </span><span class="yozora-inline-math">1</span><span class="yozora-text">；</span></li><li class="yozora-list-item"><span class="yozora-text">所有选出的行叠加在一起的结果覆盖所有列（每一列的值都不为 </span><span class="yozora-inline-math">0</span><span class="yozora-text">）。</span></li></ul><h2 class="yozora-heading"><span class="yozora-text">算法 X</span></h2><p class="yozora-paragraph"><span class="yozora-text">算法 X（Algorithm X），其实就是回溯，可能是专门针对覆盖问题提出的算法吧。算法描述如下：</span></p><blockquote class="yozora-blockquote"><p class="yozora-paragraph"><span class="yozora-text">每次选择一个没有被删除列，然后枚举该列为 </span><span class="yozora-inline-math">1</span><span class="yozora-text"> 的所有行，尝试删除这些行，递归搜索后再恢复这些行。尝试删除行时，还要将该行中所有值为 </span><span class="yozora-inline-math">1</span><span class="yozora-text"> 的列也一并删除</span><sup id="reference-1" class="yozora-footnote-reference"><a href="#1" title="1">[1]</a></sup><span class="yozora-text">，恢复时也同样。</span></p><p class="yozora-paragraph"><span class="yozora-text">若没有可以选择的列了（即所有列都被删除了），说明已经找到一个精确覆盖的解了</span><sup id="reference-2" class="yozora-footnote-reference"><a href="#2" title="2">[2]</a></sup><span class="yozora-text">；若还有列但是没有行了</span><sup id="reference-3" class="yozora-footnote-reference"><a href="#3" title="3">[3]</a></sup><span class="yozora-text">说明原问题无解。</span></p></blockquote><h2 class="yozora-heading"><span class="yozora-text">舞蹈链</span></h2><p class="yozora-paragraph"><span class="yozora-text">舞蹈链（Dancing Link），一种支持快速删除、恢复列和行的数据结构。</span></p><p class="yozora-paragraph"><span class="yozora-text">舞蹈链是一个十字型双向链表结构，链表中的每个节点对应上述 </span><span class="yozora-inline-math">01</span><span class="yozora-text"> 矩阵中的一个 </span><span class="yozora-inline-math">1</span><span class="yozora-text">。另外还有 </span><span class="yozora-inline-math">n+1</span><span class="yozora-text"> 个虚拟节点，其中每列最上方一个虚拟节点作为该列链表的头指针，而所有虚拟节点的最前方有一个虚拟节点，作为虚拟节点的头指针，它也是舞蹈链的头指针。如下图所示（图片来源于网络）：</span></p><p class="yozora-paragraph"><img class="yozora-image" alt="dancing-link.png" src="/asset/img/post/adfc77b1-1fc0-59ba-bd69-b69726d6cdc2.png?width=744&amp;height=638" title="dancing-link.png" /></p><p class="yozora-paragraph"><span class="yozora-text">使用四个数组 </span><span class="yozora-inline-math">L</span><span class="yozora-text">, </span><span class="yozora-inline-math">R</span><span class="yozora-text">, </span><span class="yozora-inline-math">U</span><span class="yozora-text">, </span><span class="yozora-inline-math">D</span><span class="yozora-text"> 分别表示舞蹈链中节点的左、右、上、下四个方向的指针，下标为节点的编号；同时列编号作为该列的虚拟节点，</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 表示舞蹈链的头指针对应的虚拟节点。</span></p><ul class="yozora-list"><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">删除行：只需要修改将该行中所有节点的上下行的下、上指针互指就好了。</span></p><pre class="yozora-code"><code>// 设要删除的某行中某个节点编号为 R[i]
for (let j = R[i]; j !== i; j = R[j]) {
  U[D[j]] = U[j]
  D[U[j]] = D[j]
}
</code></pre></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">恢复行：只需要将该行中所有节点的上下行的下、上指针分别指向该该节点就好了。</span></p><pre class="yozora-code"><code>// 设要删除的某行中某个节点编号为 R[i]
for (let j = R[i]; j !== i; j = R[j]) {
  U[D[j]] = j
  D[U[j]] = j
}
</code></pre></li><li class="yozora-list-item"><p class="yozora-paragraph"><span class="yozora-text">删除列和恢复列也类似，此处略去。</span></p></li></ul><h2 class="yozora-heading"><span class="yozora-text">DLX 算法</span></h2><p class="yozora-paragraph"><span class="yozora-text">使用了舞蹈链的算法 X 通常被称为 DLX 算法。此处给出 DLX 算法的 Typescript 实现</span><sup id="reference-4" class="yozora-footnote-reference"><a href="#4" title="4">[4]</a></sup><span class="yozora-text">。</span></p><pre class="yozora-code"><code>/**
 * The algorithm X that applied the dancing-link, it is also called as "DLX".
 * It is used to solve the exact-cover problem.
 *
 * Dancing-link: A cross doubly linked list, each column has a virtual node as
 * the head pointer, and at the top of all virtual nodes there is an additional
 * virtual node as the head pointer of the virtual node, which is also the head
 * pointer of the entire dancing-link. In the implementation of using an array
 * to simulate a linked list, the virtual node is represented by a column
 * number, and the head pointer of the dancing-link can be represented by 0.
 *
 * @see https://me.guanghechen.com/post/algorithm/dlx/
 */
export interface DLX {
  /**
   * Initialize the dancing-link.
   * @param totalColumns   number of columns
   */
  init(totalColumns: number): void

  /**
   * Release memory variables.
   */
  destroy(): void

  /**
   * Add a row to the dancing-link.
   *
   * It should be noted that after solving the exact-cover problem, the
   * result is a list of selected row numbers, so the row number should be
   * specified as a value that can carry information.
   *
   * @param r         the row number
   * @param columns   columns on the row
   */
  addRow(rowNo: number, columns: ReadonlyArray): void

  /**
   * Try to find a precise coverage.
   *
   * When a solution is found, return the row numbers of all selected rows,
   * otherwise return null.
   */
  solve(): number[] | null
}

/**
 * Generate an object that encapsulates the DLX algorithm.
 *
 * @param MAX_N   maximum number of nodes in the dancing-link
 * @returns
 */
export function createDLX(MAX_N: number): DLX {
  // The number of nodes in the dancing-link (including the virtual nodes on
  // the column).
  let sz: number

  // the number of columns in the dancing-link.
  let totalColumns: number

  const selectedRowNos: number[] = new Array(MAX_N) // list of row numbers of selected rows
  let countOfSelectedRows: number // the number of selected rows

  const count: number[] = new Array(MAX_N) // lhe number of nodes of a column in the dancing-link
  const row: number[] = new Array(MAX_N) // the row number of a node in the dancing-link
  const col: number[] = new Array(MAX_N) // the column number of a node in the dancing-link
  const L: number[] = new Array(MAX_N) // left pointer of cross-link list
  const R: number[] = new Array(MAX_N) // right pointer of cross-link list
  const U: number[] = new Array(MAX_N) // up pointer of cross-link list
  const D: number[] = new Array(MAX_N) // down pointer of cross-link list
  return { init, destroy, addRow, solve }

  /**
   * @see DLX#init
   * @public
   */
  function init(_totalColumns: number): void {
    totalColumns = _totalColumns
    sz = _totalColumns + 1

    // Resize arrays.
    if (selectedRowNos.length &lt; sz) {
      selectedRowNos.length = sz
      count.length = sz
      row.length = sz
      col.length = sz
      L.length = sz
      R.length = sz
      U.length = sz
      D.length = sz
    }

    for (let i = 0; i &lt; sz; ++i) {
      L[i] = i - 1
      R[i] = i + 1
      U[i] = i
      D[i] = i
    }
    R[_totalColumns] = 0
    L[0] = _totalColumns

    count.fill(0, 0, sz)
  }

  /**
   * @see DLX#destroy
   * @public
   */
  function destroy(): void {
    selectedRowNos.length = 0
    count.length = 0
    row.length = 0
    col.length = 0
    L.length = 0
    R.length = 0
    U.length = 0
    D.length = 0
  }

  /**
   * @see DLX#addRow
   * @public
   */
  function addRow(r: number, columns: ReadonlyArray): void {
    const first = sz
    for (let i = 0; i &lt; columns.length; ++i, ++sz) {
      const c = columns[i]
      row[sz] = r
      col[sz] = c
      count[c] += 1

      // Connect left and right nodes
      L[sz] = sz - 1
      R[sz] = sz + 1

      // Connect top and bottom nodes,
      // c is the virtual node on the c-th column, and is also the head pointer
      // of the linked list of the column, so at this time U[c] is the last
      // element of the column
      D[sz] = c
      D[U[c]] = sz
      U[sz] = U[c]
      U[c] = sz
    }

    // Since this is a circular linked list, the first and last columns of the
    // current row are connected to each other.
    R[sz - 1] = first
    L[first] = sz - 1
  }

  /**
   * @see DLX#solve
   * @public
   */
  function solve(): number[] | null {
    if (!algorithmX(0)) return null
    return selectedRowNos.slice(0, countOfSelectedRows)
  }

  /**
   * Remove a column from the dancing-link.
   * @param c   column number
   * @private
   */
  function removeColumn(c: number): void {
    L[R[c]] = L[c]
    R[L[c]] = R[c]
    for (let i = D[c]; i !== c; i = D[i]) {
      for (let j = R[i]; j !== i; j = R[j]) {
        U[D[j]] = U[j]
        D[U[j]] = D[j]
        count[col[j]] -= 1
      }
    }
  }

  /**
   * Restore a previously deleted column
   * @param c   column number
   * @private
   */
  function restoreColumn(c: number): void {
    for (let i = U[c]; i !== c; i = U[i]) {
      for (let j = L[i]; j !== i; j = L[j]) {
        count[col[j]] += 1
        U[D[j]] = j
        D[U[j]] = j
      }
    }
    L[R[c]] = c
    R[L[c]] = c
  }

  /**
   * Algorithm X.
   *
   * Recursively solve the problem of precise coverage, enumerate which rows are
   * selected in the recursive process, remove the selected rows and all the
   * columns on the rows, and restore these rows and columns during the
   * backtrack.
   *
   * @param dep   recursion depth
   * @private
   */
  function algorithmX(dep: number): boolean {
    // Find a solution when the dancing-link is empty.
    if (R[0] === 0) {
      // Record the length of the solution.
      countOfSelectedRows = dep
      return true
    }

    /**
     * Optimization: Find the column with the least number of nodes, and try to
     * cover from this column.
     */
    let c = R[0]
    for (let i = R[0]; i !== 0; i = R[i]) {
      if (count[i] &lt; count[c]) c = i
    }

    // Remove this column.
    removeColumn(c)
    for (let i = D[c]; i !== c; i = D[i]) {
      selectedRowNos[dep] = row[i]
      for (let j = R[i]; j !== i; j = R[j]) removeColumn(col[j])

      // Recursively processing.
      if (algorithmX(dep + 1)) return true

      // Backtrack.
      for (let j = L[i]; j !== i; j = L[j]) restoreColumn(col[j])
    }
    // Backtrack.
    restoreColumn(c)

    return false
  }
}
</code></pre><p class="yozora-paragraph"><span class="yozora-text">我把它封装在了 </span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/blob/main/packages/dlx/README.md" title="https://github.com/guanghechen/algorithm.ts/blob/main/packages/dlx/README.md" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/dlx</span></a><span class="yozora-text"> 中，你可以通过 npm 包导入它：</span></p><pre class="yozora-code"><code>import { createDLX } from 'algorithm.ts/dlx'

// 创建一个基于至多有 1000 个节点的舞蹈链的 dlx 算法
const dlx = createDLX(1000)

// 初始化 dlx 算法，总共有 1000 列
dlx.init(1000)

// 添加行，此处为伪代码
dlx.addRow(...)

// 尝试找到一个精确覆盖
dlx.solve()
</code></pre><h2 class="yozora-heading"><span class="yozora-text">求解数独问题</span></h2><p class="yozora-paragraph"><span class="yozora-text">数独是精确覆盖问题的一个特例。为了套用 DLX 算法框架，首先需要弄清楚如何构建 </span><span class="yozora-inline-math">01</span><span class="yozora-text">
矩阵。一般来说，可以将列对应成约束，而将行对应到策略，即选择某个策略时能够满足哪些约束。比如考虑经典 </span><span class="yozora-inline-math">x^2 \times x^2</span><span class="yozora-text"> 数独游戏，其有如下类型的约束：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-inline-math">Slot(a,b)</span><span class="yozora-text">: 第 </span><span class="yozora-inline-math">a</span><span class="yozora-text"> 行第 </span><span class="yozora-inline-math">b</span><span class="yozora-text"> 列格子要有数字；</span></li><li class="yozora-list-item"><span class="yozora-inline-math">Row(a,b)</span><span class="yozora-text">: 第 </span><span class="yozora-inline-math">a</span><span class="yozora-text"> 行要有数字 </span><span class="yozora-inline-math">b</span><span class="yozora-text">；</span></li><li class="yozora-list-item"><span class="yozora-inline-math">Col(a,b)</span><span class="yozora-text">: 第 </span><span class="yozora-inline-math">a</span><span class="yozora-text"> 列要有数字 </span><span class="yozora-inline-math">b</span><span class="yozora-text">；</span></li><li class="yozora-list-item"><span class="yozora-inline-math">Sub(a,b)</span><span class="yozora-text">: 第 </span><span class="yozora-inline-math">a</span><span class="yozora-text"> 个子方阵中要有方阵 </span><span class="yozora-inline-math">c</span><span class="yozora-text">；</span></li></ul><p class="yozora-paragraph"><span class="yozora-text">一共有 </span><span class="yozora-inline-math">x^2 \times x^2 \times 4</span><span class="yozora-text"> 中约束。再考虑可选择的策略，即在第 </span><span class="yozora-inline-math">r</span><span class="yozora-text"> 行第 </span><span class="yozora-inline-math">c</span><span class="yozora-text">
列填入数字 </span><span class="yozora-inline-math">v</span><span class="yozora-text">，且可以满足约束 </span><span class="yozora-inline-math">Slot(r,c)</span><span class="yozora-text">、</span><span class="yozora-inline-math">Row(r,v)</span><span class="yozora-text">、</span><span class="yozora-inline-math">Col(c,v)</span><span class="yozora-text">、
</span><span class="yozora-inline-math">\displaystyle Sub\left(\left\lfloor \frac{r}{x} \right\rfloor \times x + \left\lfloor \frac{c}{x} \right\rfloor,v\right)</span><span class="yozora-text">。</span></p><p class="yozora-paragraph"><span class="yozora-text">代码如下：</span></p><pre class="yozora-code"><code>import { createDLX } from './dlx'

/**
 * @param SUDOKU_SIZE_SQRT 数独子方阵大小（即数独行数的平方根)
 */
export function createSudokuSolver(SUDOKU_SIZE_SQRT: number): SudokuSolver {
  const ebs = 1e-6
  const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT
  const SUDOKU_SIZE_SQUARE = SUDOKU_SIZE * SUDOKU_SIZE
  const MAX_NODES = SUDOKU_SIZE_SQUARE * 4

  let codeA: number, codeB: number, codeC: number
  const columns: number[] = new Array(4)
  const solver = createDLX(MAX_NODES)
  return { solve }

  function solve(puzzle: number[][]): boolean {
    solver.init(MAX_NODES)
    for (let r = 0; r &lt; SUDOKU_SIZE; ++r) {
      for (let c = 0; c &lt; SUDOKU_SIZE; ++c) {
        const w = puzzle[r][c]

        // (r,c) 所属的子方阵编号
        const s =
          Math.floor(r / SUDOKU_SIZE_SQRT + ebs) * SUDOKU_SIZE_SQRT +
          Math.floor(c / SUDOKU_SIZE_SQRT + ebs)
        for (let v = 0; v &lt; SUDOKU_SIZE; ++v) {
          if (w === -1 || w === v) {
            columns[0] = encode(SudokuConstraint.SLOT, r, c)
            columns[1] = encode(SudokuConstraint.ROW, r, v)
            columns[2] = encode(SudokuConstraint.COL, c, v)
            columns[3] = encode(SudokuConstraint.SUB, s, v)
            solver.addRow(encode(r, c, v), columns)
          }
        }
      }
    }

    const answer: number[] | null = solver.solve()
    if (answer === null) return false

    for (const code of answer) {
      decode(code)
      // eslint-disable-next-line no-param-reassign
      puzzle[codeA][codeB] = codeC
    }

    return true
  }

  function encode(a: number, b: number, c: number): number {
    return a * SUDOKU_SIZE_SQUARE + b * SUDOKU_SIZE + c + 1
  }

  function decode(code: number): void {
    let c = code - 1
    codeC = c % SUDOKU_SIZE

    c = Math.floor(c / SUDOKU_SIZE + ebs)
    codeB = c % SUDOKU_SIZE

    c = Math.floor(c / SUDOKU_SIZE + ebs)
    codeA = c
  }
}

/**
 * Sudoku constraints.
 */
export enum SudokuConstraint {
  SLOT = 0, // Slot(a, b) 表示第 a 行 b 列个格子上要有数字
  ROW = 1, // Row(a, b) 表示第 a 行要有数字 b
  COL = 2, // Col(a, b) 表示第 a 列要有数字 b
  SUB = 3, // Sub(a, b) 表示第 a 个子方阵要有数字 b
}

export interface SudokuSolver {
  /**
   * 数独的谜题格子，从 0 开始填，若某个格子未被填，则将其置为 -1
   * @param puzzle
   */
  solve(puzzle: number[][]): boolean
}
</code></pre><p class="yozora-paragraph"><span class="yozora-text">我把求解数独的算法封装在了 </span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" title="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a><span class="yozora-text"> 中，下面是求解 </span><span class="yozora-inline-math">3^2 \times 3^2</span><span class="yozora-text">
数独谜题的示例</span><sup id="reference-footnote-5" class="yozora-footnote-reference"><a href="#footnote-5" title="5">[5]</a></sup><span class="yozora-text">：</span></p><pre class="yozora-code"><code>// import { SudokuSolver, createSudokuBoardData } from '@algorithm.ts/sudoku'
const solver = new SudokuSolver({ childMatrixWidth: 3 })

render()

function SudokuLiveSolver() {
  const [puzzle, setPuzzle] = React.useState(() =&gt; ([
     5,  0,  6,  7,  8, -1, -1,  3,  2,
     1,  4,  2,  3, -1, -1,  8,  7,  6,
     7,  3, -1, -1, -1, -1,  4,  0, -1,
     8,  7,  3,  0,  6, -1, -1,  4,  1,
     2, -1,  5,  1,  4,  3,  0,  8,  7,
    -1,  1, -1,  8, -1, -1, -1, -1, -1,
    -1,  8,  0, -1, -1, -1,  5,  1,  4,
    -1,  5,  1,  4,  0,  6, -1,  2,  8,
    -1, -1,  7,  5,  1,  8, -1,  6, -1
  ]))

  // Resolve sudoku puzzle.
  const solution = React.useMemo(() =&gt; {
    // Solve a sudoku puzzle and write the result into the `solution` array.
    const solution = createSudokuBoardData(solver.size)
    solver.solve(puzzle, solution)
    return solution
  }, [puzzle])

  return (
    
  )
}
</code></pre><h2 class="yozora-heading"><span class="yozora-text">Related</span></h2><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">刘汝佳《算法竞赛入门经典──训练指南》 P406 6.3.3 精确覆盖问题和 DLX 算法</span></li></ul><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，此处并没有构成递归删除，因为只有被选择的行才需要删除行上的其余列，而删除这些列时所删除的其它行并未被选择（被选择行的此时均已被删除），也就不会进一步删除它们的列了。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">每次删除时都是选择一个未被覆盖的列，然后枚举覆盖此列的行，之后删除该行上的其它列。即每次选取了一个集合 </span><span class="yozora-inline-math">s</span><span class="yozora-text">，将目标集合中所有在 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 中出现的数字都删去，同时删除所有与 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 有非空交集的那些集合，也就是每次选择集合都保证了和之前已选择的集合间没有交集。而当目标集合为空时，说明所有数字都在已选择的集合中出现过了，也就是已选择的集合中无重叠、无遗漏的覆盖了目标集合中的所有数字。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">这里指的是虚拟列，即相当于目标集合中的未被覆盖的元素，对应于下文中将提到的舞蹈链中中的列虚拟节点，所以即便所有行都被删除，列虚拟节点构成的链表仍可能不为空。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">在使用数组模拟链表的实现中，虚拟节点用列号表示就行了。而舞蹈链的头指针有
</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 表示即可。需要注意的是，舞蹈链中所有列号均为正整数。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，</span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" title="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a><span class="yozora-text"> 中对于一个 </span><span class="yozora-inline-math">x^2 \times x^2</span><span class="yozora-text">
的数独，使用 </span><span class="yozora-inline-math">[-1, x^2)</span><span class="yozora-text"> 之间的整数作为数独格子的值，其中 </span><span class="yozora-inline-math">-1</span><span class="yozora-text"> 代表对应格子未预置值</span></p></div></div></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-1">&uarr;</a><span>&nbsp;[1]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，此处并没有构成递归删除，因为只有被选择的行才需要删除行上的其余列，而删除这些列时所删除的其它行并未被选择（被选择行的此时均已被删除），也就不会进一步删除它们的列了。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-2">&uarr;</a><span>&nbsp;[2]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">每次删除时都是选择一个未被覆盖的列，然后枚举覆盖此列的行，之后删除该行上的其它列。即每次选取了一个集合 </span><span class="yozora-inline-math">s</span><span class="yozora-text">，将目标集合中所有在 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 中出现的数字都删去，同时删除所有与 </span><span class="yozora-inline-math">s</span><span class="yozora-text"> 有非空交集的那些集合，也就是每次选择集合都保证了和之前已选择的集合间没有交集。而当目标集合为空时，说明所有数字都在已选择的集合中出现过了，也就是已选择的集合中无重叠、无遗漏的覆盖了目标集合中的所有数字。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-3">&uarr;</a><span>&nbsp;[3]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">这里指的是虚拟列，即相当于目标集合中的未被覆盖的元素，对应于下文中将提到的舞蹈链中中的列虚拟节点，所以即便所有行都被删除，列虚拟节点构成的链表仍可能不为空。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-4">&uarr;</a><span>&nbsp;[4]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">在使用数组模拟链表的实现中，虚拟节点用列号表示就行了。而舞蹈链的头指针有
</span><span class="yozora-inline-math">0</span><span class="yozora-text"> 表示即可。需要注意的是，舞蹈链中所有列号均为正整数。</span></p></div></div><div className="yozora-footnote-definition"><p className="yozora-footnote-definition__title yozora-paragraph"><a href="#reference-footnote-5">&uarr;</a><span>&nbsp;[5]:&nbsp;</span></p><div className="yozora-footnote-definition__content"><p class="yozora-paragraph"><span class="yozora-text">需要注意的是，</span><a class="yozora-link" href="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" title="https://github.com/guanghechen/algorithm.ts/blob/main/packages/sudoku/README-zh.md" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">@algorithm.ts/sudoku</span></a><span class="yozora-text"> 中对于一个 </span><span class="yozora-inline-math">x^2 \times x^2</span><span class="yozora-text">
的数独，使用 </span><span class="yozora-inline-math">[-1, x^2)</span><span class="yozora-text"> 之间的整数作为数独格子的值，其中 </span><span class="yozora-inline-math">-1</span><span class="yozora-text"> 代表对应格子未预置值</span></p></div></div></ul></div></footer></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[洗牌问题和 knuth-shuffle 算法]]></title>
            <link>https://me.guanghechen.com/post/algorithm/shuffle</link>
            <guid>https://me.guanghechen.com/post/algorithm/shuffle</guid>
            <pubDate>Wed, 21 Jul 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[<section class="yozora-markdown"><main><p class="yozora-paragraph"><span class="yozora-text">对于给定的 </span><span class="yozora-inline-math">N</span><span class="yozora-text"> 个数，将其公平地随机打乱，使得每个位置上每个数出现的概率相等。</span></p><h2 class="yozora-heading"><span class="yozora-text">约瑟夫环</span></h2><p class="yozora-paragraph"><span class="yozora-text">遍历位置 </span><span class="yozora-inline-math">i</span><span class="yozora-text">，每次从剩余的数中随机取一个放到该位置上。由此可以将问题归约到
</span><a class="yozora-link" href="/post/quiz/classical/Josephus-ring/#heading-%E4%B8%8D%E5%AE%9A%E6%AD%A5%E9%95%BF%E7%9A%84%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98" title="/post/quiz/classical/Josephus-ring/#heading-%E4%B8%8D%E5%AE%9A%E6%AD%A5%E9%95%BF%E7%9A%84%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">不定步长约瑟夫环问题</span></a><span class="yozora-text">，即：</span><span class="yozora-inline-math">N</span><span class="yozora-text"> 个人围坐一圈，从 </span><span class="yozora-inline-math">1</span><span class="yozora-text"> 开始报数，每次随机一个数 </span><span class="yozora-inline-math">x</span><span class="yozora-text">，报到 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 的人从圈中离开，然后进入下一轮游戏。因为需要求离开的顺序，所以不能使用递推法，只能用树状数组+二分，复杂度为：</span></p></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"></ul></div></footer></section>]]></description>
            <content:encoded><![CDATA[<section class="yozora-markdown"><main><p class="yozora-paragraph"><span class="yozora-text">对于给定的 </span><span class="yozora-inline-math">N</span><span class="yozora-text"> 个数，将其公平地随机打乱，使得每个位置上每个数出现的概率相等。</span></p><h2 class="yozora-heading"><span class="yozora-text">约瑟夫环</span></h2><p class="yozora-paragraph"><span class="yozora-text">遍历位置 </span><span class="yozora-inline-math">i</span><span class="yozora-text">，每次从剩余的数中随机取一个放到该位置上。由此可以将问题归约到
</span><a class="yozora-link" href="/post/quiz/classical/Josephus-ring/#heading-%E4%B8%8D%E5%AE%9A%E6%AD%A5%E9%95%BF%E7%9A%84%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98" title="/post/quiz/classical/Josephus-ring/#heading-%E4%B8%8D%E5%AE%9A%E6%AD%A5%E9%95%BF%E7%9A%84%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98" target="_blank" rel="noopener,noreferrer"><span class="yozora-text">不定步长约瑟夫环问题</span></a><span class="yozora-text">，即：</span><span class="yozora-inline-math">N</span><span class="yozora-text"> 个人围坐一圈，从 </span><span class="yozora-inline-math">1</span><span class="yozora-text"> 开始报数，每次随机一个数 </span><span class="yozora-inline-math">x</span><span class="yozora-text">，报到 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 的人从圈中离开，然后进入下一轮游戏。因为需要求离开的顺序，所以不能使用递推法，只能用树状数组+二分，复杂度为：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">时间复杂度： </span><span class="yozora-inline-math">O(N \cdot \log^2 N)</span></li><li class="yozora-list-item"><span class="yozora-text">额外空间复杂度： </span><span class="yozora-inline-math">O(N)</span></li></ul><h2 class="yozora-heading"><span class="yozora-text">knuth-shuffle</span></h2><p class="yozora-paragraph"><span class="yozora-text">进一步考虑，在 shuffle 问题中，我们并不需要保证每个“人”的相对位置不变，也不必每次从上一个被踢的位置开始继续报数，而是只需要保证剩下的“人”被选出来的概率相同即可；如果能让剩下的人始终紧密地聚集到一起，那么利用数组的索引特性，每次 </span><span class="yozora-inline-math">O(1)</span><span class="yozora-text"> 即可选出该轮应该被踢出的“人”。</span></p><h3 class="yozora-heading"><span class="yozora-text">算法描述</span></h3><ol class="yozora-list" start="1"><li class="yozora-list-item"><span class="yozora-text">从第 </span><span class="yozora-inline-math">N</span><span class="yozora-text"> 个位置（最右侧）开始向左遍历位置 </span><span class="yozora-inline-math">i</span></li><li class="yozora-list-item"><span class="yozora-text">每次从最左侧到当前位置 </span><span class="yozora-inline-math">i</span><span class="yozora-text"> 上的所有数中随机选择一个数和当前位置的数进行交换</span></li></ol><p class="yozora-paragraph"><span class="yozora-text">应用上述算法，每个数字出现的概率为：</span></p><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">第 </span><span class="yozora-inline-math">N</span><span class="yozora-text"> 个位置上，每个数出现的概率为：</span><span class="yozora-inline-math">\displaystyle \frac{1}{N}</span></li><li class="yozora-list-item"><span class="yozora-text">第 </span><span class="yozora-inline-math">N-1</span><span class="yozora-text"> 个位置上，每个数出现的概率为：</span><span class="yozora-inline-math">\displaystyle \frac{N-1}{N} \times \frac{1}{N-1}=\frac{1}{N}</span></li><li class="yozora-list-item"><span class="yozora-text">...</span></li><li class="yozora-list-item"><span class="yozora-text">第 </span><span class="yozora-inline-math">x</span><span class="yozora-text"> 个位置上，每个数出现的概率为：</span><span class="yozora-inline-math">\displaystyle \frac{N-1}{N} \times \frac{N-2}{N-1} \times \cdots \times \frac{1}{N-x}=\frac{1}{N}</span></li><li class="yozora-list-item"><span class="yozora-text">...</span></li></ul><h3 class="yozora-heading"><span class="yozora-text">程序实现</span></h3><ul class="yozora-list"><li class="yozora-list-item"><span class="yozora-text">时间复杂度： </span><span class="yozora-inline-math">O(N)</span></li><li class="yozora-list-item"><span class="yozora-text">额外空间复杂度： </span><span class="yozora-inline-math">O(1)</span></li></ul><pre class="yozora-code"><code>export function knuthShuffle(nodes: T[]): void {
  const N = nodes.length
  for (let i = N - 1, j: number, x: T; i &gt; 0; --i) {
    j = Math.floor(Math.random() * (i + 1))
    x = nodes[i]
    nodes[i] = nodes[j]
    nodes[j] = x
  }
}
</code></pre></main><footer><div class="yozora-footnote-definitions"><div class="yozora-footnote-definitions__title">footnote-definitions</div><ul class="yozora-footnote-definitions__main"></ul></div></footer></section>]]></content:encoded>
        </item>
    </channel>
</rss>